<!--
$PostgreSQL: pgsql/doc/src/sgml/func.sgml,v 1.234 2005/01/09 20:08:50 tgl Exp $
PostgreSQL documentation
-->

 <chapter id="functions">
  <title>Funções e Operadores</title>

  <indexterm zone="functions">
   <primary>função</primary>
  </indexterm>

  <indexterm zone="functions">
   <primary>operador</primary>
  </indexterm>

  <para>
   O <productname>PostgreSQL</productname> fornece um grande número de funções
   e operadores para os tipos de dado nativos.
   Os usuários também podem definir suas próprias funções e operadores,
   conforme descrito na <xref linkend="server-programming">.
   Os comandos <command>\df</command> e <command>\do</command> do
   <application>psql</application> podem ser utilizados para mostrar a lista
   de todas as funções e operadores disponíveis, respectivamente.
  </para>

  <para>
   Havendo preocupação quanto à portabilidade, deve-se ter em mente que a
   maioria das funções e operadores descritos neste capítulo, com exceção dos
   operadores mais triviais de aritmética e de comparação, além de algumas
   funções indicadas explicitamente, não são especificadas pelo padrão
   <acronym>SQL</acronym>.
   Algumas das funcionalidades estendidas estão presentes em outros sistemas
   gerenciadores de banco de dados <acronym>SQL</acronym> e, em muitos casos,
   estas funcionalidades são compatíveis e consistentes entre as várias
   implementações.
  </para>


  <sect1 id="functions-logical">
   <title>Operadores lógicos</title>

   <indexterm zone="functions-logical">
    <primary>operador</primary>
    <secondary>lógico</secondary>
   </indexterm>

   <indexterm>
    <primary>Boolean</primary>
    <secondary>operadores</secondary>
    <see>operadores, lógicos</see>
   </indexterm>

   <para>
    Estão disponíveis os operadores lógicos habituais:

    <indexterm>
     <primary>AND (operador)</primary>
    </indexterm>

    <indexterm>
     <primary>OR (operador)</primary>
    </indexterm>

    <indexterm>
     <primary>NOT (operador)</primary>
    </indexterm>

    <indexterm>
     <primary>conjunção</primary>
    </indexterm>

    <indexterm>
     <primary>disjunção</primary>
    </indexterm>

    <indexterm>
     <primary>negação</primary>
    </indexterm>

    <simplelist>
     <member><literal>AND</></member>
     <member><literal>OR</></member>
     <member><literal>NOT</></member>
    </simplelist>

    O <acronym>SQL</acronym> utiliza a lógica booleana de três valores, onde o
    valor nulo representa o <quote>desconhecido</quote>.
    Devem ser observadas as seguintes tabelas verdade:

    <informaltable>
     <tgroup cols="4">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry><replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> AND <replaceable>b</replaceable></entry>
        <entry><replaceable>a</replaceable> OR <replaceable>b</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>TRUE</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>NULL</entry>
        <entry>FALSE</entry>
        <entry>NULL</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>

    <informaltable>
     <tgroup cols="2">
      <thead>
       <row>
        <entry><replaceable>a</replaceable></entry>
        <entry>NOT <replaceable>a</replaceable></entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>TRUE</entry>
        <entry>FALSE</entry>
       </row>

       <row>
        <entry>FALSE</entry>
        <entry>TRUE</entry>
       </row>

       <row>
        <entry>NULL</entry>
        <entry>NULL</entry>
       </row>
      </tbody>
     </tgroup>
    </informaltable>
   </para>

   <para>
    Os operadores <literal>AND</literal> e <literal>OR</literal> são
    comutativos, ou seja, pode-se trocar a ordem dos operandos
    esquerdo e direito sem afetar o resultado. Consulte a <xref
    linkend="syntax-express-eval"> para obter informações adicionais sobre a
    ordem de avaliação das subexpressões.
   </para>
  </sect1>

  <sect1 id="functions-comparison">
   <title>Operadores de comparação</title>

   <indexterm zone="functions-comparison">
    <primary>comparação</primary>
    <secondary>operadores</secondary>
   </indexterm>

   <para>
    Estão disponíveis os operadores de comparação habituais,
    conforme mostrado na <xref linkend="functions-comparison-table">.
   </para>

   <table id="functions-comparison-table">
    <title>Operadores de comparação</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Operador</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>&lt;</literal> </entry>
       <entry>menor</entry>
      </row>

      <row>
       <entry> <literal>&gt;</literal> </entry>
       <entry>maior</entry>
      </row>

      <row>
       <entry> <literal>&lt;=</literal> </entry>
       <entry>menor ou igual</entry>
      </row>

      <row>
       <entry> <literal>&gt;=</literal> </entry>
       <entry>maior ou igual</entry>
      </row>

      <row>
       <entry> <literal>=</literal> </entry>
       <entry>igual</entry>
      </row>

      <row>
       <entry> <literal>&lt;&gt;</literal> ou <literal>!=</literal> </entry>
       <entry>diferente</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <note>
    <para>
     O operador <literal>!=</literal> é convertido em
     <literal>&lt;&gt;</literal> no estágio de análise. Não é possível
     implementar os operadores <literal>!=</literal> e
     <literal>&lt;&gt;</literal> realizando operações diferentes.
    </para>
   </note>

   <para>
    Os operadores de comparação estão disponíveis para todos os tipos de dado
    onde fazem sentido. Todos os operadores de comparação são operadores
    binários, que retornam valores do tipo <type>boolean</type>; expressões como
    <literal>1 &lt; 2 &lt; 3</literal> não são válidas (porque não existe o
    operador <literal>&lt;</literal> para comparar um valor booleano com
    <literal>3</literal>).
   </para>

   <para>
    <indexterm>
     <primary>BETWEEN</primary>
    </indexterm>
    Além dos operadores de comparação, está disponível a construção especial
    <token>BETWEEN</token>.
<synopsis>
<replaceable>a</replaceable> BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    equivale a
<synopsis>
<replaceable>a</replaceable> &gt;= <replaceable>x</replaceable> AND <replaceable>a</replaceable> &lt;= <replaceable>y</replaceable>
</synopsis>
    Analogamente,
<synopsis>
<replaceable>a</replaceable> NOT BETWEEN <replaceable>x</replaceable> AND <replaceable>y</replaceable>
</synopsis>
    equivale a
<synopsis>
<replaceable>a</replaceable> &lt; <replaceable>x</replaceable> OR <replaceable>a</replaceable> &gt; <replaceable>y</replaceable>
</synopsis>
    Não existe diferença entre as duas formas, além dos ciclos
    de <acronym>CPU</acronym> necessários para reescrever
    a primeira forma na segunda internamente.
   </para>

   <para>
    <indexterm>
     <primary>IS NULL</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT NULL</primary>
    </indexterm>
    <indexterm>
     <primary>ISNULL</primary>
    </indexterm>
    <indexterm>
     <primary>NOTNULL</primary>
    </indexterm>
    Para verificar se um valor é nulo ou não, são usadas as construções
<synopsis>
<replaceable>expressão</replaceable> IS NULL
<replaceable>expressão</replaceable> IS NOT NULL
</synopsis>
    ou às construções equivalentes, mas fora do padrão,
<synopsis>
<replaceable>expressão</replaceable> ISNULL
<replaceable>expressão</replaceable> NOTNULL
</synopsis>
    <indexterm><primary>valor nulo</primary><secondary>comparação</secondary></indexterm>
   </para>

   <para>
    <emphasis>Não</emphasis> deve ser escrito
    <literal><replaceable>expressão</replaceable> = NULL</literal>,
    porque <literal>NULL</literal> não é <quote>igual a</quote>
    <literal>NULL</literal> (O valor nulo representa um valor desconhecido,
    e não se pode saber se dois valores desconhecidos são iguais).
    Este comportamento está de acordo com o padrão SQL.
   </para>

  <tip>
   <para>
    Alguns aplicativos podem (incorretamente) esperar que
    <literal><replaceable>expressão</replaceable> = NULL</literal> retorne
    verdade se o resultado da <replaceable>expressão</replaceable> for o
    valor nulo.
    É altamente recomendado que estes aplicativos sejam modificadas para ficarem
    em conformidade com o padrão SQL.
    Entretanto, se isto não puder ser feito, está disponível a variável de
    configuração <xref linkend="guc-transform-null-equals">.
    Quando <xref linkend="guc-transform-null-equals"> está habilitada, o
    <productname>PostgreSQL</productname> converte as cláusulas
    <literal>x = NULL</literal> em <literal>x IS NULL</literal>.
    Este foi o comportamento padrão do <productname>PostgreSQL</productname>
    nas versões de 6.5 a 7.1.
   </para>
  </tip>

   <para>
    <indexterm>
     <primary>IS DISTINCT FROM</primary>
    </indexterm>
    O resultado dos operadores de comparação comuns é nulo (significando
    <quote>desconhecido</>), quando algum dos operandos é nulo.
    Outra forma de fazer comparação é com a construção
    <literal>IS DISTINCT FROM</literal>:
<synopsis>
<replaceable>expressão</replaceable> IS DISTINCT FROM <replaceable>expressão</replaceable>
</synopsis>
    Para expressões não-nulas é o mesmo que o operador <literal>&lt;&gt;</>.
    Entretanto, quando as duas expressões são nulas retorna falso, e quando
    apenas uma expressão é nula retorna verdade. Portanto, atua efetivamente como
    se nulo fosse um valor de dado normal, em vez de <quote>desconhecido</>.
   </para>

   <para>
    <indexterm>
     <primary>IS TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT TRUE</primary>
    </indexterm>
    <indexterm>
     <primary>IS FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT FALSE</primary>
    </indexterm>
    <indexterm>
     <primary>IS UNKNOWN</primary>
    </indexterm>
    <indexterm>
     <primary>IS NOT UNKNOWN</primary>
    </indexterm>
    Os valores booleanos também podem ser testados utilizando as construções
<synopsis>
<replaceable>expressão</replaceable> IS TRUE
<replaceable>expressão</replaceable> IS NOT TRUE
<replaceable>expressão</replaceable> IS FALSE
<replaceable>expressão</replaceable> IS NOT FALSE
<replaceable>expressão</replaceable> IS UNKNOWN
<replaceable>expressão</replaceable> IS NOT UNKNOWN
</synopsis>
    Estas formas sempre retornam verdade ou falso, e nunca o valor nulo,
    mesmo quando o operando é nulo.
    A entrada nula é tratada como o valor lógico <quote>desconhecido</>.
    Deve ser observado que <literal>IS UNKNOWN</> e <literal>IS NOT UNKNOWN</>
    são efetivamente o mesmo que <literal>IS NULL</literal> e
    <literal>IS NOT NULL</literal>, respectivamente, exceto que a expressão
    de entrada deve ser do tipo booleana.
   </para>
  </sect1>

  <sect1 id="functions-math">
   <title>Funções e operadores matemáticos</title>

   <para>
    São fornecidos operadores matemáticos para muitos tipos de dado do
    <productname>PostgreSQL</productname>. Para os tipos sem as
    convenções matemáticas habituais para todas as permutações possíveis
    (por exemplo, os tipos de data e hora), o
    comportamento real é descrito nas próximas seções.
   </para>

   <para>
    A <xref linkend="functions-math-op-table"> mostra os operadores matemáticos disponíveis.
   </para>

   <table id="functions-math-op-table">
    <title>Operadores matemáticos</title>

    <tgroup cols="4">
     <thead>
      <row>
       <entry>Operador</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>+</literal> </entry>
       <entry>adição</entry>
       <entry><literal>2 + 3</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>-</literal> </entry>
       <entry>subtração</entry>
       <entry><literal>2 - 3</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry> <literal>*</literal> </entry>
       <entry>multiplicação</entry>
       <entry><literal>2 * 3</literal></entry>
       <entry><literal>6</literal></entry>
      </row>

      <row>
       <entry> <literal>/</literal> </entry>
       <entry>divisão (divisão inteira trunca o resultado)</entry>
       <entry><literal>4 / 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry> <literal>%</literal> </entry>
       <entry>módulo (resto)</entry>
       <entry><literal>5 % 4</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry> <literal>^</literal> </entry>
       <entry>exponenciação</entry>
       <entry><literal>2.0 ^ 3.0</literal></entry>
       <entry><literal>8</literal></entry>
      </row>

      <row>
       <entry> <literal>|/</literal> </entry>
       <entry>raiz quadrada</entry>
       <entry><literal>|/ 25.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>||/</literal> </entry>
       <entry>raiz cúbica</entry>
       <entry><literal>||/ 27.0</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry> <literal>!</literal> </entry>
       <entry>fatorial</entry>
       <entry><literal>5 !</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>!!</literal> </entry>
       <entry>fatorial (operador de prefixo)</entry>
       <entry><literal>!! 5</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry> <literal>@</literal> </entry>
       <entry>valor absoluto</entry>
       <entry><literal>@ -5.0</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <entry>AND bit a bit</entry>
       <entry><literal>91 &amp; 15</literal></entry>
       <entry><literal>11</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <entry>OR bit a bit</entry>
       <entry><literal>32 | 3</literal></entry>
       <entry><literal>35</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <entry>XOR bit a bit</entry>
       <entry><literal>17 # 5</literal></entry>
       <entry><literal>20</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <entry>NOT bit a bit</entry>
       <entry><literal>~1</literal></entry>
       <entry><literal>-2</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <entry>deslocamento à esquerda bit a bit</entry>
       <entry><literal>1 &lt;&lt; 4</literal></entry>
       <entry><literal>16</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <entry>deslocamento à direita bit a bit</entry>
       <entry><literal>8 &gt;&gt; 2</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <para>
    Os operadores bit a bit
    <footnote>
     <para>
      <literal>bitwise</literal> &mdash; um operador bit a bit trata seus
      operandos como um vetor de bits, em vez de como um único número.
      <ulink url="http://wombat.doc.ic.ac.uk/foldoc/foldoc.cgi?query=bitwise">
      FOLDOC - Free On-Line Dictionary of Computing</ulink> (N. do T.)
     </para>
    </footnote>
    trabalham somente em tipos de dado inteiros, enquanto os demais estão
    disponíveis para todos os tipos de dado numéricos.
    Os operadores bit a bit também estão disponíveis para os tipos cadeia de
    bits <type>bit</type> e <type>bit varying</type>, conforme
    mostrado na <xref linkend="functions-bit-string-op-table">.
   </para>

  <para>
   A <xref linkend="functions-math-func-table"> mostra as funções
   matemáticas disponíveis. Nesta tabela <quote>dp</quote> significa
   <type>double precision</type>. Muitas destas funções são fornecidas
   em várias formas, com diferentes tipos de dado dos argumentos.
   Exceto onde estiver indicado, todas as formas das funções retornam o mesmo
   tipo de dado de seu argumento.
   As funções que trabalham com dados do tipo <type>double precision</type> são,
   em sua maioria, implementadas usando a biblioteca C do sistema hospedeiro;
   a precisão e o comportamento em casos limites podem, portanto, variar
   dependendo do sistema hospedeiro.
  </para>

   <table id="functions-math-func-table">
    <title>Funções matemáticas</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Tipo retornado</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>abs</>(<replaceable>x</replaceable>)</literal></entry>
       <entry>(o mesmo de <replaceable>x</replaceable>)</entry>
       <entry>valor absoluto</entry>
       <entry><literal>abs(-17.4)</literal></entry>
       <entry><literal>17.4</literal></entry>
      </row>

      <row>
       <entry><literal><function>cbrt</function>(<type>dp</type>)</literal></entry>
       <entry><type>dp</type></entry>
       <entry>raiz cúbica</entry>
       <entry><literal>cbrt(27.0)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>ceil</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>o menor inteiro não menor que o argumento</entry>
       <entry><literal>ceil(-42.8)</literal></entry>
       <entry><literal>-42</literal></entry>
      </row>

      <row>
       <entry><literal><function>ceiling</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>o menor inteiro não menor que o argumento (o mesmo que <function>ceil</function>)</entry>
       <entry><literal>ceiling(-95.3)</literal></entry>
       <entry><literal>-95</literal></entry>
      </row>

      <row>
       <entry><literal><function>degrees</function>(<type>dp</type>)</literal></entry>
       <entry><type>dp</type></entry>
       <entry>radianos para graus</entry>
       <entry><literal>degrees(0.5)</literal></entry>
       <entry><literal>28.6478897565412</literal></entry>
      </row>

      <row>
       <entry><literal><function>exp</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>exponenciação</entry>
       <entry><literal>exp(1.0)</literal></entry>
       <entry><literal>2.71828182845905</literal></entry>
      </row>

      <row>
       <entry><literal><function>floor</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>o maior inteiro não maior que o argumento</entry>
       <entry><literal>floor(-42.8)</literal></entry>
       <entry><literal>-43</literal></entry>
      </row>

      <row>
       <entry><literal><function>ln</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>logaritmo natural</entry>
       <entry><literal>ln(2.0)</literal></entry>
       <entry><literal>0.693147180559945</literal></entry>
      </row>

      <row>
       <entry><literal><function>log</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>logaritmo na base 10</entry>
       <entry><literal>log(100.0)</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>log</function>(<parameter>b</parameter> <type>numeric</type>,
        <parameter>x</parameter> <type>numeric</type>)</literal></entry>
       <entry><type>numeric</type></entry>
       <entry>logaritmo na base <parameter>b</parameter></entry>
       <entry><literal>log(2.0, 64.0)</literal></entry>
       <entry><literal>6.0000000000</literal></entry>
      </row>

      <row>
       <entry><literal><function>mod</function>(<parameter>y</parameter>,
        <parameter>x</parameter>)</literal></entry>
       <entry>(same as argument types)</entry>
       <entry>resto de <parameter>y</parameter>/<parameter>x</parameter></entry>
       <entry><literal>mod(9,4)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry><literal><function>pi</function>()</literal></entry>
       <entry><type>dp</type></entry>
       <entry>constante <quote>&pi;</quote></entry>
       <entry><literal>pi()</literal></entry>
       <entry><literal>3.14159265358979</literal></entry>
      </row>

      <row>
       <entry><literal><function>power</function>(<parameter>a</parameter> <type>dp</type>,
        <parameter>b</parameter> <type>dp</type>)</literal></entry>
       <entry><type>dp</type></entry>
       <entry><parameter>a</> elevado a <parameter>b</parameter></entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>power</function>(<parameter>a</parameter> <type>numeric</type>,
        <parameter>b</parameter> <type>numeric</type>)</literal></entry>
       <entry><type>numeric</type></entry>
       <entry><parameter>a</> elevado a <parameter>b</parameter></entry>
       <entry><literal>power(9.0, 3.0)</literal></entry>
       <entry><literal>729</literal></entry>
      </row>

      <row>
       <entry><literal><function>radians</function>(<type>dp</type>)</literal></entry>
       <entry><type>dp</type></entry>
       <entry>graus para radianos</entry>
       <entry><literal>radians(45.0)</literal></entry>
       <entry><literal>0.785398163397448</literal></entry>
      </row>

      <row>
       <entry><literal><function>random</function>()</literal></entry>
       <entry><type>dp</type></entry>
       <entry>valor randômico entre 0.0 e 1.0</entry>
       <entry><literal>random()</literal></entry>
       <entry></entry>
      </row>

      <row>
       <entry><literal><function>round</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>arredondar para o inteiro mais próximo</entry>
       <entry><literal>round(42.4)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>round</function>(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type>)</literal></entry>
       <entry><type>numeric</type></entry>
       <entry>arredondar para <parameter>s</parameter> casas decimais</entry>
       <entry><literal>round(42.4382, 2)</literal></entry>
       <entry><literal>42.44</literal></entry>
      </row>

      <row>
       <entry><literal><function>setseed</function>(<type>dp</type>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>define a semente para as próximas chamadas a <literal>random()</literal></entry>
       <entry><literal>setseed(0.54823)</literal></entry>
       <entry><literal>1177314959</literal></entry>
      </row>

      <row>
       <entry><literal><function>sign</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>sinal do argumento (-1, 0, +1)</entry>
       <entry><literal>sign(-8.4)</literal></entry>
       <entry><literal>-1</literal></entry>
      </row>

      <row>
       <entry><literal><function>sqrt</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>raiz quadrada</entry>
       <entry><literal>sqrt(2.0)</literal></entry>
       <entry><literal>1.4142135623731</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
       <entry>(o mesmo da entrada)</entry>
       <entry>trunca em direção ao zero</entry>
       <entry><literal>trunc(42.8)</literal></entry>
       <entry><literal>42</literal></entry>
      </row>

      <row>
       <entry><literal><function>trunc</function>(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type>)</literal></entry>
       <entry><type>numeric</type></entry>
       <entry>trunca com <parameter>s</parameter> casas decimais</entry>
       <entry><literal>trunc(42.4382, 2)</literal></entry>
       <entry><literal>42.43</literal></entry>
      </row>

      <row>
       <entry><literal><function>width_bucket</function>(<parameter>operando</parameter> <type>numeric</type>, <parameter>b1</parameter> <type>numeric</type>, <parameter>b2</parameter> <type>numeric</type>, <parameter>contador</parameter> <type>integer</type>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>retorna a barra à qual o <parameter>operando</> seria atribuído,
       em um histograma <literal>equidepth</literal> com <parameter>contador</>
       barras, um limite superior de <parameter>b1</>, e um limite inferior de
       <parameter>b2</></entry>
       <entry><literal>width_bucket(5.35, 0.024, 10.06, 5)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   A <xref linkend="functions-math-trig-table"> mostra as
   funções trigonométricas disponíveis. Todas as funções trigonométricas
   recebem argumentos e retornam valores do tipo <type>double
   precision</type>.
  </para>

   <table id="functions-math-trig-table">
    <title>Funções trigonométricas</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>acos</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>arco cosseno</entry>
      </row>

      <row>
       <entry><literal><function>asin</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>arco seno</entry>
      </row>

      <row>
       <entry><literal><function>atan</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>arco tangente</entry>
      </row>

      <row>
       <entry><literal><function>atan2</function>(<replaceable>x</replaceable>,
        <replaceable>y</replaceable>)</literal></entry>
       <entry>arco tangente de
        <literal><replaceable>x</replaceable>/<replaceable>y</replaceable></literal></entry>
      </row>

      <row>
       <entry><literal><function>cos</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>cosseno</entry>
      </row>

      <row>
       <entry><literal><function>cot</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>cotangente</entry>
      </row>

      <row>
       <entry><literal><function>sin</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>seno</entry>
      </row>

      <row>
       <entry><literal><function>tan</function>(<replaceable>x</replaceable>)</literal></entry>
       <entry>tangente</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    A <xref linkend="func-math-table-pg-ora-mssql"> compara as funções
    matemáticas e trigonométricas do
    <ulink url="http://www.stanford.edu/dept/itss/docs/oracle/9i/server.920/a96540/functions2a.htm">
    Oracle</ulink>, do
    <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/tsqlref/ts_fa-fz_24c3.asp">
    SQL Server</ulink>, do
    <ulink url="ftp://ftp.software.ibm.com/ps/products/db2/info/vr82/pdf/en_US/db2s1e81.pdf">
    DB2</ulink>
    e do <productname>PostgreSQL &version;</productname>.
   </para>

   <note>
    <para>
     Tabela escrita pelo tradutor, não fazendo parte do manual original.
    </para>
   </note>

   <table id="func-math-table-pg-ora-mssql">
    <title>
     Funções matemáticas e trigonométricas do Oracle 9i, do SQL Server 2000, do
     DB2 8.1 e do PostgreSQL &version;
    </title>

    <tgroup cols="5">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Oracle 9i
        <footnote>
         <para>
          <productname>Oracle 9i</productname> &mdash; As funções numéricas
          recebem entradas numéricas e retornam valores numéricos.
          A maior parte destas funções retornam valores com precisão de 38
          dígitos decimais.
          As funções transcendentais COS, COSH, EXP, LN, LOG, SIN, SINH, SQRT,
          TAN e TANH têm precisão de 36 dígitos decimais.
          As funções transcendentais ACOS, ASIN, ATAN e ATAN2 têm precisão de
          30 dígitos decimais.
         </para>
         </footnote>
       </entry>
       <entry>SQL Server 2000
        <footnote>
         <para>
          <productname>SQL Server 2000</productname> &mdash;
          As funções aritméticas, tais como ABS, CEILING, DEGREES, FLOOR,
          POWER, RADIANS e SIGN, retornam um valor que possui o mesmo tipo
          de dado do valor da entrada.
          As funções trigonométricas e as demais funções, incluindo EXP, LOG,
          LOG10, SQUARE e SQRT convertem seus valores de entrada em ponto
          flutuante, e retornam um valor de ponto flutuante.
          Todas as funções matemáticas, exceto RAND, são funções
          determinísticas; retornam o mesmo resultado toda vez que são chamadas
          com um determinado conjunto de valores de entrada. RAND só é
          determinística quando é especificado o parâmetro semente.
         </para>
         </footnote>
       </entry>
       <entry>DB2 8.1</entry>
       <entry>PostgreSQL &version;</entry>
      </row>
     </thead>
     <tbody>
      <row>
       <entry>valor absoluto</entry>
       <entry><literal><function>abs</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>abs</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>abs</function>(<parameter>n</parameter>)</literal> ou
              <literal><function>absval</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>abs</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>arco cosseno</entry>
       <entry><literal><function>acos</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>acos</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>acos</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>acos</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>arco seno</entry>
       <entry><literal><function>asin</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>asin</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>asin</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>asin</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>arco tangente de n</entry>
       <entry><literal><function>atan</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>atan</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>atan</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>atan</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>arco tangente de x/y</entry>
       <entry><literal><function>atan2</function>(<parameter>n</parameter>, <parameter>m</parameter>)</literal></entry>
       <entry><literal><function>atn2</function>(<parameter>f</parameter>, <parameter>f</parameter>)</literal></entry>
       <entry><literal><function>atan2</function>(<parameter>d</parameter>, <parameter>d</parameter>)</literal></entry>
       <entry><literal><function>atan2</function>(<parameter>x</parameter>, <parameter>y</parameter>)</literal></entry>
      </row>
      <row>
       <entry>raiz cúbica</entry>
       <entry>-</entry>
       <entry>-</entry>
       <entry>-</entry>
       <entry><literal><function>cbrt</function>(<type>dp</type>)</literal></entry>
      </row>
      <row>
       <entry>menor inteiro não menor que o argumento</entry>
       <entry><literal><function>ceil</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>ceiling</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>ceil</function>(<parameter>n</parameter>)</literal> ou
              <literal><function>ceiling</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>ceil</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>cosseno</entry>
       <entry><literal><function>cos</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>cos</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>cos</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>cos</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>cosseno hiperbólico</entry>
       <entry><literal><function>cosh</function>(<parameter>n</parameter>)</literal></entry>
       <entry>-</entry>
       <entry>-</entry>
       <entry>-</entry>
      </row>
      <row>
       <entry>cotangente</entry>
       <entry>-</entry>
       <entry><literal><function>cot</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>cot</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>cot</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>radianos para graus</entry>
       <entry>-</entry>
       <entry><literal><function>degrees</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>degrees</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>degrees</function>(<type>dp</type>)</literal></entry>
      </row>
      <row>
       <entry>exponenciação</entry>
       <entry><literal><function>exp</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>exp</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>exp</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>exp</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>maior inteiro não maior que o argumento</entry>
       <entry><literal><function>floor</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>floor</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>floor</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>floor</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>logaritmo natural</entry>
       <entry><literal><function>ln</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>log</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>ln</function>(<parameter>d</parameter>)</literal> ou
              <literal><function>log</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>ln</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>logaritmo, qualquer base</entry>
       <entry><literal><function>log</function>(<parameter>m</parameter>, <parameter>n</parameter>)</literal></entry>
       <entry>-</entry>
       <entry>-</entry>
       <entry><literal><function>log</function>(<parameter>b</parameter> <type>numeric</type>, <parameter>x</parameter> <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>logaritmo, base 10</entry>
       <entry><literal><function>log</function>(10, <parameter>n</parameter>)</literal></entry>
       <entry><literal><function>log10</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>log10</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>log</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>módulo (resto)</entry>
       <entry><literal><function>mod</function>(<parameter>m</parameter>, <parameter>n</parameter>)</literal></entry>
       <entry><literal>dividendo % divisor</literal></entry>
       <entry><literal><function>mod</function>(<parameter>n</parameter>, <parameter>n</parameter>)</literal></entry>
       <entry><literal><function>mod</function>(<parameter>y</parameter>, <parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>constante &pi;</entry>
       <entry>-</entry>
       <entry><literal><function>pi</function>()</literal></entry>
       <entry>-</entry>
       <entry><literal><function>pi</function>()</literal></entry>
      </row>
      <row>
       <entry>potenciação</entry>
       <entry><literal><function>power</function>(<parameter>m</parameter>, <parameter>n</parameter>)</literal></entry>
       <entry><literal><function>power</function>(<parameter>n</parameter>, <parameter>y</parameter>)</literal></entry>
       <entry><literal><function>power</function>(<parameter>n</parameter>, <parameter>n</parameter>)</literal></entry>
       <entry><literal>
       <function>pow</function>(<parameter>a</parameter> <type>dp</type>, <parameter>b</parameter> <type>dp</type>) e
       <function>pow</function>(<parameter>a</parameter> <type>numeric</type>, <parameter>b</parameter> <type>numeric</type>)
       </literal></entry>
      </row>
      <row>
       <entry>radianos</entry>
       <entry>-</entry>
       <entry><literal><function>radians</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>radians</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>radians</function>(<type>dp</type>)</literal></entry>
      </row>
      <row>
       <entry>número randômico</entry>
       <entry>-</entry>
       <entry><literal><function>rand</function>()</literal></entry>
       <entry><literal><function>rand</function>()</literal></entry>
       <entry><literal><function>random</function>()</literal></entry>
      </row>
      <row>
       <entry>arredondar para o inteiro mais próximo</entry>
       <entry><literal><function>round</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>round</function>(<parameter>n</parameter>,0)</literal></entry>
       <entry><literal><function>round</function>(<parameter>n</parameter>,0)</literal></entry>
       <entry><literal><function>round</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>arredondar para s casas decimais</entry>
       <entry><literal><function>round</function>(<parameter>n</parameter> [,<parameter>s</parameter> <type>integer</type>])</literal></entry>
       <entry><literal><function>round</function>(<parameter>n</parameter>, <parameter>s</parameter> <type>integer</type> [,<parameter>função</parameter>])</literal></entry>
       <entry><literal><function>round</function>(<parameter>n</parameter>, <parameter>s</parameter> <type>integer</type>)</literal></entry>
       <entry><literal><function>round</function>(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type>)</literal></entry>
      </row>
      <row>
       <entry>define a semente para as próximas chamadas a random()</entry>
       <entry>-</entry>
       <entry><literal><function>rand</function>(<parameter>semente</parameter>)</literal></entry>
       <entry><literal><function>rand</function>(<parameter>semente</parameter>)</literal></entry>
       <entry><literal><function>setseed</function>(<type>dp</type>)</literal></entry>
      </row>
      <row>
       <entry>sinal do argumento (-1, 0, +1)</entry>
       <entry><literal><function>sign</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>sign</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>sign</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>sign</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>seno</entry>
       <entry><literal><function>sin</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>sin</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>sin</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>sin</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>seno hiperbólico</entry>
       <entry><literal><function>sinh</function>(<parameter>n</parameter>)</literal></entry>
       <entry>-</entry>
       <entry>-</entry>
       <entry>-</entry>
      </row>
      <row>
       <entry>raiz quadrada</entry>
       <entry><literal><function>sqrt</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>sqrt</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>sqrt</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>sqrt</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
       <entry>tangente</entry>
       <entry><literal><function>tan</function>(<parameter>n</parameter>)</literal></entry>
       <entry><literal><function>tan</function>(<parameter>f</parameter>)</literal></entry>
       <entry><literal><function>tan</function>(<parameter>d</parameter>)</literal></entry>
       <entry><literal><function>tan</function>(<parameter>x</parameter>)</literal></entry>
      </row>
      <row>
       <entry>tangente hiperbólica</entry>
       <entry><literal><function>tanh</function>(<parameter>n</parameter>)</literal></entry>
       <entry>-</entry>
       <entry>-</entry>
       <entry>-</entry>
      </row>
      <row>
       <entry>trunca em direção ao zero</entry>
       <entry><literal><function>trunc</function>(<parameter>n</parameter>)</literal></entry>
       <entry>-</entry>
       <entry><literal><function>trunc</function>(<parameter>n</parameter>, 0)</literal></entry>
       <entry><literal><function>trunc</function>(<type>dp</type> ou <type>numeric</type>)</literal></entry>
      </row>
      <row>
      <entry>trunca com s casas decimais</entry>
       <entry><literal><function>trunc</function>(<parameter>n</parameter> [,<parameter>s</parameter> <type>integer</type>])</literal></entry>
       <entry>-</entry>
       <entry><literal><function>trunc</function>(<parameter>n</parameter> ,<parameter>s</parameter> <type>integer</type>)</literal></entry>
       <entry><literal><function>trunc</function>(<parameter>v</parameter> <type>numeric</type>, <parameter>s</parameter> <type>integer</type>)</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>
  </sect1>


  <sect1 id="functions-string">
   <title>Funções e operadores para cadeias de caracteres</title>

   <para>
    Esta seção descreve as funções e operadores disponíveis para examinar e
    manipular valores cadeia de caracteres. Neste contexto, cadeia de caracteres
    inclui todos os valores dos tipos <type>character</type>, <type>character
    varying</type> e <type>text</type>. A menos que seja dito o contrário, todas
    as funções relacionadas abaixo trabalham com todos estes tipos, mas se deve
    tomar cuidado com os efeitos em potencial do preenchimento automático quando
    for utilizado o tipo <type>character</type>. De modo geral, as funções
    descritas nesta seção também trabalham com dados de tipos que não são
    cadeias de caracteres, convertendo estes dados primeiro na representação de
    cadeia de caracteres. Algumas funções também existem em forma nativa para
    os tipos cadeia de bits.
   </para>

   <para>
    O <acronym>SQL</acronym> define algumas funções para cadeias de caracteres
    com uma sintaxe especial, onde certas palavras chave, em vez de vírgulas,
    são utilizadas para separar os argumentos. Os detalhes estão na
    <xref linkend="functions-string-sql">.
    Estas funções também são implementadas utilizando a sintaxe regular de
    chamada de função (Consulte a <xref linkend="functions-string-other">).
   </para>

   <table id="functions-string-sql">
    <title>Funções e operadores SQL para cadeias de caracteres</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Tipo retornado</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>cadeia_de_caracteres</parameter> <literal>||</literal>
        <parameter>cadeia_de_caracteres</parameter></literal></entry>
       <entry> <type>text</type> </entry>
       <entry>
        Concatenação de cadeias de caracteres
        <indexterm>
         <primary>cadeia de caracteres</primary>
         <secondary>concatenação</secondary>
        </indexterm>
       </entry>
       <entry><literal>'Post' || 'greSQL'</literal></entry>
       <entry><literal>PostgreSQL</literal></entry>
      </row>

      <row>
       <entry><literal><function>bit_length</function>(<parameter>cadeia_de_caracteres</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>Número de bits na cadeia de caracteres</entry>
       <entry><literal>bit_length('José')</literal></entry>
       <entry><literal>32</literal></entry>
      </row>

      <row>
       <entry><literal><function>char_length</function>(<parameter>cadeia_de_caracteres</parameter>)</literal> ou <literal><function>character_length</function>(<parameter>cadeia_de_caracteres</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>
        Número de caracteres na cadeia de caracteres
        <indexterm>
         <primary>cadeia de caracteres</primary>
         <secondary>comprimento - função char_length()</secondary>
        </indexterm>
        <indexterm>
         <primary>comprimento</primary>
         <secondary sortas="cadeia de caracteres">de uma cadeia de caracteres</secondary>
         <see>cadeia de caracteres, comprimento</see>
        </indexterm>
       </entry>
       <entry><literal>char_length('José')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>convert</function>(<parameter>cadeia_de_caracteres</parameter>
       using <parameter>nome_da_conversão</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Muda a codificação utilizando o nome de conversão especificado. As conversões
        podem ser definidas pelo comando <command>CREATE CONVERSION</command>.
        Além disso, existem alguns nomes de conversão pré-definidos. Veja na
        <xref linkend="conversion-names"> os nomes de conversão disponíveis.
       </entry>
       <entry><literal>convert('PostgreSQL' using iso_8859_1_to_utf_8)</literal></entry>
       <entry><literal>'PostgreSQL'</literal> na codificação Unicode (UTF-8)</entry>
      </row>

      <row>
       <entry><literal><function>lower</function>(<parameter>cadeia_de_caracteres</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Converte as letras da cadeia de caracteres em minúsculas</entry>
       <entry><literal>lower('SÃO')</literal></entry>
       <entry><literal>sÃo</literal></entry>
      </row>

      <row>
       <entry><literal><function>octet_length</function>(<parameter>cadeia_de_caracteres</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>Número de bytes na cadeia de caracteres</entry>
       <entry><literal>octet_length('José')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry><literal><function>overlay</function>(<parameter>cadeia_de_caracteres</parameter> placing <parameter>cadeia_de_caracteres</parameter> from <type>integer</type> <optional>for <type>integer</type></optional>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Substituir parte da cadeia de caracteres (sobreposição)
        <indexterm>
         <primary>overlay</primary>
        </indexterm>
       </entry>
       <entry><literal>overlay('Txxxxas' placing 'hom' from 2 for 4)</literal></entry>
       <entry><literal>Thomas</literal></entry>
      </row>

      <row>
       <entry><literal><function>position</function>(<parameter>substring</parameter> in <parameter>cadeia_de_caracteres</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>Posição da subcadeia de caracteres</entry>
       <entry><literal>position('om' in 'Thomas')</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring</function>(<parameter>cadeia_de_caracteres</parameter> <optional>from <type>integer</type></optional> <optional>for <type>integer</type></optional>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Extrai parte da cadeia de caracteres
        <indexterm>
         <primary>substring</primary>
        </indexterm>
       </entry>
       <entry><literal>substring('Thomas' from 2 for 3)</literal></entry>
       <entry><literal>hom</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring</function>(<parameter>cadeia_de_caracteres</parameter> from <replaceable>padrão</replaceable>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Extrai a parte da cadeia de caracteres correspondente à
        <ulink url="http://unixhelp.ed.ac.uk/CGI/man-cgi?regex+7">expressão regular POSIX</ulink>
        <footnote>
         <para>
          Nos sistemas <literal>*nix</literal> execute
          <literal>man 7 regex</literal> para ver
          uma descrição das expressões regulares POSIX 1003.2. (N. do T.)
         </para>
        </footnote>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
       </entry>
       <entry><literal>substring('Thomas' from '...$')</literal></entry>
       <entry><literal>mas</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring</function>(<parameter>cadeia_de_caracteres</parameter> from <replaceable>padrão</replaceable> for <replaceable>escape</replaceable>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Extrai a parte da cadeia de caracteres correspondente
        à expressão regular <acronym>SQL</acronym>
        <indexterm>
         <primary>substring</primary>
        </indexterm>
       </entry>
       <entry><literal>substring('Thomas' from '%#"o_a#"_' for '#')</literal></entry>
       <entry><literal>oma</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim</function>(<optional>leading | trailing | both</optional>
        <optional><parameter>caracteres</parameter></optional> from
        <parameter>cadeia_de_caracteres</parameter>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Remove a cadeia de caracteres mais longa contendo apenas os
        <parameter>caracteres</parameter> (espaço por padrão) da extremidade
        inicial/final/ambas da <parameter>cadeia_de_caracteres</parameter>.
       </entry>
       <entry><literal>trim(both 'x' from 'xTomxx')</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry><literal><function>upper</function>(<parameter>cadeia_de_caracteres</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Converte as letras da cadeia de caracteres em maiúsculas</entry>
       <entry><literal>upper('são')</literal></entry>
       <entry><literal>SãO</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Estão disponíveis funções adicionais para manipulação de cadeias de
    caracteres, conforme mostrado na <xref linkend="functions-string-other">.
    Algumas delas são utilizadas internamente para implementar funções de
    cadeia de caracteres do padrão <acronym>SQL</acronym>, conforme mostrado na
    <xref linkend="functions-string-sql">.
   </para>

   <table id="functions-string-other">
    <title>Outras funções para cadeia de caracteres</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Tipo retornado</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>ascii</function>(<type>text</type>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>código <acronym>ASCII</acronym> do primeiro caractere do argumento</entry>
       <entry><literal>ascii('x')</literal></entry>
       <entry><literal>120</literal></entry>
      </row>

      <row>
       <entry><literal><function>btrim</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>
       <optional>, <parameter>caracteres</parameter> <type>text</type></optional>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Remove a maior cadeia de caracteres contendo apenas os caracteres
        presentes em <parameter>caracteres</parameter> (espaço por padrão),
        do início e do fim da <parameter>cadeia_de_caracteres</parameter>
       </entry>
       <entry><literal>btrim('xyxtrimyyx', 'xy')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry><literal><function>chr</function>(<type>integer</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Caractere com o código <acronym>ASCII</acronym> fornecido</entry>
       <entry><literal>chr(65)</literal></entry>
       <entry><literal>A</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>convert</function>(<parameter>cadeia_de_caracteres</parameter>
        <type>text</type>,
        <optional><parameter>codificação_de_origem</parameter> <type>name</type>,</optional>
        <parameter>codificação_de_destino</parameter> <type>name</type>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Converte a cadeia de caracteres na <parameter>codificação_de_destino</parameter>.
        A codificação de origem é especificada por
        <parameter>codificação_de_origem</parameter>. Se a
        <parameter>codificação_de_origem</parameter> for omitida,
        será assumida a codificação do banco de dados.
       </entry>
       <entry><literal>convert( 'texto_em_unicode', 'UNICODE', 'LATIN1')</literal></entry>
       <entry>Representação na codificação ISO 8859-1 do <literal>texto_em_unicode</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>decode</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>,
        <parameter>tipo</parameter> <type>text</type>)</literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        Decodifica os dados binários da <parameter>cadeia_de_caracteres</parameter>
        previamente codificada com <function>encode()</function>. O tipo do
        parâmetro é o mesmo que em <function>encode()</function>.
       </entry>
       <entry><literal>decode('MTIzAAE=', 'base64')</literal></entry>
       <entry><literal>123\000\001</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>encode</function>(<parameter>dados</parameter> <type>bytea</type>,
        <parameter>tipo</parameter> <type>text</type>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Codifica dados binários na representação somente <acronym>ASCII</acronym>.
        Os tipos suportados são: <literal>base64</literal>, <literal>hex</literal>
        e <literal>escape</literal>.
       </entry>
       <entry><literal>encode( '123\\000\\001', 'base64')</literal></entry>
       <entry><literal>MTIzAAE=</literal></entry>
      </row>

      <row>
       <entry><literal><function>initcap</function>(<type>text</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Converte a primeira letra de cada palavra em maiúscula e as demais em
        minúsculas. As palavras são seqüências de caracteres alfanuméricos
        separadas por caracteres não alfanuméricos.
       </entry>
       <entry><literal>initcap('hi THOMAS')</literal></entry>
       <entry><literal>Hi Thomas</literal></entry>
      </row>

      <row>
       <entry><literal><function>length</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>
        Número de caracteres presentes na <parameter>cadeia_de_caracteres</parameter>.
        <indexterm>
         <primary>cadeia de caracteres</primary>
         <secondary>comprimento - função length()</secondary>
        </indexterm>
        <indexterm>
         <primary>comprimento</primary>
         <secondary sortas="cadeia de caracteres">de uma cadeia de caracteres</secondary>
         <see>cadeia de caracteres, comprimento</see>
        </indexterm>
       </entry>
       <entry><literal>length('José')</literal></entry>
       <entry><literal>4</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>lpad</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>,
        <parameter>comprimento</parameter> <type>integer</type>
        <optional>, <parameter>preenchimento</parameter> <type>text</type></optional>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Preenche a <parameter>cadeia_de_caracteres</parameter> até o
        <parameter>comprimento</parameter> adicionando os caracteres de
        <parameter>preenchimento</parameter> (espaço por padrão) à esquerda.
        Se a <parameter>cadeia_de_caracteres</parameter> for mais longa que o
        <parameter>comprimento</parameter> então é truncada (à direita).
       </entry>
       <entry><literal>lpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>xyxhi</literal></entry>
      </row>

      <row>
       <entry><literal><function>ltrim</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>
        <optional>, <parameter>caracteres</parameter> <type>text</type></optional>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Remove a cadeia de caracteres mais longa contendo apenas caracteres
        presentes em <parameter>caracteres</parameter> (espaço por padrão)
        do início da <parameter>cadeia_de_caracteres</parameter>.
       </entry>
       <entry><literal>ltrim('zzzytrim', 'xyz')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry><literal><function>md5</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Calcula o MD5 da <parameter>cadeia_de_caracteres</parameter>,
        retornando o resultado em hexadecimal.
       </entry>
       <entry><literal>md5('abc')</literal></entry>
       <entry><literal>900150983cd24fb0 d6963f7d28e17f72</literal></entry>
      </row>

      <row>
       <entry><literal><function>pg_client_encoding</function>()</literal></entry>
       <entry><type>name</type></entry>
       <entry>
        Nome da codificação atual do cliente
       </entry>
       <entry><literal>pg_client_encoding()</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_ident</function>(<parameter>cadeia_de_caracteres</parameter> text)</literal><indexterm><primary>quote_ident</></></entry>
       <entry><type>text</type></entry>
       <entry>
        Retorna a cadeia de caracteres fornecida apropriadamente entre aspas,
        para ser utilizada como identificador na cadeia de caracteres de um
        comando <acronym>SQL</acronym>. As aspas são adicionadas somente quando
        há necessidade (ou seja, se a cadeia de caracteres contiver caracteres
        não-identificadores, ou se contiver letras maiúsculas e minúsculas).
        As aspas internas são devidamente duplicadas.
       </entry>
       <entry><literal>quote_ident('Foo bar')</literal></entry>
       <entry><literal>"Foo bar"</literal></entry>
      </row>

      <row>
       <entry><literal><function>quote_literal</function>(<parameter>cadeia_de_caracteres</parameter> text)</literal><indexterm><primary>quote_literal</></></entry>
       <entry><type>text</type></entry>
       <entry>
        Retorna a cadeia de caracteres fornecida apropriadamente entre
        apóstrofos, para ser utilizada como literal cadeia de caracteres na
        cadeia de caracteres de um comando <acronym>SQL</acronym>.
        Os apóstrofos e contrabarras embutidos são devidamente duplicados.
       </entry>
       <entry><literal>quote_literal( 'O\'Reilly')</literal></entry>
       <entry><literal>'O''Reilly'</literal></entry>
      </row>

      <row>
       <entry><literal><function>repeat</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>, <parameter>número</parameter> <type>integer</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Repete a <parameter>cadeia_de_caracteres</parameter> pelo
       <parameter>número</parameter> de vezes especificado</entry>
       <entry><literal>repeat('Pg', 4)</literal></entry>
       <entry><literal>PgPgPgPg</literal></entry>
      </row>

      <row>
       <entry><literal><function>replace</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>,
       <parameter>origem</parameter> <type>text</type>,
       <parameter>destino</parameter> <type>text</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Substitui todas as ocorrências na
        <parameter>cadeia_de_caracteres</parameter>,
        da cadeia de caracteres de <parameter>origem</parameter>
        pela cadeia de caracteres de <parameter>destino</parameter>.
       </entry>
       <entry><literal>replace( 'abcdefabcdef', 'cd', 'XX')</literal></entry>
       <entry><literal>abXXefabXXef</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>rpad</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>,
        <parameter>comprimento</parameter> <type>integer</type>
        <optional>, <parameter>preenchimento</parameter> <type>text</type></optional>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Preenche a <parameter>cadeia_de_caracteres</parameter> até o
        <parameter>comprimento</parameter> anexando os caracteres de
        <parameter>preenchimento</parameter> (espaço por padrão) à direita.
        Se a <parameter>cadeia_de_caracteres</parameter> for mais longa que o
        <parameter>comprimento</parameter>, então é truncada.
       </entry>
       <entry><literal>rpad('hi', 5, 'xy')</literal></entry>
       <entry><literal>hixyx</literal></entry>
      </row>

      <row>
       <entry><literal><function>rtrim</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>
        <optional>, <parameter>caracteres</parameter> <type>text</type></optional>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Remove do final da <parameter>cadeia_de_caracteres</parameter>, a cadeia
        de caracteres mais longa contendo apenas os caracteres presentes em
        <parameter>caracteres</parameter> (espaço por padrão).
       </entry>
       <entry><literal>rtrim('trimxxxx', 'x')</literal></entry>
       <entry><literal>trim</literal></entry>
      </row>

      <row>
       <entry><literal><function>split_part</function>(<parameter>cadeia_de_caracteres</parameter> <type>text</type>,
       <parameter>delimitador</parameter> <type>text</type>,
       <parameter>campo</parameter> <type>integer</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Divide a <parameter>cadeia_de_caracteres</parameter> utilizando o
        <parameter>delimitador</parameter>, retornando o campo especificado
        (contado a partir de 1).
       </entry>
       <entry><literal>split_part( 'abc~@~def~@~ghi', '~@~', 2)</literal></entry>
       <entry><literal>def</literal></entry>
      </row>

      <row>
       <entry><literal><function>strpos</function>(<parameter>cadeia_de_caracteres</parameter>, <parameter>caracteres</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Posição dos caracteres especificados; o mesmo que
        <literal>position(<parameter>caracteres</parameter> in
        <parameter>cadeia_de_caracteres</parameter>)</literal>, mas deve ser
        observada a ordem invertida dos argumentos
       </entry>
       <entry><literal>strpos('high', 'ig')</literal></entry>
       <entry><literal>2</literal></entry>
      </row>

      <row>
       <entry><literal><function>substr</function>(<parameter>cadeia_de_caracteres</parameter>, <parameter>origem</parameter> <optional>, <parameter>contador</parameter></optional>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        Extrai a subcadeia de caracteres caracteres; o mesmo que
        <literal>substring(<parameter>cadeia_de_caracteres</parameter>
        from <parameter>origem</parameter>
        for <parameter>contador</parameter>)</literal>
       </entry>
       <entry><literal>substr('alphabet', 3, 2)</literal></entry>
       <entry><literal>ph</literal></entry>
      </row>

      <row>
       <entry><literal><function>to_ascii</function>(<type>text</type>
        <optional>, <parameter>codificação</parameter></optional>)</literal></entry>
       <entry><type>text</type></entry>

       <entry>
       Converte texto em outras codificações em <acronym>ASCII</acronym>
       <footnote>
        <para>
         A função <function>to_ascii</function> permite apenas a conversão das
         codificações <literal>LATIN1</>, <literal>LATIN2</>,
         <literal>LATIN9</> e <literal>WIN1250</>.
        </para>
       </footnote>
       </entry>

       <entry><literal>to_ascii('Conseqüência')</literal></entry>
       <entry><literal>Consequencia</literal></entry>
      </row>

      <row>
       <entry><literal><function>to_hex</function>(<parameter>número</parameter> <type>integer</type>
       ou <type>bigint</type>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>Converte o <parameter>número</parameter> em sua representação
        hexadecimal equivalente
       </entry>
       <entry><literal>to_hex(2147483647)</literal></entry>
       <entry><literal>7fffffff</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>translate</function>(<parameter>cadeia_de_caracteres</parameter>
        <type>text</type>,
        <parameter>origem</parameter> <type>text</type>,
        <parameter>destino</parameter> <type>text</type>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>
        Todo caractere da <parameter>cadeia_de_caracteres</parameter> que
        corresponde a um caractere do conjunto <parameter>origem</parameter>,
        é substituído pelo caractere correspondente do conjunto
        <parameter>destino</parameter>.
       </entry>
       <entry><literal>translate('12345', '14', 'ax')</literal></entry>
       <entry><literal>a23x5</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

   <example id="func-conv-diacritic-letter">
    <title>Conversão de letras minúsculas e maiúsculas acentuadas</title>

    <para>
     Abaixo estão mostradas duas funções para conversão de letras.
     A função <literal>maiusculas</literal> converte letras minúsculas, com ou
     sem acentos, em maiúsculas, enquanto a função <literal>minusculas</literal>
     faz o contrário, ou seja, converte letras maiúsculas, com ou sem acentos em
     minúsculas
     <footnote>
      <para>
       Exemplo escrito pelo tradutor, não fazendo parte do manual original.
      </para>
     </footnote>
     .
    </para>

<screen>
<prompt>=&gt;</prompt> <userinput>\!chcp 1252</userinput>
<computeroutput>Active code page: 1252</computeroutput>
<prompt>=&gt;</prompt> <userinput>CREATE FUNCTION maiusculas(text) RETURNS text AS '</userinput>
<prompt>'&gt;</prompt> <userinput>    SELECT translate( upper($1),</userinput>
<prompt>'&gt;</prompt> <userinput>           text ''áéíóúàèìòùãõâêîôôäëïöüç'',</userinput>
<prompt>'&gt;</prompt> <userinput>           text ''ÁÉÍÓÚÀÈÌÒÙÃÕÂÊÎÔÛÄËÏÖÜÇ'')</userinput>
<prompt>'&gt;</prompt> <userinput>' LANGUAGE SQL STRICT;</userinput>

<prompt>=&gt;</prompt> <userinput>SELECT maiusculas('à ação seqüência');</userinput>

<computeroutput>
    maiusculas
------------------
 À AÇÃO SEQÜÊNCIA
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>CREATE FUNCTION minusculas(text) RETURNS text AS '</userinput>
<prompt>'&gt;</prompt> <userinput>    SELECT translate( lower($1),</userinput>
<prompt>'&gt;</prompt> <userinput>           text ''ÁÉÍÓÚÀÈÌÒÙÃÕÂÊÎÔÛÄËÏÖÜÇ'',</userinput>
<prompt>'&gt;</prompt> <userinput>           text ''áéíóúàèìòùãõâêîôôäëïöüç'')</userinput>
<prompt>'&gt;</prompt> <userinput>' LANGUAGE SQL STRICT;</userinput>

<prompt>=&gt;</prompt> <userinput>SELECT minusculas('À AÇÃO SEQÜÊNCIA');</userinput>

<computeroutput>
    minusculas
------------------
 à ação seqüência
(1 linha)
</computeroutput>
</screen>
   </example>

   <table id="conversion-names">
    <title>Conversões nativas</title>
    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nome da conversão
        <footnote>
         <para>
          Os nomes das conversões obedecem a um esquema de nomes padronizado:
          O nome oficial da codificação de origem, com todos os caracteres
          não alfanuméricos substituídos por sublinhado, seguido por
          <literal>_to_</literal>, seguido pelo nome da codificação de
          destino processado da mesma forma que o nome da codificação de origem.
          Portanto, os nomes podem desviar dos nomes habituais das codificações.
         </para>
        </footnote>
       </entry>
       <entry>Codificação de origem</entry>
       <entry>Codificação de destino</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>ascii_to_mic</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>ascii_to_utf_8</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_euc_tw</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_mic</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>big5_to_utf_8</literal></entry>
       <entry><literal>BIG5</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_mic</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_cn_to_utf_8</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_mic</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_sjis</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>euc_jp_to_utf_8</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_mic</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_kr_to_utf_8</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_big5</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_mic</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>euc_tw_to_utf_8</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>gb18030_to_utf_8</literal></entry>
       <entry><literal>GB18030</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>gbk_to_utf_8</literal></entry>
       <entry><literal>GBK</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_10_to_utf_8</literal></entry>
       <entry><literal>LATIN6</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_13_to_utf_8</literal></entry>
       <entry><literal>LATIN7</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_14_to_utf_8</literal></entry>
       <entry><literal>LATIN8</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_15_to_utf_8</literal></entry>
       <entry><literal>LATIN9</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_16_to_utf_8</literal></entry>
       <entry><literal>LATIN10</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_mic</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_1_to_utf_8</literal></entry>
       <entry><literal>LATIN1</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_mic</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_utf_8</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_2_to_windows_1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_mic</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_3_to_utf_8</literal></entry>
       <entry><literal>LATIN3</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_mic</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_4_to_utf_8</literal></entry>
       <entry><literal>LATIN4</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_koi8_r</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>KOI8</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_mic</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_utf_8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_1251</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_5_to_windows_866</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
       <entry><literal>ALT</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_6_to_utf_8</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_7_to_utf_8</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_8_to_utf_8</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>iso_8859_9_to_utf_8</literal></entry>
       <entry><literal>LATIN5</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>johab_to_utf_8</literal></entry>
       <entry><literal>JOHAB</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_iso_8859_5</literal></entry>
       <entry><literal>KOI8</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_mic</literal></entry>
       <entry><literal>KOI8</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_utf_8</literal></entry>
       <entry><literal>KOI8</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_1251</literal></entry>
       <entry><literal>KOI8</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>koi8_r_to_windows_866</literal></entry>
       <entry><literal>KOI8</literal></entry>
       <entry><literal>ALT</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_ascii</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_big5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_cn</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_jp</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_kr</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_euc_tw</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_1</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_2</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_3</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_4</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_iso_8859_5</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_koi8_r</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>KOI8</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_sjis</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_1251</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>mic_to_windows_866</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
       <entry><literal>ALT</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_euc_jp</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_mic</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>sjis_to_utf_8</literal></entry>
       <entry><literal>SJIS</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>tcvn_to_utf_8</literal></entry>
       <entry><literal>TCVN</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>uhc_to_utf_8</literal></entry>
       <entry><literal>UHC</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_ascii</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>SQL_ASCII</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_big5</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>BIG5</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_euc_cn</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>EUC_CN</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_euc_jp</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>EUC_JP</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_euc_kr</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>EUC_KR</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_euc_tw</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>EUC_TW</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_gb18030</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>GB18030</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_gbk</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>GBK</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_1</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN1</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_10</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN6</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_13</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN7</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_14</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN8</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_15</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN9</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_16</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN10</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_2</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_3</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN3</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_4</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN4</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_5</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_6</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>ISO_8859_6</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_7</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>ISO_8859_7</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_8</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>ISO_8859_8</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_iso_8859_9</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>LATIN5</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_johab</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>JOHAB</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_koi8_r</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>KOI8</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_sjis</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>SJIS</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_tcvn</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>TCVN</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_uhc</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>UHC</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_windows_1250</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>WIN1250</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_windows_1251</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_windows_1256</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>WIN1256</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_windows_866</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>ALT</literal></entry>
      </row>

      <row>
       <entry><literal>utf_8_to_windows_874</literal></entry>
       <entry><literal>UNICODE</literal></entry>
       <entry><literal>WIN874</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_iso_8859_2</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>LATIN2</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_mic</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1250_to_utf_8</literal></entry>
       <entry><literal>WIN1250</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_iso_8859_5</literal></entry>
       <entry><literal>WIN</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_koi8_r</literal></entry>
       <entry><literal>WIN</literal></entry>
       <entry><literal>KOI8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_mic</literal></entry>
       <entry><literal>WIN</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_utf_8</literal></entry>
       <entry><literal>WIN</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1251_to_windows_866</literal></entry>
       <entry><literal>WIN</literal></entry>
       <entry><literal>ALT</literal></entry>
      </row>

      <row>
       <entry><literal>windows_1256_to_utf_8</literal></entry>
       <entry><literal>WIN1256</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_iso_8859_5</literal></entry>
       <entry><literal>ALT</literal></entry>
       <entry><literal>ISO_8859_5</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_koi8_r</literal></entry>
       <entry><literal>ALT</literal></entry>
       <entry><literal>KOI8</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_mic</literal></entry>
       <entry><literal>ALT</literal></entry>
       <entry><literal>MULE_INTERNAL</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_utf_8</literal></entry>
       <entry><literal>ALT</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

      <row>
       <entry><literal>windows_866_to_windows_1251</literal></entry>
       <entry><literal>ALT</literal></entry>
       <entry><literal>WIN</literal></entry>
      </row>

      <row>
       <entry><literal>windows_874_to_utf_8</literal></entry>
       <entry><literal>WIN874</literal></entry>
       <entry><literal>UNICODE</literal></entry>
      </row>

     </tbody>
    </tgroup>
   </table>

  <sect2 id="functions-string-pg-mssql-oracle">

   <sect2info>
    <author>
     <firstname>Halley</firstname>
     <surname>Pacheco de Oliveira</surname>
     <affiliation>
      <orgname>Câmara Municipal do Rio de Janeiro</orgname>
      <orgdiv>Assessoria de Informática</orgdiv>
      <address>
       <city>Rio de Janeiro</city>
       <country>Brasil</country>
      </address>
     </affiliation>
    </author>
    <date>2005-08-10</date>
   </sect2info>

   <title>Comparações entre o PostgreSQL, o Oracle, o SQL Server e o DB2</title>

  <note>
   <para>
    Seção escrita pelo tradutor, não fazendo parte do manual original.
   </para>
  </note>

  <para>
   Os exemplos abaixo comparam funções e operadores para cadeias de caracteres do
   <ulink url="http://www.stanford.edu/dept/itss/docs/oracle/9i/server.920/a96540/functions2a.htm">
   Oracle</ulink>, do
   <ulink url="http://msdn.microsoft.com/library/en-us/tsqlref/ts_fa-fz_7oqb.asp">
   SQL Server</ulink>, do
   <ulink url="ftp://ftp.software.ibm.com/ps/products/db2/info/vr82/pdf/en_US/db2s1e81.pdf">
   DB2</ulink>
   e do <productname>PostgreSQL &version;</productname>.
  </para>

   <example id="func-length-space-right">
    <title>Tamanho de uma cadeia de caracteres com espaço à direita</title>
    <para>
     Abaixo são mostradas consultas que retornam como resultado o tamanho de
     uma cadeia de caracteres com espaço à direita. Note que apenas a função
     <function>len</function> do <productname>SQL Server 2000</productname>
     não conta o espaço à direita.
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT length('1234567890 ');</userinput>

<computeroutput>
 length
--------
     11
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT len('1234567890 ') AS len</userinput>

<computeroutput>
len
---
10
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT length('1234567890 ') AS length FROM sys.dual;</userinput>

<computeroutput>
    LENGTH
----------
        11
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT length('1234567890 ') FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
-------------
         11
</computeroutput>
</screen>
   </example>

   <example id="func-concat-strings">
    <title>Concatenação de cadeias de caracteres</title>
    <para>
     Abaixo são mostradas consultas que retornam como resultado a
     concatenação de cadeias de caracteres. Deve ser observado que o
     <productname>SQL Server 2000</productname> usa o operador
     <literal>+</literal>, enquanto os demais usam o operador
     <literal>||</literal> para concatenar cadeias de caracteres. Além disso,
     o <productname>Oracle</productname> e o <productname>DB2</productname>
     possuem a função <function>concat</function>, nativa, para concatenar duas
     cadeias de caracteres. Embora o <productname>PostgreSQL</productname> e o
     <productname>SQL Server</productname> não possuam a função
     <function>concat</function> nativa, esta pode ser facilmente
     definida neste dois produtos.
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT 'ae' || 'io' || 'u' AS vogais;</userinput>

<computeroutput>
 vogais
--------
 aeiou
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>CREATE FUNCTION concat(text,text) RETURNS text AS '</userinput>
<prompt>'&gt;</prompt> <userinput>    SELECT $1 || $2;</userinput>
<prompt>'&gt;</prompt> <userinput>' LANGUAGE SQL STRICT;</userinput>

<prompt>=&gt;</prompt> <userinput>SELECT concat(concat('ae','io'),'u') AS vogais;</userinput>

<computeroutput>
 vogais
--------
 aeiou
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT 'ae' + 'io' + 'u' AS vogais;</userinput>

<computeroutput>
vogais
------
aeiou
(1 row(s) affected)
</computeroutput>

<userinput>
CREATE FUNCTION dbo.concat(@s1 varchar(64), @s2 varchar(64))
RETURNS varchar(128)
AS
BEGIN
    RETURN @s1 + @s2
END
GO
SELECT dbo.concat(dbo.concat('ae','io'),'u') AS vogais
GO
</userinput>

<computeroutput>
vogais
------
aeiou
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT 'ae' || 'io' || 'u' AS vogais FROM sys.dual;</userinput>

<computeroutput>
VOGAI
-----
aeiou
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT concat(concat('ae','io'),'u') AS vogais FROM sys.dual;</userinput>

<computeroutput>
VOGAI
-----
aeiou
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT 'ae' || 'io' || 'u' AS vogais FROM sysibm.sysdummy1;</userinput>

<computeroutput>
VOGAIS
--------
aeiou
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT concat(concat('ae','io'),'u') AS vogais FROM sysibm.sysdummy1;</userinput>

<computeroutput>
VOGAIS
--------
aeiou
</computeroutput>
</screen>
   </example>

  </sect2>

  <sect2 id="functions-string-comp-pg-oracle">

   <sect2info>
    <author>
     <firstname>Halley</firstname>
     <surname>Pacheco de Oliveira</surname>
     <affiliation>
      <orgname>Câmara Municipal do Rio de Janeiro</orgname>
      <orgdiv>Assessoria de Informática</orgdiv>
      <address>
       <city>Rio de Janeiro</city>
       <country>Brasil</country>
      </address>
     </affiliation>
    </author>
    <date>2005-08-10</date>
   </sect2info>

   <title>Similaridades entre o PostgreSQL e o Oracle</title>

  <note>
   <para>
    Seção escrita pelo tradutor, não fazendo parte do manual original.
   </para>
  </note>

  <para>
   A <xref linkend="functions-string-tab-pg-oracle"> compara funções e
   operadores para cadeias de caracteres do <productname>PostgreSQL</productname>
   e do <productname>Oracle</productname>, através de exemplos tirados do próprio
   <ulink url="http://download-west.oracle.com/docs/cd/B10501_01/server.920/a96540/functions2a.htm">
   manual do <productname>Oracle</productname></ulink>, com intuito de mostrar
   similaridades.
  </para>
   <table id="functions-string-tab-pg-oracle">
    <title>Funções e operadores para cadeias de caracteres do
    PostgreSQL e do Oracle</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>PostgreSQL &version;</entry>
       <entry>Oracle 10g</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT CHR(67)||CHR(65)||CHR(84) AS "Dog";</userinput>

<computeroutput>
 Dog
-----
 CAT
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT CHR(67)||CHR(65)||CHR(84) "Dog"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
Dog
---
CAT
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT INITCAP('the soap') AS "Capitals";</userinput>

<computeroutput>
 Capitals
----------
 The Soap
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT INITCAP('the soap') "Capitals"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
Capitals
---------
The Soap
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT LOWER('MR. SCOTT MCMILLAN') AS "Lowercase";</userinput>

<computeroutput>
     Lowercase
--------------------
 mr. scott mcmillan
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT LOWER('MR. SCOTT MCMILLAN') "Lowercase"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
Lowercase
--------------------
mr. scott mcmillan
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT LPAD('Page 1',15,'*.') AS "LPAD example";</userinput>

<computeroutput>
  LPAD example
-----------------
 *.*.*.*.*Page 1
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT LPAD('Page 1',15,'*.') "LPAD example"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
LPAD example
---------------
*.*.*.*.*Page 1
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT LTRIM('xyxXxyLAST WORD','xy') AS "LTRIM example";</userinput>

<computeroutput>
 LTRIM example
---------------
 XxyLAST WORD
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT LTRIM('xyxXxyLAST WORD','xy') "LTRIM example"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
LTRIM example
------------
XxyLAST WORD
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT REPLACE('JACK and JUE','J','BL') AS "Changes";</userinput>

<computeroutput>
    Changes
----------------
 BLACK and BLUE
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT REPLACE('JACK and JUE','J','BL') "Changes"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
Changes
--------------
BLACK and BLUE
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT RPAD('MORRISON',12,'ab') AS "RPAD example";</userinput>

<computeroutput>
 RPAD example
--------------
 MORRISONabab
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT RPAD('MORRISON',12,'ab') "RPAD example"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
RPAD example
-----------------
MORRISONabab
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT RTRIM('BROWNINGyxXxyyx','xy') AS "RTRIM example";</userinput>

<computeroutput>
 RTRIM example
---------------
 BROWNINGyxX
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT RTRIM('BROWNINGyxXxyyx','xy') "RTRIM example"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
RTRIM examp
-----------
BROWNINGyxX
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT SUBSTR('ABCDEFG',3,4) AS "Substring";</userinput>

<computeroutput>
 Substring
-----------
 CDEF
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT SUBSTR('ABCDEFG',3,4) "Substring"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
Substring
---------
CDEF
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT TRANSLATE('2KRW229',</userinput>
<prompt>(&gt;</prompt> <userinput>'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',</userinput>
<prompt>(&gt;</prompt> <userinput>'9999999999XXXXXXXXXXXXXXXXXXXXXXXXXX') AS "License";</userinput>

<computeroutput>
 License
---------
 9XXX999
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT TRANSLATE('2KRW229',</userinput>
<prompt>  2 </prompt> <userinput>'0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ',</userinput>
<prompt>  3 </prompt> <userinput>'9999999999XXXXXXXXXXXXXXXXXXXXXXXXXX') "License"</userinput>
<prompt>  4 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
License
--------
9XXX999
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT TRANSLATE('2KRW229',</userinput>
<prompt>(&gt;</prompt> <userinput>   '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', '0123456789')</userinput>
<prompt>-&gt;</prompt> <userinput>   AS "Translate example";</userinput>

<computeroutput>
 Translate example
-------------------
 2229
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT TRANSLATE('2KRW229',</userinput>
<prompt>  2 </prompt> <userinput>   '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', '0123456789')</userinput>
<prompt>  3 </prompt> <userinput>   "Translate example"</userinput>
<prompt>  4 </prompt> <userinput>   FROM sys.dual;</userinput>
<computeroutput>
Translate example
-----------------
2229
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT TRIM (0 FROM 0009872348900) AS "TRIM Example";</userinput>

<computeroutput>
 TRIM Example
--------------
 98723489
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT TRIM (0 FROM 0009872348900) "TRIM Example"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
TRIM Example
------------
    98723489
</computeroutput>
</literallayout>
       </entry>
      </row>
      <row>
       <entry>
<literallayout class="monospaced">
<prompt>=&gt;</prompt> <userinput>SELECT UPPER('Large') AS "Uppercase";</userinput>

<computeroutput>
 Uppercase
-----------
 LARGE
</computeroutput>
</literallayout>
       </entry>
       <entry>
<literallayout class="monospaced">
<prompt>SQL&gt;</prompt> <userinput>SELECT UPPER('Large') "Uppercase"</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>
<computeroutput>
Upper
-----
LARGE
</computeroutput>
</literallayout>
       </entry>
      </row>
     </tbody>
     </tgroup>
    </table>

  </sect2>

  </sect1>

  <sect1 id="functions-binarystring">
   <title>Funções e operadores para cadeias binárias</title>

   <indexterm zone="functions-binarystring">
    <primary>dados binários</primary>
    <secondary>funções</secondary>
   </indexterm>

   <para>
    Esta seção descreve as funções e operadores disponíveis para examinar
    e manipular valores do tipo <type>bytea</type>.
   </para>

   <para>
    O <acronym>SQL</acronym> define algumas funções para cadeias binárias
    com uma sintaxe especial, onde certas palavras chave, em vez de vírgulas,
    são utilizadas para separar os argumentos. Os detalhes estão na
    <xref linkend="functions-binarystring-sql">.
    Algumas funções também são implementadas utilizando a sintaxe
    regular de chamada de função
    (Consulte a <xref linkend="functions-binarystring-other">).
   </para>

   <table id="functions-binarystring-sql">
    <title>Funções e operadores SQL para cadeias binárias</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Tipo retornado</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><parameter>cadeia_binária</parameter> <literal>||</literal>
        <parameter>cadeia_binária</parameter></literal></entry>
       <entry> <type>bytea</type> </entry>
       <entry>
        Concatenação de cadeias binárias
        <indexterm>
         <primary>cadeia binária</primary>
         <secondary>concatenação</secondary>
        </indexterm>
       </entry>
       <entry><literal>'\\\\Post'::bytea || '\\047gres\\000'::bytea</literal></entry>
       <entry><literal>\\Post'gres\000</literal></entry>
      </row>

      <row>
       <entry><literal><function>octet_length</function>(<parameter>cadeia_binária</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>Número de bytes da cadeia binária</entry>
       <entry><literal>octet_length( 'Jo\\000sé'::bytea)</literal></entry>
       <entry><literal>5</literal></entry>
      </row>

      <row>
       <entry><literal><function>position</function>(<parameter>subcadeia</parameter> in <parameter>cadeia_binária</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>Posição da subcadeia especificada</entry>
      <entry><literal>position('\\000om'::bytea in 'Th\\000omas'::bytea)</literal></entry>
       <entry><literal>3</literal></entry>
      </row>

      <row>
       <entry><literal><function>substring</function>(<parameter>cadeia_binária</parameter> <optional>from <type>integer</type></optional> <optional>for <type>integer</type></optional>)</literal></entry>
       <entry><type>bytea</type></entry>
       <entry>
        Extrai uma parte da cadeia binária
        <indexterm>
         <primary>substring</primary>
        </indexterm>
       </entry>
       <entry><literal>substring('Th\\000omas'::bytea from 2 for 3)</literal></entry>
       <entry><literal>h\000o</literal></entry>
      </row>

      <row>
       <entry>
        <literal><function>trim</function>(<optional>both</optional>
        <parameter>bytes</parameter> from
        <parameter>cadeia_binária</parameter>)</literal>
       </entry>
       <entry><type>bytea</type></entry>
       <entry>
        Remove a cadeia mais longa contendo apenas os bytes em
        <parameter>bytes</parameter> do início e do fim da
        <parameter>cadeia_binária</parameter>.
       </entry>
       <entry><literal>trim('\\000'::bytea from '\\000Tom\\000'::bytea)</literal></entry>
       <entry><literal>Tom</literal></entry>
      </row>

      <row>
       <entry><literal><function>get_byte</function>(<parameter>cadeia_binária</parameter>, <parameter>deslocamento</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>
        Extrai byte da cadeia binária.
        <indexterm>
         <primary>get_byte</primary>
        </indexterm>
       </entry>
       <entry><literal>get_byte('Th\\000omas'::bytea, 4)</literal></entry>
       <entry><literal>109</literal></entry>
      </row>

      <row>
       <entry><literal><function>set_byte</function>(<parameter>cadeia_binária</parameter>,
       <parameter>deslocamento</parameter>, <parameter>novo_valor</parameter>)</literal></entry>
       <entry><type>bytea</type></entry>
       <entry>
        Define byte na cadeia binária.
        <indexterm>
         <primary>set_byte</primary>
        </indexterm>
       </entry>
       <entry><literal>set_byte('Th\\000omas'::bytea, 4, 64)</literal></entry>
       <entry><literal>Th\000o@as</literal></entry>
      </row>

      <row>
       <entry><literal><function>get_bit</function>(<parameter>cadeia_binária</parameter>, <parameter>deslocamento</parameter>)</literal></entry>
       <entry><type>integer</type></entry>
       <entry>
        Extrai bit da cadeia binária.
        <indexterm>
         <primary>get_bit</primary>
        </indexterm>
       </entry>
       <entry><literal>get_bit('Th\\000omas'::bytea, 45)</literal></entry>
       <entry><literal>1</literal></entry>
      </row>

      <row>
       <entry><literal><function>set_bit</function>(<parameter>cadeia_binária</parameter>,
       <parameter>deslocamento</parameter>, <parameter>novo_valor</parameter>)</literal></entry>
       <entry><type>bytea</type></entry>
       <entry>
        Define bit na cadeia binária.
        <indexterm>
         <primary>set_bit</primary>
        </indexterm>
       </entry>
       <entry><literal>set_bit('Th\\000omas'::bytea, 45, 0)</literal></entry>
       <entry><literal>Th\000omAs</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Estão disponíveis outras funções para manipulação de cadeias binárias,
    conforme mostrado na <xref linkend="functions-binarystring-other">.
    Algumas são utilizadas internamente para implementar as funções de cadeias
    binárias do padrão <acronym>SQL</acronym> mostradas na
    <xref linkend="functions-binarystring-sql">.
   </para>

   <table id="functions-binarystring-other">
    <title>Outras funções para cadeias binárias</title>
    <tgroup cols="5">
     <thead>
      <row>
       <entry>Função</entry>
       <entry>Tipo retornado</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>btrim</function>(<parameter>cadeia_binária</parameter>
        <type>bytea</type>, <parameter>bytes</parameter> <type>bytea</type>)</literal></entry>
       <entry><type>bytea</type></entry>
       <entry>
        Remove do início e do fim da <parameter>cadeia_binária</parameter>,
        a cadeia mais longa contendo apenas os bytes em
        <parameter>bytes</parameter>
      </entry>
      <entry><literal>btrim('\\000trim\\000'::bytea, '\\000'::bytea)</literal></entry>
      <entry><literal>trim</literal></entry>
     </row>

     <row>
      <entry><literal><function>length</function>(<parameter>cadeia_binária</parameter>)</literal></entry>
      <entry><type>integer</type></entry>
      <entry>
       Comprimento da cadeia binária
       <indexterm>
        <primary>cadeia binária</primary>
        <secondary>comprimento</secondary>
       </indexterm>
       <indexterm>
        <primary>comprimento</primary>
        <secondary sortas="cadeia binária">da cadeia binária</secondary>
        <see>cadeia binária, comprimento</see>
       </indexterm>
      </entry>
      <entry><literal>length('Jo\\000sé'::bytea)</literal></entry>
      <entry><literal>5</literal></entry>
     </row>

     <row>
      <entry>
       <literal><function>decode</function>(<parameter>cadeia_binária</parameter> <type>text</type>,
              <parameter>tipo</parameter> <type>text</type>)</literal>
      </entry>
      <entry><type>bytea</type></entry>
      <entry>
       Decodifica a <parameter>cadeia_binária</parameter> previamente codificada
       com <literal>encode()</literal>. O tipo do parâmetro é o mesmo do
       <literal>encode()</literal>.
      </entry>
      <entry><literal>decode('123\\000456', 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

     <row>
      <entry>
       <literal><function>encode</function>(<parameter>cadeia_binária</parameter> <type>bytea</type>,
              <parameter>tipo</parameter> <type>text</type>)</literal>
      </entry>
      <entry><type>text</type></entry>
      <entry>
       Codifica a <parameter>cadeia_binária</parameter> na representação somente
       <acronym>ASCII</acronym>. Os tipos suportados são: <literal>base64</literal>,
       <literal>hex</literal>, <literal>escape</literal>.
      </entry>
      <entry><literal>encode('123\\000456'::bytea, 'escape')</literal></entry>
      <entry><literal>123\000456</literal></entry>
     </row>

    </tbody>
   </tgroup>
  </table>

 </sect1>


  <sect1 id="functions-bitstring">
   <title>Funções e operadores para cadeias de bits</title>

   <indexterm zone="functions-bitstring">
    <primary>bit strings</primary>
    <secondary>funções</secondary>
   </indexterm>

   <para>
    Esta seção descreve as funções e operadores disponíveis para examinar
    e manipular cadeias de bits, ou seja, valores dos tipos
    <type>bit</type> e <type>bit varying</type>. Além dos operadores
    usuais de comparação, podem ser utilizados os operadores mostrados na
    <xref linkend="functions-bit-string-op-table">. Devem ser do mesmo
    comprimento as cadeias de bits operandos de <literal>&amp;</literal>,
    <literal>|</literal> e <literal>#</literal> . Ao ser feito o
    deslocamento de bits é preservado o comprimento original da cadeia de bits,
    conforme mostrado nos exemplos.
   </para>

   <table id="functions-bit-string-op-table">
    <title>Operadores para cadeias de bits</title>

    <tgroup cols="4">
     <thead>
      <row>
       <entry>Operador</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
       <entry>Resultado</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry> <literal>||</literal> </entry>
       <entry>concatenação</entry>
       <entry><literal>B'10001' || B'011'</literal></entry>
       <entry><literal>10001011</literal></entry>
      </row>

      <row>
       <entry> <literal>&amp;</literal> </entry>
       <entry>AND bit a bit</entry>
       <entry><literal>B'10001' &amp; B'01101'</literal></entry>
       <entry><literal>00001</literal></entry>
      </row>

      <row>
       <entry> <literal>|</literal> </entry>
       <entry>OR bit a bit</entry>
       <entry><literal>B'10001' | B'01101'</literal></entry>
       <entry><literal>11101</literal></entry>
      </row>

      <row>
       <entry> <literal>#</literal> </entry>
       <entry>XOR bit a bit</entry>
       <entry><literal>B'10001' # B'01101'</literal></entry>
       <entry><literal>11100</literal></entry>
      </row>

      <row>
       <entry> <literal>~</literal> </entry>
       <entry>NOT bit a bit</entry>
       <entry><literal>~ B'10001'</literal></entry>
       <entry><literal>01110</literal></entry>
      </row>

      <row>
       <entry> <literal>&lt;&lt;</literal> </entry>
       <entry>deslocamento à esquerda bit a bit</entry>
       <entry><literal>B'10001' &lt;&lt; 3</literal></entry>
       <entry><literal>01000</literal></entry>
      </row>

      <row>
       <entry> <literal>&gt;&gt;</literal> </entry>
       <entry>deslocamento à direita bit a bit</entry>
       <entry><literal>B'10001' &gt;&gt; 2</literal></entry>
       <entry><literal>00100</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    As seguintes funções do padrão <acronym>SQL</acronym> funcionam em
    cadeias de bits, assim como em cadeias de caracteres:
    <literal><function>length</function></literal>,
    <literal><function>bit_length</function></literal>,
    <literal><function>octet_length</function></literal>,
    <literal><function>position</function></literal>,
    <literal><function>substring</function></literal>.
   </para>

   <para>
    Além disso, é possível converter valores inteiros de e para o tipo
    <type>bit</>.
    Alguns exemplos:
<screen>
<userinput>44::bit(10)</userinput>                    <lineannotation>0000101100</lineannotation>
<userinput>44::bit(3)</userinput>                     <lineannotation>100</lineannotation>
<userinput>cast(-44 as bit(12))</userinput>           <lineannotation>111111010100</lineannotation>
<userinput>'1110'::bit(4)::integer</userinput>        <lineannotation>14</lineannotation>
</screen>
    Deve ser observado que converter para apenas um <quote>bit</> significa
    converter para <literal>bit(1)</> e, portanto, o resultado será apenas o
    bit menos significativo do inteiro.
   </para>

    <note>
     <para>
      Antes do <productname>PostgreSQL</productname> 8.0, a conversão de um
      inteiro para <type>bit(n)</> copiava os <literal>n</> bits mais à
      esquerda do inteiro, enquanto agora copia os <literal>n</> bits mais à
      direita. Também, converter um inteiro para uma cadeia de bits mais
      larga que o próprio inteiro, estende o sinal para à esquerda.
     </para>
    </note>

  </sect1>


 <sect1 id="functions-matching">
  <title>Correspondência com padrão</title>

  <indexterm zone="functions-matching">
   <primary>correspondência com padrão</primary>
  </indexterm>

   <para>
    O <productname>PostgreSQL</productname> disponibiliza três abordagens
    distintas para correspondência com padrão: o operador
    <function>LIKE</function> tradicional do <acronym>SQL</acronym>;
    o operador mais recente <function>SIMILAR TO</function> (adicionado ao
    <acronym>SQL:1999</acronym>); e as expressões regulares no estilo
    <acronym>POSIX</acronym>. Além disso, também está disponível a função de
    correspondência com padrão <function>substring</function>, que utiliza
    expressões regulares tanto no estilo <function>SIMILAR TO</function>
    quanto no estilo POSIX.
   </para>

   <tip>
    <para>
     Havendo necessidade de correspondência com padrão acima destas, deve ser
     considerado o desenvolvimento de uma função definida pelo usuário em Perl
     ou Tcl.
    </para>
   </tip>

  <sect2 id="functions-like">
   <title>LIKE</title>

   <indexterm zone="functions-like">
    <primary>LIKE</primary>
   </indexterm>

<synopsis>
<replaceable>cadeia_de_caracteres</replaceable> LIKE <replaceable>padrão</replaceable> <optional>ESCAPE <replaceable>caractere_de_escape</replaceable></optional>
<replaceable>cadeia_de_caracteres</replaceable> NOT LIKE <replaceable>padrão</replaceable> <optional>ESCAPE <replaceable>caractere_de_escape</replaceable></optional>
</synopsis>

    <para>
     Cada <replaceable>padrão</replaceable> define um conjunto de cadeias de
     caracteres. A expressão <function>LIKE</function> retorna verdade se a
     <replaceable>cadeia_de_caracteres</replaceable> estiver contida no conjunto de
     cadeias de caracteres representado pelo <replaceable>padrão</replaceable>;
     como esperado, a expressão <function>NOT LIKE</function>  retorna
     falso quando <function>LIKE</function> retorna verdade, e vice-versa, e
     a expressão equivalente é
     <literal>NOT (<replaceable>cadeia_de_caracteres</replaceable> LIKE
     <replaceable>padrão</replaceable>)</literal>.
    </para>

    <para>
     Quando o <replaceable>padrão</replaceable> não contém os caracteres
     percentagem ou sublinhado, o <replaceable>padrão</replaceable> representa
     apenas a própria cadeia de caracteres; neste caso <function>LIKE</function>
     atua como o operador igual. No <replaceable>padrão</replaceable> o caractere
     sublinhado (<literal>_</literal>) representa (corresponde a) qualquer um
     único caractere; o caractere percentagem (<literal>%</literal>) corresponde
     a qualquer cadeia com zero ou mais caracteres.
    </para>

   <para>
    Alguns exemplos:
<screen>
<userinput>'abc' LIKE 'abc'</userinput>    <lineannotation>verdade</lineannotation>
<userinput>'abc' LIKE 'a%'</userinput>     <lineannotation>verdade</lineannotation>
<userinput>'abc' LIKE '_b_'</userinput>    <lineannotation>verdade</lineannotation>
<userinput>'abc' LIKE 'c'</userinput>      <lineannotation>falso</lineannotation>
</screen>
   </para>

   <para>
    A correspondência com padrão <function>LIKE</function> sempre abrange toda a
    cadeia de caracteres. Para haver correspondência com o padrão em qualquer
    posição da cadeia de caracteres, o padrão deve começar e terminar pelo
    caractere percentagem.
   </para>

   <para>
    Para corresponder ao próprio caractere sublinhado ou percentagem, sem
    corresponder a outros caracteres, estes caracteres devem ser precedidos
    pelo caractere de escape no <replaceable>padrão</replaceable>.
    O caractere de escape padrão é a contrabarra, mas pode ser definido um outro
    caractere através da cláusula <literal>ESCAPE</literal>. Para corresponder
    ao próprio caractere de escape, devem ser escritos dois caracteres de escape.
   </para>

   <para>
    Deve ser observado que a contrabarra também possui significado especial nos
    literais cadeias de caracteres e, portanto, para escrever em uma constante
    um padrão contendo uma contrabarra devem ser escritas duas contrabarras no
    comando SQL. Assim sendo, para escrever um padrão que corresponda ao literal
    contrabarra é necessário escrever quatro contrabarras no comando, o que pode
    ser evitado escolhendo um caractere de escape diferente na cláusula
    <literal>ESCAPE</literal>; assim a contrabarra deixa de ser um caractere
    especial para o <function>LIKE</function> (Mas continua sendo especial para
    o analisador de literais cadeias de caracteres e, por isso, continuam sendo
    necessárias duas contrabarras).
   </para>

   <para>
    Também é possível fazer com que nenhum caractere sirva de escape declarando
    <literal>ESCAPE ''</literal>. Esta declaração tem como efeito desabilitar
    o mecanismo de escape, tornando impossível anular o significado
    especial dos caracteres sublinhado e percentagem no padrão.
   </para>

   <para>
    Alguns exemplos: (N. do T.)
<screen>
-- Neste exemplo a contrabarra única é consumida pelo analisador de literais
-- cadeias de caracteres, e não anula o significado especial do _

<prompt>=&gt;</prompt> <userinput>SELECT tablename FROM pg_tables WHERE tablename LIKE '%g\_o%' ESCAPE '\\';</userinput>

<computeroutput>
  tablename
--------------
 pg_group
 pg_operator
 pg_opclass
 pg_largeobject
(4 linhas)
</computeroutput>

-- Neste exemplo somente uma das duas contrabarras é consumida pelo analisador
-- de literais cadeias de caracteres e, portanto, a segunda contrabarra anula
-- o significado especial do _

<prompt>=&gt;</prompt> <userinput>SELECT tablename FROM pg_tables WHERE tablename LIKE '%g\\_o%' ESCAPE '\\';</userinput>

<computeroutput>
 tablename
-----------
 pg_operator
 pg_opclass
(2 linhas)
</computeroutput>

-- No Oracle não são necessárias duas contrabarras, como mostrado abaixo:

<prompt>SQL&gt;</prompt> <userinput>SELECT view_name FROM all_views WHERE view_name LIKE 'ALL\_%' ESCAPE '\';</userinput>
</screen>
   </para>

   <para>
    Pode ser utilizada a palavra chave <token>ILIKE</token> no lugar de
    <token>LIKE</token> para fazer a correspondência não diferenciar letras
    maiúsculas de minúsculas, conforme o idioma ativo.
    <footnote>
     <para>
      C, POSIX, pt_BR, etc. (N. do T.)
     </para>
    </footnote>
    Isto não faz parte do padrão <acronym>SQL</acronym>,
    sendo uma extensão do <productname>PostgreSQL</productname>.
   </para>

   <para>
    O operador <literal>~~</literal> equivale ao
    <function>LIKE</function>, enquanto <literal>~~*</literal> corresponde ao
    <function>ILIKE</function>. Também existem os operadores
    <literal>!~~</literal> e <literal>!~~*</literal>, representando
    o <function>NOT LIKE</function> e o <function>NOT ILIKE</function>
    respectivamente. Todos estes operadores são específicos do
    <productname>PostgreSQL</productname>.
   </para>
  </sect2>


  <sect2 id="functions-similarto-regexp">
   <title>Expressões regulares do SIMILAR TO</title>

   <indexterm zone="functions-similarto-regexp">
    <primary>expressão regular</primary>
    <!-- <seealso>pattern matching</seealso> breaks index build -->
   </indexterm>

   <indexterm>
    <primary>SIMILAR TO</primary>
   </indexterm>

   <indexterm>
    <primary>substring</primary>
   </indexterm>

<synopsis>
<replaceable>cadeia_de_caracteres</replaceable> SIMILAR TO <replaceable>padrão</replaceable> <optional>ESCAPE <replaceable>caractere_de_escape</replaceable></optional>
<replaceable>cadeia_de_caracteres</replaceable> NOT SIMILAR TO <replaceable>padrão</replaceable> <optional>ESCAPE <replaceable>caractere_de_escape</replaceable></optional>
</synopsis>

    <para>
     O operador <function>SIMILAR TO</function> retorna verdade ou falso
     conforme o padrão corresponda ou não à cadeia de caracteres fornecida.
     Este operador é muito semelhante ao <function>LIKE</function>, exceto
     por interpretar o padrão utilizando a definição de expressão regular do
     padrão <acronym>SQL</acronym>.
     As expressões regulares do padrão <acronym>SQL</acronym> são um cruzamento
     curioso entre a notação do <function>LIKE</function> e a notação habitual
     das expressões regulares.
    </para>

    <para>
     Da mesma forma que o <function>LIKE</function>, o operador
     <function>SIMILAR TO</function> somente é bem-sucedido quando o padrão
     corresponde a toda cadeia de caracteres; é diferente do praticado
     habitualmente nas expressões regulares, onde o padrão pode corresponder a
     qualquer parte da cadeia de caracteres. Também como o
     <function>LIKE</function>, o operador <function>SIMILAR TO</function>
     utiliza <literal>_</literal> e <literal>%</literal> como caracteres
     curinga, representando qualquer um único caractere e qualquer cadeia
     de caracteres, respectivamente (são comparáveis ao <literal>.</literal>
     e ao <literal>.*</literal> das expressões regulares POSIX).
    </para>

    <para>
     Além destas funcionalidades pegas emprestada do <function>LIKE</function>,
     o <function>SIMILAR TO</function> suporta os seguintes metacaracteres para
     correspondência com padrão pegos emprestado das expressões regulares POSIX:

    <itemizedlist>
     <listitem>
      <para>
       <literal>|</literal> representa alternância (uma das duas alternativas).
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>*</literal> representa a repetição do item anterior zero ou
       mais vezes.
      </para>
     </listitem>
     <listitem>
      <para>
       <literal>+</literal> representa a repetição do item anterior uma ou
       mais vezes.
      </para>
     </listitem>
     <listitem>
      <para>
       Os parênteses <literal>()</literal> podem ser utilizados para agrupar
       itens em um único item lógico.
      </para>
     </listitem>
     <listitem>
      <para>
       A expressão de colchetes <literal>[...]</literal> especifica uma classe
       de caracteres, do mesmo modo que na expressão regular POSIX.
      </para>
     </listitem>
    </itemizedlist>

     Deve ser observado que as repetições limitadas (<literal>?</literal> e
     <literal>{...}</literal>) não estão disponíveis, embora existam no
     POSIX. Além disso, o ponto (<literal>.</literal>) não é um metacaractere.
    </para>

    <para>
     Da mesma forma que no <function>LIKE</function>, a contrabarra desabilita
     o significado especial de qualquer um dos metacaracteres; ou pode ser
     especificado um caractere de escape diferente por meio da cláusula
     <literal>ESCAPE</literal>.
    </para>

   <para>
    Alguns exemplos:
<screen>
<userinput>'abc' SIMILAR TO 'abc'</userinput>      <lineannotation>verdade</lineannotation>
<userinput>'abc' SIMILAR TO 'a'</userinput>        <lineannotation>falso</lineannotation>
<userinput>'abc' SIMILAR TO '%(b|d)%'</userinput>  <lineannotation>verdade</lineannotation>
<userinput>'abc' SIMILAR TO '(b|c)%'</userinput>   <lineannotation>falso</lineannotation>
</screen>
   </para>

    <para>
     A função <function>substring</function> com três parâmetros,
     <function>substring(<parameter>cadeia_de_caracteres</parameter> FROM
     <replaceable>padrão</replaceable> FOR
     <replaceable>caractere_de_escape</replaceable>)</function>, permite extrair
     a parte da cadeia de caracteres que corresponde ao padrão da expressão
     regular <acronym>SQL:1999</acronym>. Assim como em <literal>SIMILAR TO</literal>,
     o padrão especificado deve corresponder a toda a cadeia de caracteres,
     senão a função falha e retorna nulo. Para indicar a parte do padrão que
     deve ser retornada em caso de sucesso, o padrão deve conter duas
     ocorrências do caractere de escape seguidas por aspas (<literal>"</literal>).
     É retornado o texto correspondente à parte do padrão entre estas marcas.
    </para>

   <para>
    Alguns exemplos:
<screen>
<userinput>substring('foobar' FROM '%#"o_b#"%' FOR '#')</userinput>   <lineannotation>oob</lineannotation>
<userinput>substring('foobar' FROM '#"o_b#"%' FOR '#')</userinput>    <lineannotation>NULL</lineannotation>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-posix-regexp">
   <title>Expressões regulares POSIX</title>

   <indexterm zone="functions-posix-regexp">
    <primary>expressão regular</primary>
    <seealso>correspondência com padrão</seealso>
   </indexterm>

   <para>
    A <xref linkend="functions-posix-table"> mostra os operadores disponíveis
    para correspondência com padrão utilizando as expressões regulares POSIX.
   </para>

   <table id="functions-posix-table">
    <title>Operadores de correspondência para expressões regulares</title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Operador</entry>
       <entry>Descrição</entry>
       <entry>Exemplo</entry>
      </row>
     </thead>

      <tbody>
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>Corresponde à expressão regular, diferenciando maiúsculas e minúsculas</entry>
        <entry><literal>'thomas' ~ '.*thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>~*</literal> </entry>
        <entry>Corresponde à expressão regular, não diferenciando maiúsculas e minúsculas</entry>
        <entry><literal>'thomas' ~* '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~</literal> </entry>
        <entry>Não corresponde à expressão regular, diferenciando maiúsculas e minúsculas</entry>
        <entry><literal>'thomas' !~ '.*Thomas.*'</literal></entry>
       </row>

       <row>
        <entry> <literal>!~*</literal> </entry>
        <entry>Não corresponde à expressão regular, não diferenciando maiúsculas e minúsculas</entry>
        <entry><literal>'thomas' !~* '.*vadim.*'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <para>
     As expressões regulares <acronym>POSIX</acronym> fornecem uma forma
     mais poderosa para correspondência com padrão
     que os operadores <function>LIKE</function> e
     <function>SIMILAR TO</function>.
     Muitas ferramentas do Unix, como <command>egrep</command>,
     <command>sed</command> e <command>awk</command>, utilizam uma linguagem
     para correspondência com padrão semelhante à descrita aqui.
    </para>

    <para>
     Uma expressão regular é uma seqüência de caracteres contendo uma
     definição abreviada de um conjunto de cadeias de caracteres (um
     <firstterm>conjunto regular</firstterm>). Uma cadeia de caracteres é dita
     correspondendo a uma expressão regular se for membro do conjunto regular
     descrito pela expressão regular. Assim como no <function>LIKE</function>,
     os caracteres do padrão correspondem exatamente aos caracteres da cadeia
     de caracteres, a não ser quando forem caracteres especiais da linguagem da
     expressão regular &mdash; porém, as expressões regulares utilizam caracteres
     especiais diferentes dos utilizados pelo <function>LIKE</function>.
     Diferentemente dos padrões do <function>LIKE</function>, uma expressão
     regular pode corresponder a qualquer parte da cadeia de caracteres, a não
     ser que a expressão regular seja explicitamente ancorada ao início ou ao
     final da cadeia de caracteres.
    </para>

   <para>
    Alguns exemplos:
<screen>
<userinput>'abc' ~ 'abc'</userinput>    <lineannotation>verdade</lineannotation>
<userinput>'abc' ~ '^a'</userinput>     <lineannotation>verdade</lineannotation>
<userinput>'abc' ~ '(b|d)'</userinput>  <lineannotation>verdade</lineannotation>
<userinput>'abc' ~ '^(b|c)'</userinput> <lineannotation>falso</lineannotation>
</screen>
   </para>

    <para>
     A função <function>substring</function> com dois parâmetros,
     <function>substring(<parameter>cadeia_de_caracteres</parameter> FROM
     <replaceable>padrão</replaceable>)</function>, permite extrair a parte da
     cadeia de caracteres que corresponde ao padrão da expressão regular POSIX.
     A função retorna nulo quando não há correspondência, senão retorna a parte
     do texto que corresponde ao padrão. Entretanto, quando o padrão contém
     parênteses, é retornada a parte do texto correspondendo à primeira
     subexpressão entre parênteses (aquela cujo abre parênteses vem primeiro).
     Podem ser colocados parênteses envolvendo toda a expressão, se for desejado
     utilizar parênteses em seu interior sem disparar esta exceção. Se for
     necessária a presença de parênteses no padrão antes da subexpressão a ser
     extraída, veja os parênteses não-capturantes descritos abaixo.
    </para>

   <para>
    Alguns exemplos:
<screen>
<userinput>substring('foobar' from 'o.b')</userinput>     <lineannotation>oob</lineannotation>
<userinput>substring('foobar' from 'o(.)b')</userinput>   <lineannotation>o</lineannotation>
</screen>
   </para>

   <para>
    As expressões regulares do <productname>PostgreSQL</productname>
    são implementadas utilizando um pacote escrito por
    <ulink url="http://www.hq.nasa.gov/office/pao/History/alsj/henry.html">Henry
    Spencer</ulink>. Grande parte da descrição das expressões regulares abaixo
    foi copiada textualmente desta parte de seu manual.
   </para>

<!-- derived from the re_syntax.n man page -->

   <sect3 id="posix-syntax-details">
    <title>Detalhes das expressões regulares</title>

   <para>
    As expressões regulares (<acronym>ER</acronym>s), conforme definidas no
    <acronym>POSIX</acronym> 1003.2, estão presentes em duas formas:
    <acronym>ER</acronym>s <firstterm>estendidas</firstterm> ou
    <acronym>ERE</acronym>s (aproximadamente as do <command>egrep</command>), e
    <acronym>ER</acronym>s <firstterm>básicas</firstterm> ou
    <acronym>ERB</acronym>s (aproximadamente as do <command>ed</command>).
    O <productname>PostgreSQL</productname> suporta as duas formas, e também
    implementa algumas extensões que não fazem parte do padrão POSIX, mas que
    são muito utilizadas por estarem disponíveis em linguagens de programação
    como Perl e Tcl. As <acronym>ER</acronym>s que utilizam as extensões
    não-POSIX são chamadas de <acronym>ER</acronym>s
    <firstterm>avançadas</firstterm>  ou <acronym>ERA</acronym>s nesta
    documentação. As <acronym>ERA</acronym>s são quase um superconjunto exato
    das <acronym>ERE</acronym>s, mas as <acronym>ERB</acronym>s possuem várias
    notações incompatíveis (bem como são muito mais limitadas). Primeiro são
    descritas as formas <acronym>ERA</acronym> e <acronym>ERE</acronym>,
    indicando as funcionalidades que se aplicam somente as
    <acronym>ERA</acronym>s, e depois descrevendo como as
    <acronym>ERB</acronym>s diferem.
   </para>

   <note>
    <para>
     A forma das expressões regulares aceitas pelo
     <productname>PostgreSQL</productname> pode ser escolhida definindo o
     parâmetro em tempo de execução <xref linkend="guc-regex-flavor">.
     A definição usual é <literal>advanced</literal>, mas pode ser escolhido
     <literal>extended</literal> para o máximo de compatibilidade com as
     versões do <productname>PostgreSQL</productname> anteriores a 7.4.
    </para>
   </note>

   <para>
    Uma expressão regular é definida como uma ou mais
    <firstterm>ramificações</firstterm> separadas por
    <literal>|</literal>. Corresponde a tudo
    que corresponda a uma de suas ramificações.
   </para>

   <para>
    Uma ramificação é formada por zero ou mais
    <firstterm>átomos quantificados</firstterm>, ou
    <firstterm>restrições</firstterm>, concatenados.
    Corresponde à correspondência para a primeira, seguida pela
    correspondência para a segunda, etc.;
    uma ramificação vazia corresponde à cadeia de caracteres vazia.
   </para>

   <para>
    Um átomo quantificado é um <firstterm>átomo</firstterm> possivelmente
    seguido por um único <firstterm>quantificador</firstterm>.
    Sem o quantificador, corresponde à correspondência para o átomo.
    Com o quantificador, pode corresponder a um número de ocorrências do átomo.
    Um <firstterm>átomo</firstterm> pode ser uma das possibilidades
    mostradas na <xref linkend="posix-atoms-table">.
    Os quantificadores possíveis e seus significados estão mostrados na
    <xref linkend="posix-quantifiers-table">.
   </para>

   <para>
    Uma <firstterm>restrição</firstterm> corresponde a uma cadeia de caracteres
    vazia, mas corresponde apenas quando determinadas condições são satisfeitas.
    Uma restrição pode ser utilizada onde um átomo pode ser utilizado, exceto
    que não pode ser seguida por um quantificador.
    As restrições simples estão mostradas na
    <xref linkend="posix-constraints-table">;
    algumas outras restrições são descritas posteriormente.
   </para>


   <table id="posix-atoms-table">
    <title>Átomos de expressões regulares</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Átomo</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>(</literal><replaceable>er</replaceable><literal>)</literal> </entry>
       <entry> (onde <replaceable>er</replaceable> é qualquer expressão regular)
       corresponde à correspondência para <replaceable>er</replaceable>, com a
       correspondência marcada para um possível relato</entry>
       </row>

       <row>
       <entry> <literal>(?:</literal><replaceable>er</replaceable><literal>)</literal> </entry>
       <entry> o mesmo acima, mas a correspondência não está marcada para relato
       (um conjunto de parênteses <quote>não-capturante</quote>)
       (somente ERAs) </entry>
       </row>

       <row>
       <entry> <literal>.</literal> </entry>
       <entry> corresponde a qualquer um único caractere </entry>
       </row>

       <row>
       <entry> <literal>[</literal><replaceable>caracteres</replaceable><literal>]</literal> </entry>
       <entry> uma <firstterm>expressão de colchetes</firstterm>, correspondendo
       a qualquer um dos <replaceable>caracteres</replaceable> (consulte a
       <xref linkend="posix-bracket-expressions"> para obter mais detalhes) </entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>k</> </entry>
       <entry> (onde <replaceable>k</replaceable> é um caractere não alfanumérico)
       corresponde a este caractere tomado como um caractere ordinário,
       por exemplo, <literal>\\</literal> corresponde ao caractere contrabarra </entry>
       </row>

       <row>
       <entry> <literal>\</literal><replaceable>c</replaceable> </entry>
       <entry> onde <replaceable>c</replaceable> é alfanumérico (possivelmente
       seguido por outros caracteres) é um <firstterm>escape</firstterm>, consulte a
       <xref linkend="posix-escape-sequences"> (ERAs somente; nas EREs e nas
       ERBs corresponde ao <replaceable>c</replaceable>) </entry>
       </row>

       <row>
       <entry> <literal>{</literal> </entry>
       <entry> quando seguido por um caractere que não seja um dígito,
       corresponde ao caractere abre chaves <literal>{</literal>;
       quando seguido por um dígito, é o início de um
       <replaceable>limite</replaceable> (veja abaixo) </entry>
       </row>

       <row>
       <entry> <replaceable>x</replaceable> </entry>
       <entry> onde <replaceable>x</replaceable> é um único caractere sem
       nenhum outro significado, corresponde a este caractere </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Uma expressão regular não pode terminar por <literal>\</literal>.
   </para>

   <note>
    <para>
     Lembre-se que a contrabarra (<literal>\</literal>) tem um significado
     especial nos literais cadeias de caracteres do
     <productname>PostgreSQL</productname>.
     Para escrever em uma constante um padrão contendo uma contrabarra,
     devem ser escritas duas contrabarras na declaração.
    </para>
   </note>

   <table id="posix-quantifiers-table">
    <title>Quantificadores de expressão regular</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Quantificador</entry>
       <entry>Corresponde</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>*</> </entry>
       <entry> uma seqüência de 0 ou mais correspondências do átomo </entry>
       </row>

       <row>
       <entry> <literal>+</> </entry>
       <entry> uma seqüência de 1 ou mais correspondências do átomo </entry>
       </row>

       <row>
       <entry> <literal>?</> </entry>
       <entry> uma seqüência de 0 ou 1 correspondência do átomo </entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}</> </entry>
       <entry> uma seqüência de exatamente <replaceable>m</replaceable> correspondências do átomo </entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}</> </entry>
       <entry> uma seqüência de <replaceable>m</replaceable> ou mais correspondências do átomo </entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
       <entry> uma seqüência de <replaceable>m</replaceable> a
       <replaceable>n</replaceable> (inclusive) correspondências do átomo;
       <replaceable>m</replaceable> não pode ser maior do que
       <replaceable>n</replaceable> </entry>
       </row>

       <row>
       <entry> <literal>*?</> </entry>
       <entry> versão não-voraz do <literal>*</> </entry>
       </row>

       <row>
       <entry> <literal>+?</> </entry>
       <entry> versão não-voraz do <literal>+</> </entry>
       </row>

       <row>
       <entry> <literal>??</> </entry>
       <entry> versão não-voraz do <literal>?</> </entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>}?</> </entry>
       <entry> versão não-voraz do <literal>{</><replaceable>m</><literal>}</> </entry>
       </row>

       <row>
       <entry> <literal>{</><replaceable>m</><literal>,}?</> </entry>
       <entry> versão não-voraz do <literal>{</><replaceable>m</><literal>,}</> </entry>
       </row>

       <row>
       <entry>
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</> </entry>
       <entry> versão não-voraz do <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</> </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    As formas que utilizam <literal>{</><replaceable>...</><literal>}</>
    são conhecidas como <firstterm>limite</firstterm>s.
    Os números <replaceable>m</replaceable> e <replaceable>n</replaceable>
    dentro dos limites são inteiros decimais sem sinal, com valores permitidos
    entre 0 e 255, inclusive.
   </para>

    <para>
     Quantificadores <firstterm>não-voraz</firstterm>es (disponíveis apenas nas
     ERAs) correspondem às mesmas possibilidades que seus semelhantes normais
     (<firstterm>voraz</firstterm>es), mas preferem o menor número em vez do
     maior número de correspondências.
     Consulte a <xref linkend="posix-matching-rules"> para obter mais detalhes.
   </para>

   <note>
    <para>
     Um quantificador não pode vir imediatamente após outro quantificador.
     Um quantificador não pode começar uma expressão ou uma subexpressão, ou
     seguir <literal>^</literal> ou <literal>|</literal>.
    </para>
   </note>

   <table id="posix-constraints-table">
    <title>Restrições de expressão regular</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Restrição</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>^</> </entry>
       <entry> corresponde no início da cadeia de caracteres </entry>
       </row>

       <row>
       <entry> <literal>$</> </entry>
       <entry> corresponde no fim da cadeia de caracteres </entry>
       </row>

       <row>
       <entry> <literal>(?=</><replaceable>er</><literal>)</> </entry>
       <entry> <firstterm>olhar à frente positiva</firstterm>
       <footnote>
        <para>
         (?=padrão) &mdash; olhar à frente positiva (<literal>positive
         lookahead</literal>) corresponde à cadeia de caracteres de procura
         em qualquer ponto onde começa uma cadeia de caracteres correspondendo
         ao padrão. Esta é uma correspondência não capturante, ou seja,
         a correspondência não é capturada para um possível uso posterior.
         Por exemplo <literal>'Windows (?=95|98|NT|2000)'</literal> corresponde
         a <quote><literal>Windows</literal></quote> em
         <quote><literal>Windows 2000</literal></quote>,
         mas não a <quote><literal>Windows</literal></quote> em
         <quote><literal>Windows 3.1</literal></quote>. Olhar à frente não
         consome caracteres, ou seja, após ocorrer a correspondência a procura
         pela próxima ocorrência começa imediatamente após a última ocorrência,
         e não após os caracteres compreendidos pelo olhar à frente.
         <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/js56jsgrpregexpsyntax.asp">
         Introduction to Regular Expressions</ulink> (N. do T.)
        </para>
       </footnote>
       &mdash;
       corresponde em qualquer ponto a partir de onde começa a parte da cadeia de
       caracteres que corresponde à <replaceable>er</replaceable> (somente ERAs) </entry>
       </row>

       <row>
       <entry> <literal>(?!</><replaceable>er</><literal>)</> </entry>
       <entry> <firstterm>olhar à frente negativa</firstterm>
       <footnote>
        <para>
         (?!padrão) &mdash; olhar à frente negativa (<literal>negative
         lookahead</literal>) corresponde à cadeia de caracteres de procura em
         qualquer ponto onde começa uma cadeia de caracteres que não corresponde
         ao padrão. Esta é uma correspondência não capturante, ou seja,
         a correspondência não é capturada para um possível uso posterior.
         Por exemplo <literal>'Windows (?!95|98|NT|2000)'</literal> corresponde
         a <quote><literal>Windows</literal></quote> em
         <quote><literal>Windows 3.1</literal></quote>,
         mas não a <quote><literal>Windows</literal></quote> em
         <quote><literal>Windows 2000</literal></quote>. Olhar à frente não
         consome caracteres, ou seja, após ocorrer a correspondência a procura
         pela próxima ocorrência começa imediatamente após a última ocorrência,
         e não após os caracteres compreendidos pelo olhar à frente.
         <ulink url="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/script56/html/js56jsgrpregexpsyntax.asp">
         Introduction to Regular Expressions</ulink> (N. do T.)
        </para>
       </footnote>
       &mdash;
       corresponde em qualquer ponto a partir de onde começa uma parte da cadeia
       de caracteres que não corresponde à <replaceable>er</replaceable>
       (somente ERAs) </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Alguns exemplos: (N. do T.)
<screen>
<userinput>substring('Windows 2000' FROM 'Windows (?=95|98|NT|2000)')</userinput>     <lineannotation>Windows</lineannotation>
<userinput>substring('Windows 3.1'  FROM 'Windows (?=95|98|NT|2000)')</userinput>     <lineannotation>NULL</lineannotation>
<userinput>substring('Windows 2000' FROM 'Windows (?!95|98|NT|2000)')</userinput>     <lineannotation>NULL</lineannotation>
<userinput>substring('Windows 3.1'  FROM 'Windows (?!95|98|NT|2000)')</userinput>     <lineannotation>Windows</lineannotation>
</screen>
   </para>

   <para>
    As restrições de olhar à frente não podem conter
    <firstterm>referências para trás</firstterm>
    (consulte a <xref linkend="posix-escape-sequences">),
    e todos os parênteses dentro das mesmas são considerados não-capturantes.
   </para>
   </sect3>

   <sect3 id="posix-bracket-expressions">
    <title>Expressões de colchetes</title>

   <para>
    Uma <firstterm>expressão de colchetes</firstterm> é uma lista de
    caracteres entre <literal>[]</literal>. Normalmente corresponde
    a qualquer um único caractere da lista (mas veja abaixo). Se a lista
    começar por <literal>^</literal>, corresponde a qualquer um único caractere
    não presente no restante da lista (mas veja abaixo). Se dois caracteres da
    lista estiverem separados por <literal>-</literal>, isto representa a
    forma abreviada de todos os caracteres entre estes dois (inclusive) na
    seqüência de classificação (<literal>collating sequence</literal>
    <footnote>
     <para>
      <literal>collation</literal>; <literal>collating sequence</literal> &mdash;
      Um método para comparar duas cadeias de caracteres comparáveis.
      Todo conjunto de caracteres possui seu <literal>collation</literal> padrão.
      (Second Informal Review Draft) ISO/IEC 9075:1992, Database
      Language SQL- July 30, 1992. (N. do T.)
      </para>
    </footnote>
    ) como, por exemplo, <literal>[0-9]</literal> em <acronym>ASCII</acronym>
    corresponde a qualquer dígito decimal.  É ilegal dois intervalos
    compartilharem uma mesma extremidade como, por exemplo,
    <literal>a-c-e</literal>. Os intervalos são dependentes da seqüência de
    classificação dos caracteres, e os programas portáveis devem evitar esta
    dependência.
   </para>

   <para>
    Para incluir o literal <literal>]</literal> na lista, deve ser feito com que
    seja o primeiro caractere (seguindo um possível <literal>^</literal>). Para
    incluir o literal <literal>-</literal>, deve ser feito com que seja o primeiro
    ou o último caractere, ou a segunda extremidade de um intervalo. Para utilizar o
    literal <literal>-</literal> como a primeira extremidade do intervalo, deve-se
    colocá-lo entre <literal>[.</literal> e <literal>.]</literal> para torná-lo um
    elemento de classificação (veja abaixo). Com exceção destes caracteres,
    algumas combinações utilizando <literal>[</literal> (veja os próximos
    parágrafos), e escapes (somente ERAs), todos os outros caracteres especiais
    perdem seu significado especial dentro da expressão de colchetes.
    Em particular, <literal>\</literal> não é especial ao seguir as regras das
    EREs ou ERBs, embora seja especial (como introdução de escape)
    nas ERAs.
   </para>

   <para>
    Dentro da expressão de colchetes, o elemento de classificação (um caractere,
    uma seqüência de vários caracteres que é classificada como sendo um único
    caractere, ou o nome de uma seqüência de classificação) entre
    <literal>[.</literal> e <literal>.]</literal> representa a seqüência de
    caracteres deste elemento de classificação. A seqüência é um único elemento
    da lista da expressão de colchetes. Uma expressão de colchetes contendo um
    elemento de classificação com vários caracteres pode, portanto, corresponder
    a mais de um caractere. Por exemplo, se a seqüência de classificação incluir
    o elemento de classificação <literal>ch</literal>, então a
    expressão regular <literal>[[.ch.]]*c</literal> corresponde aos cinco
    primeiros caracteres de <literal>chchcc</literal>.
   </para>

   <note>
    <para>
     Atualmente o <productname>PostgreSQL</productname> não possui elementos de
     classificação de vários caracteres. Esta informação descreve um possível
     comportamento futuro.
    </para>
   </note>

   <para>
    Dentro da expressão de colchetes, um elemento de classificação entre
    <literal>[=</literal> e <literal>=]</literal> é uma classe de equivalência,
    representando as seqüências de caracteres de todos os elementos de
    classificação equivalentes a este elemento, incluindo o próprio (Se não
    existirem outros elementos de classificação equivalentes, o tratamento é
    como se os delimitadores envoltórios fossem <literal>[.</literal> e
    <literal>.]</literal>). Por exemplo, se <literal>o</literal> e
    <literal>^</literal> são membros de uma classe de equivalência, então
    <literal>[[=o=]]</literal>, <literal>[[=^=]]</literal> e
    <literal>[o^]</literal> são todos sinônimos. Uma classe de equivalência
    não pode ser a extremidade de um intervalo.
   </para>

   <para>
    Dentro da expressão de colchetes, o nome de uma classe de caracteres
    entre <literal>[:</literal> e <literal>:]</literal> representa a
    lista de todos os caracteres pertencentes a esta classe. Os nomes das
    classes de caracteres padrão são: <literal>alnum</literal>,
    <literal>alpha</literal>, <literal>blank</literal>,
    <literal>cntrl</literal>, <literal>digit</literal>,
    <literal>graph</literal>, <literal>lower</literal>,
    <literal>print</literal>, <literal>punct</literal>,
    <literal>space</literal>, <literal>upper</literal>,
    <literal>xdigit</literal>. Estes nomes representam as classes de caracteres
    definidas em
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>.
    O idioma pode fornecer outras. Uma classe de caracteres não pode ser
    usada como extremidade de um intervalo.
   </para>

   <para>
    Existem dois casos especiais de expressões de colchetes: as expressões
    de colchetes <literal>[[:&lt;:]]</literal> e <literal>[[:&gt;:]]</literal>
    são restrições, correspondendo a cadeias de caracteres vazias no início e no
    fim da palavra, respectivamente. Uma <emphasis>palavra é definida como a
    seqüência de caracteres de palavra, que não é nem precedida nem seguida por
    caractere de palavra</emphasis>. Um caractere de palavra é um caractere
    <literal>alnum</literal> (conforme definido em
    <citerefentry><refentrytitle>ctype</refentrytitle><manvolnum>3</manvolnum></citerefentry>)
    ou um sublinhado. Isto é uma extensão, compatível mas não especificada
    pelo <acronym>POSIX</acronym> 1003.2, devendo ser utilizada com cautela em
    programas onde se deseja a portabilidade para outros sistemas.
    Os escapes de restrição descritos abaixo geralmente são preferíveis (não
    são mais padrão que estes, mas com certeza são mais fáceis de serem digitados).
   </para>
   </sect3>

   <sect3 id="posix-escape-sequences">
    <title>Escapes de expressão regular</title>

   <para>
    <firstterm>Escapes</firstterm> são seqüências especiais começando por
    <literal>\</literal> seguida por um caractere alfanumérico. Os escapes se
    apresentam em diversas variedades: entrada de caractere, abreviaturas de
    classe, escapes de restrição e referências para trás.
    Uma <literal>\</literal> seguida por um caractere alfanumérico que não
    constitua um escape válido é ilegal nas ERAs.
    Nas EREs não existem escapes: fora da expressão de colchetes, uma
    <literal>\</literal> seguida por um caractere alfanumérico representa tão
    somente este caractere como um caractere comum, e dentro da expressão de
    colchetes, a <literal>\</literal> é um caractere comum;
    Esta última é uma verdadeira incompatibilidade entre EREs e ERAs.
   </para>

   <para>
    Os <firstterm>escapes de entrada de caractere</firstterm> existem para
    tornar mais fácil a especificação de caracteres não-imprimíveis, ou de
    alguma outra maneira inconvenientes, nas expressões regulares.
    Estão mostrados na <xref linkend="posix-character-entry-escapes-table">.
   </para>

   <para>
    Os <firstterm>escapes de abreviatura de classe</firstterm> fornecem
    abreviaturas para certas classes de caracteres comumente utilizadas. Estão
    mostrados na <xref linkend="posix-class-shorthand-escapes-table">.
   </para>

   <para>
    O <firstterm>escape de restrição</firstterm> é uma restrição,
    correspondendo à cadeia de caracteres vazia caso ocorram determinadas
    condições, escrita como um escape. Estão
    mostrados na <xref linkend="posix-constraint-escapes-table">.
   </para>

   <para>
    Uma <firstterm>referência para trás</firstterm>
    (<literal>\</literal><replaceable>n</replaceable>) corresponde à
    mesma cadeia de caracteres correspondida pela subexpressão entre parênteses
    anterior especificada pelo número <replaceable>n</replaceable>
    (consulte a <xref linkend="posix-constraint-backref-table">). Por exemplo,
    <literal>([bc])\1</literal> corresponde a <literal>bb</literal> ou
    <literal>cc</literal>, mas não a <literal>bc</literal> ou
    <literal>cb</literal>. A subexpressão deve preceder inteiramente à
    referência para trás na expressão regular.
    As subexpressões são numeradas na ordem de seu parêntese de abertura.
    Parênteses não-capturantes não definem subexpressões.
   </para>

   <note>
    <para>
     Deve-se ter em mente que a <literal>\</literal> de abertura do escape
     deve ser dobrada ao se entrar o padrão usando uma constante
     cadeia de caracteres do SQL. Por exemplo:
<screen>
<userinput>'123' ~ '^\\d{3}'</userinput> <lineannotation>verdade</lineannotation>
</screen>
    </para>
   </note>

   <table id="posix-character-entry-escapes-table">
    <title>Escapes entrada de caractere em expressão regular</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Escape</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\a</> </entry>
       <entry> caractere de alerta (<literal>bell</literal>), como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\b</> </entry>
       <entry> voltar apagando (<literal>backspace</literal>), como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\B</> </entry>
       <entry> sinônimo de <literal>\</literal> para ajudar a reduzir a necessidade de
       contrabarras dobradas </entry>
       </row>

       <row>
       <entry> <literal>\c</><replaceable>X</> </entry>
       <entry> (onde <replaceable>X</replaceable> é qualquer caractere) o
       caractere cujos 5 bits de mais baixa ordem são os mesmos de
       <replaceable>X</replaceable>, e cujos outros bits são todos zero </entry>
       </row>

       <row>
       <entry> <literal>\e</> </entry>
       <entry> o caractere cujo nome da seqüência de classificação
       é <literal>ESC</literal> ou,
       na falta deste, o caractere com valor octal 033 </entry>
       </row>

       <row>
       <entry> <literal>\f</> </entry>
       <entry> avanço de formulário, como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\n</> </entry>
       <entry> nova-linha, como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\r</> </entry>
       <entry> retorno-de-carro, como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\t</> </entry>
       <entry> tabulação horizontal, como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\u</><replaceable>wxyz</> </entry>
       <entry> (onde <replaceable>wxyz</replaceable> são exatamente quatro
       dígitos hexadecimais) o caractere Unicode
       <literal>U+</literal><replaceable>wxyz</replaceable>
       na ordem de bytes local </entry>
       </row>

       <row>
       <entry> <literal>\U</><replaceable>stuvwxyz</> </entry>
       <entry> (onde <replaceable>stuvwxyz</replaceable> são exatamente oito
       dígitos hexadecimais)
       reservado para uma extensão hipotética do Unicode para 32 bits
       </entry>
       </row>

       <row>
       <entry> <literal>\v</> </entry>
       <entry> tabulação vertical, como na linguagem C </entry>
       </row>

       <row>
       <entry> <literal>\x</><replaceable>hhh</> </entry>
       <entry> (onde <replaceable>hhh</replaceable> é qualquer seqüência de
       dígitos hexadecimais) o caractere cujo valor hexadecimal é
       <literal>0x</literal><replaceable>hhh</replaceable> (um único caractere
       não importando quantos dígitos hexadecimais são utilizados)
       </entry>
       </row>

       <row>
       <entry> <literal>\0</> </entry>
       <entry> o caractere cujo valor é <literal>0</literal> </entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xy</> </entry>
       <entry> (onde <replaceable>xy</replaceable> são exatamente dois dígitos
       octais, e não é uma <firstterm>referência para trás</firstterm>)
       o caractere cujo valor octal é
       <literal>0</literal><replaceable>xy</replaceable> </entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>xyz</> </entry>
       <entry> (onde <replaceable>xyz</replaceable> são exatamente três dígitos
       octais, e não é uma <firstterm>referência para trás</firstterm>)
       o caractere cujo valor octal é
       <literal>0</literal><replaceable>xyz</replaceable> </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Os dígitos hexadecimais são <literal>0</literal>-<literal>9</literal>,
    <literal>a</literal>-<literal>f</literal> e
    <literal>A</literal>-<literal>F</literal>.
    Os dígitos octais são <literal>0</literal>-<literal>7</literal>.
   </para>

   <para>
    Os escapes de entrada de caractere são sempre tomados como caracteres comuns.
    Por exemplo, <literal>\135</literal> é <literal>]</literal> em ASCII, mas
    <literal>\135</literal> não termina uma expressão de colchetes.
   </para>

   <table id="posix-class-shorthand-escapes-table">
    <title>Escapes de abreviatura de classe em expressão regular</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Escape</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\d</> </entry>
       <entry> <literal>[[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\s</> </entry>
       <entry> <literal>[[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\w</> </entry>
       <entry> <literal>[[:alnum:]_]</>
       (deve ser observado que inclui o sublinhado) </entry>
       </row>

       <row>
       <entry> <literal>\D</> </entry>
       <entry> <literal>[^[:digit:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\S</> </entry>
       <entry> <literal>[^[:space:]]</> </entry>
       </row>

       <row>
       <entry> <literal>\W</> </entry>
       <entry> <literal>[^[:alnum:]_]</>
       (deve ser observado que inclui o sublinhado) </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Dentro das expressões de colchetes, <literal>\d</literal>,
    <literal>\s</literal> e <literal>\w</literal> perdem seus colchetes externos,
    e <literal>\D</literal>, <literal>\S</literal> e <literal>\W</literal> são
    ilegais (Portanto, por exemplo, <literal>[a-c\d]</literal> equivale a
    <literal>[a-c[:digit:]]</literal>.
    Também, <literal>[a-c\D]</literal>, que equivale a
    <literal>[a-c^[:digit:]]</literal>, é ilegal).
   </para>

   <table id="posix-constraint-escapes-table">
    <title>Escapes de restrição em expressão regular</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Escape</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\A</> </entry>
       <entry> corresponde apenas no início da cadeia de caracteres
       (veja na <xref linkend="posix-matching-rules"> como isto difere de
       <literal>^</literal>) </entry>
       </row>

       <row>
       <entry> <literal>\m</> </entry>
       <entry> corresponde apenas no início da palavra </entry>
       </row>

       <row>
       <entry> <literal>\M</> </entry>
       <entry> corresponde apenas no final da palavra </entry>
       </row>

       <row>
       <entry> <literal>\y</> </entry>
       <entry> corresponde apenas no início ou no final da palavra </entry>
       </row>

       <row>
       <entry> <literal>\Y</> </entry>
       <entry> corresponde apenas no ponto que não é nem o início nem o final
       da palavra </entry>
       </row>

       <row>
       <entry> <literal>\Z</> </entry>
       <entry> corresponde apenas no final da cadeia de caracteres
       (veja na <xref linkend="posix-matching-rules"> como isto difere de
       <literal>$</>) </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Uma palavra é definida como na especificação de
    <literal>[[:&lt;:]]</literal> e <literal>[[:&gt;:]]</literal> acima.
    Os escapes de restrição são ilegais dentro de expressões de colchetes.
   </para>

   <table id="posix-constraint-backref-table">
    <title>Referências para trás em expressões regulares</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Escape</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>\</><replaceable>m</> </entry>
       <entry> (onde <replaceable>m</replaceable> é um dígito diferente de zero)
       uma referência para trás à <replaceable>m</replaceable>'ésima subexpressão </entry>
       </row>

       <row>
       <entry> <literal>\</><replaceable>mnn</> </entry>
       <entry> (onde <replaceable>m</replaceable> é um dígito diferente de zero,
       e <replaceable>nn</replaceable> são mais alguns dígitos, e o valor
       decimal <replaceable>mnn</replaceable> não é maior do que o número de
       parênteses capturantes fechados até este ponto) uma referência para trás
       à <replaceable>mnn</replaceable>'ésima subexpressão </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <note>
    <para>
     Existe uma ambigüidade histórica inerente entre as entradas de caractere
     em octal para escapes e referências para trás, que é solucionado por
     heurística, como mostrado acima.
     Um zero na frente sempre indica um escape octal.
     Um único dígito diferente de zero, não seguido por outro dígito,
     é sempre assumido como uma referência para trás.
     Uma seqüência de vários dígitos não começada por zero é assumida como uma
     referência para trás se vier após uma subexpressão adequada
     (ou seja, o número está na faixa legal de referências para trás),
     senão é assumida como um octal.
    </para>
   </note>
   </sect3>

   <sect3 id="posix-metasyntax">
    <title>Metassintaxe em expressão regular</title>

   <para>
    Além da sintaxe principal descrita acima, existem algumas formas
    especiais e uma miscelânea de facilidades de sintaxe disponíveis.
   </para>

   <para>
    Normalmente, a variedade da expressão regular sendo utilizada é determinada
    por <xref linkend="guc-regex-flavor">, mas pode ser mudada pelo prefixo
    <firstterm>diretriz</firstterm>.
    Se a expressão regular começar por <literal>***:</>, o restante da expressão
    regular é assumido como sendo uma ARE a despeito de
    <xref linkend="guc-regex-flavor">.
    Se a expressão regular começar por <literal>***=</>, o restante da expressão
    regular é assumido como sendo um literal cadeia de caracteres, com todos os
    caracteres considerados como sendo caracteres comuns.
   </para>

   <para>
    Uma ERA pode começar por <firstterm>opções incorporadas</firstterm>:
    uma seqüência <literal>(?</><replaceable>xyz</><literal>)</>
    (onde <replaceable>xyz</replaceable> é um ou mais caracteres alfabéticos)
    especifica opções que afetam o restante da expressão regular.
    Estas opções substituem qualquer opção previamente determinada (incluindo
    a variedade da expressão regular e a diferenciação de maiúsculas e
    minúsculas). As letras das opções disponíveis estão mostradas
    na <xref linkend="posix-embedded-options-table">.
   </para>

   <table id="posix-embedded-options-table">
    <title>Letras de opção incorporada em ERA</title>

    <tgroup cols="2">
     <thead>
      <row>
       <entry>Opção</entry>
       <entry>Descrição</entry>
      </row>
     </thead>

      <tbody>
       <row>
       <entry> <literal>b</> </entry>
       <entry> o restante da expressão regular é uma ERB </entry>
       </row>

       <row>
       <entry> <literal>c</> </entry>
       <entry> correspondência fazendo distinção entre letras maiúsculas e
       minúsculas (substitui o tipo do operador) </entry>
       </row>

       <row>
       <entry> <literal>e</> </entry>
       <entry> o restante da expressão regular é uma ERE </entry>
       </row>

       <row>
       <entry> <literal>i</> </entry>
       <entry> correspondência não fazendo distinção entre letras maiúsculas e
       minúsculas (consulte a <xref linkend="posix-matching-rules">) (substitui
       o tipo do operador) </entry>
       </row>

       <row>
       <entry> <literal>m</> </entry>
       <entry> sinônimo histórico para <literal>n</literal> </entry>
       </row>

       <row>
       <entry> <literal>n</> </entry>
       <entry> correspondência sensível à nova-linha (consulte a
       <xref linkend="posix-matching-rules">) </entry>
       </row>

       <row>
       <entry> <literal>p</> </entry>
       <entry> correspondência sensível à nova-linha parcial (consulte a
       <xref linkend="posix-matching-rules">) </entry>
       </row>

       <row>
       <entry> <literal>q</> </entry>
       <entry> o restante da expressão regular é um literal cadeia de caracteres
       (<quote>entre aspas</quote>), todos caracteres são comuns </entry>
       </row>

       <row>
       <entry> <literal>s</> </entry>
       <entry> correspondência não sensível à nova-linha (padrão) </entry>
       </row>

       <row>
       <entry> <literal>t</> </entry>
       <entry> sintaxe amarrada (padrão; veja abaixo) </entry>
       </row>

       <row>
       <entry> <literal>w</> </entry>
       <entry> correspondência sensível a nova-linha parcial inversa
       (<quote>estranha</quote>)
       (consulte a <xref linkend="posix-matching-rules">) </entry>
       </row>

       <row>
       <entry> <literal>x</> </entry>
       <entry> sintaxe expandida (veja abaixo) </entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    As opções incorporadas se tornam ativas no fecha parênteses
    <quote><literal>)</literal></quote> que termina
    a seqüência. Podem aparecer apenas no início de uma ERA
    (após a diretriz <literal>***:</>, caso exista).
   </para>

   <para>
    Além da sintaxe de expressão regular usual (<firstterm>amarrada</firstterm>),
    na qual todos os caracteres possuem significado, existe uma sintaxe
    <firstterm>expandida</firstterm>, disponível especificando-se a opção
    incorporada <literal>x</literal>.
    Na sintaxe expandida, os caracteres de espaço-em-branco na expressão regular
    são ignorados, assim como todos os caracteres entre a <literal>#</literal>
    e a próxima nova-linha (ou o fim da expressão regular). Isto permite colocar
    parágrafos e comentários em uma expressão regular complexa.
    Existem três exceções para esta regra básica:

    <itemizedlist>
     <listitem>
      <para>
       um caractere de espaço em branco ou <literal>#</literal> precedido por
       <literal>\</literal> é retido
      </para>
     </listitem>
     <listitem>
      <para>
       espaço em branco ou <literal>#</literal> dentro da expressão de colchetes
       é retido
      </para>
     </listitem>
     <listitem>
      <para>
       espaço em branco e comentários são ilegais dentro de símbolos
       multicaractere, como o <literal>(?:</literal>
      </para>
     </listitem>
    </itemizedlist>

    Para esta finalidade os caracteres de espaço-em-branco são espaço, tabulação,
    nova-linha e qualquer outro caractere que pertença a classe de caracteres
    <replaceable>space</replaceable>.
   </para>

   <para>
    Por fim, em uma ERA, fora das expressões de colchetes, a seqüência
    <literal>(?#</literal><replaceable>ttt</replaceable><literal>)</literal>
    (onde <replaceable>ttt</replaceable> é qualquer texto não contendo um
    <literal>)</literal>) é um comentário, completamente ignorado.
    Novamente, isto não é permitido entre os caracteres dos símbolos
    multicaractere, como o <literal>(?:</literal>. Estes comentários são mais
    um artefato histórico do que uma funcionalidade útil, e sua utilização está
    obsoleta; deve ser usada a sintaxe expandida em seu lugar.
   </para>

   <para>
    <emphasis>Nenhuma</emphasis> destas extensões da metassintaxe está
    disponível quando uma diretriz inicial <literal>***=</literal> especificar
    que a entrada do usuário deve ser tratada como um literal cadeia de
    caracteres em vez de uma expressão regular.
   </para>
   </sect3>

   <sect3 id="posix-matching-rules">
    <title>Regras de correspondência de expressão regular</title>

   <para>
    Quando uma expressão regular corresponde a mais de uma parte de uma dada
    cadeia de caracteres, a expressão regular corresponde à parte que começa
    primeiro. Se a expressão regular puder corresponder a mais de uma parte da
    cadeia de caracteres começando neste ponto, então corresponderá à
    correspondência mais longa possível, ou corresponderá à correspondência mais
    curta possível, dependendo se a expressão regular é <firstterm>voraz</>
    (<literal>greedy</literal>) ou <firstterm>não-voraz</>
    (<literal>non-greedy</literal>).
   </para>

   <para>
    Se a expressão regular é voraz ou não, é determinado pelas seguintes regras:
    <itemizedlist>
     <listitem>
      <para>
       A maioria dos átomos, e todas as restrições, não possuem atributos de
       voracidade (porque não podem corresponder a quantidades variáveis de
       texto de qualquer forma).
      </para>
     </listitem>
     <listitem>
      <para>
       A adição de parênteses em torno da expressão regular não muda
       sua voracidade.
      </para>
     </listitem>
     <listitem>
      <para>
       Um átomo quantificado por um quantificador de repetição fixo
       (<literal>{</><replaceable>m</><literal>}</>
       ou
       <literal>{</><replaceable>m</><literal>}?</>)
       possui a mesma voracidade (possivelmente nenhuma) do próprio átomo.
      </para>
     </listitem>
     <listitem>
      <para>
       Um átomo quantificado por outros quantificadores normais (incluindo
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}</>
       com <replaceable>m</> igual a <replaceable>n</>)
       é voraz (prefere a correspondência mais longa).
      </para>
     </listitem>
     <listitem>
      <para>
       Um átomo quantificado por um quantificador não voraz (incluindo
       <literal>{</><replaceable>m</><literal>,</><replaceable>n</><literal>}?</>
       com <replaceable>m</> igual a <replaceable>n</>)
       é não-voraz (prefere a correspondência mais curta).
      </para>
     </listitem>
     <listitem>
      <para>
       Uma ramificação &mdash; ou seja, uma expressão regular que não possua
       o operador de nível mais alto <literal>|</> &mdash; possui a mesma
       voracidade do primeiro átomo quantificado nesta que possui o atributo
       de voracidade.
      </para>
     </listitem>
     <listitem>
      <para>
       Uma expressão regular formada por duas ou mais ramificações
       conectadas pelo operador <literal>|</> é sempre voraz.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    As regras acima associam os atributos de voracidade não apenas aos átomos
    quantificados individualmente, mas também com as ramificações e as
    expressões regulares inteiras contendo átomos quantificados. Isto significa
    que a correspondência é feita de uma forma que a ramificação, ou toda a
    expressão regular, corresponda à parte da cadeia de caracteres mais longa
    ou mais curta possível <emphasis>como um todo</>. Uma vez que seja
    determinado o comprimento de toda a correspondência, a parte desta que
    corresponde a uma determinada subexpressão é determinada com base no
    atributo de voracidade desta subexpressão, com as subexpressões que
    começam primeiro na expressão regular tendo prioridade sobre as que começam
    depois.
   </para>

   <para>
    Exemplo do que isto significa:
<programlisting>
SELECT substring('XY1234Z', 'Y*([0-9]{1,3})');
<lineannotation>Resultado: </lineannotation><computeroutput>123</computeroutput>
SELECT substring('XY1234Z', 'Y*?([0-9]{1,3})');
<lineannotation>Resultado: </lineannotation><computeroutput>1</computeroutput>
</programlisting>
    No primeiro caso, a expressão regular como um todo é voraz porque
    <literal>Y*</> é voraz. Pode corresponder a partir do <literal>Y</>, e
    corresponde à cadeia de caracteres mais longa possível começando neste
    ponto, ou seja, <literal>Y123</>.
    A saída é a parte entre parênteses da expressão, ou seja, <literal>123</>.
    No segundo caso, a expressão regular como um todo não é voraz porque
    <literal>Y*?</> é não voraz. Pode corresponder a partir do <literal>Y</>,
    e corresponde à cadeia de caracteres mais curta possível começando neste
    ponto, ou seja, <literal>Y1</>.
    A subexpressão <literal>[0-9]{1,3}</> é voraz, mas não pode mudar a decisão
    para o comprimento de correspondência geral; portanto é forçada a
    corresponder apenas ao <literal>1</>.
   </para>

   <para>
    Em resumo, quando a expressão regular contém tanto subexpressões vorazes
    quanto não vorazes, o comprimento total da correspondência é o mais longo
    possível ou o mais curto possível, de acordo com o atributo atribuído a
    expressão regular como um todo. Os atributos atribuídos às subexpressões
    afetam somente quanto desta correspondência estas podem <quote>comer</>
    com relação a cada uma outra.
   </para>

   <para>
    Os quantificadores <literal>{1,1}</> e <literal>{1,1}?</> podem ser
    utilizados para obrigar voracidade e não-voracidade, respectivamente,
    nas subexpressões ou na expressão regular como um todo.
   </para>

   <para>
    Os comprimentos de correspondência são medidos em caracteres, e não em
    elementos de classificação.
    Uma cadeia de caracteres vazia é considerada mais longa do que nenhuma
    correspondência.
    Por exemplo:
    <literal>bb*</literal> corresponde aos três caracteres do meio
    de <literal>abbbc</literal>;
    <literal>(week|wee)(night|knights)</literal>
    coresponde a todos os dez caracteres de <literal>weeknights</literal>;
    quando é feita a correspondência entre <literal>(.*).*</literal>
    e <literal>abc</literal>, a subexpressão entre parênteses corresponde a
    todos os três caracteres;
    e quando é feita a correspondência entre <literal>(a*)*</literal> e
    <literal>bc</literal>, tanto toda a expressão regular quanto a subexpressão
    entre parênteses correspondem a uma cadeia de caracteres vazia.
   </para>

   <para>
    Se for especificada uma correspondência não diferenciando maiúsculas de
    minúsculas, o efeito é como se toda a distinção entre letras maiúsculas
    e minúsculas tivesse desaparecido do alfabeto.
    Quando um caractere alfabético que existe em minúscula e maiúscula aparece
    como um caractere comum fora da expressão de colchetes, este é efetivamente
    transformado em uma expressão de colchetes contendo as duas representações:
    por exemplo, <literal>x</literal> se torna <literal>[xX]</literal>.
    Quando aparece dentro de uma expressão de colchetes, todas as outras
    representações são adicionadas à expressão de colchetes: por exemplo,
    <literal>[x]</literal> se torna <literal>[xX]</literal>
    e <literal>[^x]</literal> se torna <literal>[^xX]</literal>.
   </para>

   <para>
    Se for especificada uma correspondência sensível a nova-linha,
    o <literal>.</literal> e as expressões de colchetes utilizando
    <literal>^</literal> nunca vão corresponder ao caractere de nova-linha
    (portanto a correspondência nunca atravessa as novas-linhas, a menos que
    a expressão regular determine explicitamente que isto seja feito),
    e <literal>^</literal> e <literal>$</literal> vão corresponder à cadeia de
    caracteres vazia após e antes da nova-linha, respectivamente, além de
    corresponderem ao início e fim da cadeia de caracteres, respectivamente.
    Mas os escapes <literal>\A</literal> e <literal>\Z</literal> das ERAs
    continuam a corresponder <emphasis>apenas</emphasis> ao início e fim da
    cadeia de caracteres.
   </para>

   <para>
    Se for especificada a correspondência sensível a nova-linha parcial,
    isto afeta o <literal>.</literal> e as expressões de colchetes como na
    correspondência sensível a nova-linha, mas não o <literal>^</literal>
    e o <literal>$</literal>.
   </para>

   <para>
    Se for especificada a correspondência sensível a nova-linha parcial inversa,
    isto afeta o <literal>^</literal> e o <literal>$</literal> como na
    correspondência sensível a nova-linha, mas não o <literal>.</literal>
    e as expressões de colchetes.
    Não é muito útil mas é fornecido para simetria.
   </para>
   </sect3>

   <sect3 id="posix-limits-compatibility">
    <title>Limites e compatibilidade</title>

   <para>
    Nenhum limite específico é imposto para o comprimento das expressões
    regulares nesta implementação. Entretanto, os programas que pretendem ser
    altamente portáveis não devem utilizar expressões regulares mais longas do
    que 256 bytes, porque uma implementação em conformidade com o POSIX pode
    não aceitar estas expressões regulares.
   </para>

   <para>
    A única funcionalidade das ERAs realmente incompatível com as EREs do POSIX,
    é que a <literal>\</literal> não perde seu significado especial dentro das
    expressões de colchetes. Todas as outras funcionalidades das ERAs utilizam
    uma sintaxe que é ilegal ou  possuem efeitos não definidos ou não
    especificados nas EREs POSIX; a sintaxe de diretrizes na forma
    <literal>***</literal> está fora da sintaxe POSIX tanto para as ERBs quanto
    para as EREs.
   </para>

   <para>
    Muitas extensões das ERAs foram pegas emprestadas do Perl, mas algumas
    foram modificadas para que ficassem limpas, e umas poucas extensões do Perl
    não estão presentes. Entre as incompatibilidades a serem notadas estão
    <literal>\b</literal>, <literal>\B</literal>, a falta de um tratamento
    especial para a nova-linha final, a adição de expressões de colchetes
    complementadas para as coisas afetadas pela correspondência sensível
    à nova-linha, as restrições nos parênteses e referências para trás nas
    restrições de procura adiante, e a semântica de correspondência contendo
    correspondência mais longa/mais curta (em vez de primeira correspondência).
   </para>

   <para>
    Existem duas incompatibilidades significativas entre as sintaxes das ERAs e
    das ERE reconhecida pelas versões do <productname>PostgreSQL</productname>
    anteriores a 7.4:

    <itemizedlist>
     <listitem>
      <para>
       Nas ERAs, a <literal>\</literal> seguida por um caractere alfanumérico é
       um escape ou um erro, enquanto nas versões anteriores, era apenas uma
       outra forma de escrever o caractere alfanumérico.
       Isto não deve causar problemas, porque não havia razão
       para escrever esta seqüência nas versões anteriores.
      </para>
     </listitem>
     <listitem>
      <para>
       Nas ERAs, a <literal>\</literal> permanece sendo um caractere especial
       dentro de <literal>[]</literal>, portanto o literal <literal>\</literal>
       dentro da expressão de colchetes deve ser escrito como <literal>\\</literal>.
      </para>
     </listitem>
    </itemizedlist>

    Embora estas diferenças provavelmente não devam criar problemas para a
    maioria dos aplicativos, podem ser evitadas se for necessário
    definindo <varname>regex_flavor</varname> como <literal>extended</literal>.
   </para>
   </sect3>

   <sect3 id="posix-basic-regexes">
    <title>Expressões regulares básicas</title>

   <para>
    As ERBs diferem das EREs sob vários aspectos.
    <literal>|</literal>, <literal>+</literal> e <literal>?</literal> são
    caracteres comuns e não existe nada equivalente para suas funcionalidades.
    Os delimitadores para limites são <literal>\{</literal> e
    <literal>\}</literal>, com <literal>{</literal> e <literal>}</literal>
    por si só sendo caracteres comuns.
    Os parênteses para as subexpressões aninhadas são <literal>\(</literal> e
    <literal>\)</literal>, com <literal>(</literal> e <literal>)</literal>
    por si só sendo caracteres comuns.
    <literal>^</literal> é um caractere comum exceto no início da expressão
    regular ou no início de uma subexpressão entre parênteses,
    <literal>$</literal> é um caractere comum exceto no final da expressão
    regular ou no final de uma subexpressão entre parênteses,
    e <literal>*</literal> é um caractere comum se aparecer no início da
    expressão regular ou no início de uma subexpressão entre parênteses,
    (após um possível <literal>^</literal> de abertura).
    Por fim, referências para trás de um único dígito estão disponíveis, e
    <literal>\&lt;</literal> e <literal>\&gt;</literal> são sinônimos de
    <literal>[[:&lt;:]]</literal> e <literal>[[:&gt;:]]</literal>
    respectivamente; nenhum outro escape está disponível.
   </para>
   </sect3>

<!-- end re_syntax.n man page -->

  </sect2>

  <sect2 id="functions-matching-examples">

   <sect2info>
    <author>
     <firstname>Halley</firstname>
     <surname>Pacheco de Oliveira</surname>
     <affiliation>
      <orgname>Câmara Municipal do Rio de Janeiro</orgname>
      <orgdiv>Assessoria de Informática</orgdiv>
      <address>
       <city>Rio de Janeiro</city>
       <country>Brasil</country>
      </address>
     </affiliation>
    </author>
    <date>2005-08-10</date>
   </sect2info>

   <title>Exemplos</title>

   <note>
    <para>
     Seção escrita pelo tradutor, não fazendo parte do manual original.
    </para>
   </note>

   <example id="func-match-example-similar-to">
    <title>Utilização de expressão regular em consulta</title>
    <para>
     Neste exemplo são utilizadas expressões regulares em consultas a uma tabela.
     São mostradas, também, consultas semelhantes utilizando a função
     <function>REGEXP_LIKE</function> do <productname>Oracle 10g</productname>,
     para efeitos de comparação.
     <footnote>
      <para>
       Exemplo escrito pelo tradutor, não fazendo parte do manual original.
       Fora Inês Pedrosa, escritora portuguesa, os demais nomes foram tirados de
       <ulink url="http://www2.xlibris.com/bookstore/book_excerpt.asp?bookid=801">
       Women of the Last Millennium</ulink>.
      </para>
     </footnote>
    </para>
    <para>
     Deve ser observado que no <productname>PostgreSQL</productname> quando se
     usa <function>SIMILAR TO</function> deve haver caractere de escape antes
     do sublinhado que não é metacaractere (<quote>\\_</quote>), mesmo entre
     colchetes, enquanto quando se usa o operador <quote>~</quote> deve haver
     caractere de escape antes do ponto que não é metacaractere
     (<quote>\\.</quote>), ou ser colocado entre colchetes (<quote>[.]</quote>)
     para que este perca o seu significado especial.
     O <productname>PostgreSQL</productname> utiliza a função
     <function>similar_escape()</function> para converter as expressões
     regulares no estilo SQL:1999 para o estilo POSIX, para poder usá-las
     em seu processador de expressões regulares.
    </para>
    <para>
     A função <function>REGEXP_LIKE</function> do
     <productname>Oracle 10g</productname> é semelhante ao operador
     <quote>~</quote> do <productname>PostgreSQL</productname>, mas enquanto
     na função <function>REGEXP_LIKE</function> é necessária apenas uma
     contrabarra para o escape de metacaracteres, no operador <quote>~</quote>
     são necessárias duas contrabarras, porque a primeira é consumida pelo
     interpretador de literais cadeia de caracteres.
     Nos dois casos, como é habitual nas expressões regulares, a correspondência
     se dá em qualquer ponto, a não ser que sejam utilizados os metacaracteres
     <literal>^</literal> e <literal>$</literal> para ancorar, explicitamente,
     a correspondência no início ou no fim da cadeia de caracteres,
     respectivamente.
    </para>
    <para>
     Abaixo está mostrado o script usado para criar e carregar a tabela:
    </para>

<programlisting>
\!chcp 1252
CREATE TABLE textos(texto VARCHAR(40));
INSERT INTO textos VALUES ('www.apache.org');
INSERT INTO textos VALUES ('pgdocptbr.sourceforge.net');
INSERT INTO textos VALUES ('WWW.PHP.NET');
INSERT INTO textos VALUES ('www-130.ibm.com');
INSERT INTO textos VALUES ('Julia Margaret Cameron');
INSERT INTO textos VALUES ('Sor Juana Inés de la Cruz');
INSERT INTO textos VALUES ('Inês Pedrosa');
INSERT INTO textos VALUES ('Amy Semple McPherson');
INSERT INTO textos VALUES ('Mary McCarthy');
INSERT INTO textos VALUES ('Isabella Andreine');
INSERT INTO textos VALUES ('Jeanne Marie Bouvier de la Motte Guyon');
INSERT INTO textos VALUES ('Maria Tinteretto');
INSERT INTO textos VALUES ('');
INSERT INTO textos VALUES ('  '||chr(9)||chr(10)||chr(11)||chr(12)||chr(13));
INSERT INTO textos VALUES ('192.168.0.15');
INSERT INTO textos VALUES ('pgsql-bugs-owner@postgresql.org');
INSERT INTO textos VALUES('00:08:54:15:E5:FB');
</programlisting>

    <para>
     A seguir estão mostradas as consultas efetuadas juntamente com seus
     resultados:
    </para>

    <orderedlist numeration="upperroman">
     <listitem>
      <para>
       Selecionar textos contendo um ou mais caracteres de <quote>a</quote> até
       <quote>z</quote>, seguidos por um ponto, seguido por um ou mais
       caracteres de <quote>a</quote> até <quote>z</quote>, seguidos por um
       ponto, seguido por um ou mais caracteres de <quote>a</quote> até
       <quote>z</quote>.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '([a-z]+).([a-z]+).([a-z]+)';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '^([a-z]+)\\.([a-z]+)\\.([a-z]+)$';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '^([a-z]+)[.]([a-z]+)[.]([a-z]+)$';</userinput>

<computeroutput>
           texto
---------------------------
 www.apache.org
 pgdocptbr.sourceforge.net
(2 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '^([a-z]+)\.([a-z]+)\.([a-z]+)$');</userinput>
-- ou
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '^([a-z]+)[.]([a-z]+)[.]([a-z]+)$');</userinput>

<computeroutput>
TEXTO
----------------------------------------
www.apache.org
pgdocptbr.sourceforge.net
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo um ou mais caracteres alfanuméricos,
       sublinhado ou hífen, seguidos por um ponto, seguido por um ou mais
       caracteres alfanuméricos, sublinhado ou hífen, seguidos por um ponto,
       seguido por um ou mais caracteres alfanuméricos ou sublinhado
       (\w corresponde a [a-zA-Z0-9_], ou seja, alfanuméricos e sublinhado).
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>-&gt;</prompt> <userinput>FROM textos</userinput>
<prompt>-&gt;</prompt> <userinput>WHERE texto SIMILAR TO '([[:alnum:]\\_-]+).([[:alnum:]\\_-]+).([[:alnum:]\\_]+)';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto SIMILAR TO '([\\w-]+).([\\w-]+).([\\w]+)';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^([[:alnum:]_-]+)\\.([[:alnum:]_-]+)\\.([[:alnum:]_]+)$';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^(([[:alnum:]_-]+)\\.){2}([[:alnum:]_]+)$';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^([\\w-]+)\\.([\\w-]+)\\.([\\w]+)$';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^(([\\w-]+)\\.){2}([\\w]+)$';</userinput>

<computeroutput>
           texto
---------------------------
 www.apache.org
 pgdocptbr.sourceforge.net
 WWW.PHP.NET
 www-130.ibm.com
(4 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>  2 </prompt> <userinput>FROM textos</userinput>
<prompt>  3 </prompt> <userinput>WHERE REGEXP_LIKE(texto, '^([[:alnum:]_-]+)\.([[:alnum:]_-]+)\.([[:alnum:]_]+)$');</userinput>

<computeroutput>
TEXTO
----------------------------------------
www.apache.org
pgdocptbr.sourceforge.net
WWW.PHP.NET
www-130.ibm.com
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos começando pela letra <quote>S</quote> maiúscula
       (_* equivale a %).
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO 'S%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO 'S_*';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '^S';</userinput>

<computeroutput>
           texto
---------------------------
 Sor Juana Inés de la Cruz
(1 linha)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '^S');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Sor Juana Inés de la Cruz
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo <quote>Mc</quote> em qualquer posição.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%Mc%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ 'Mc';</userinput>

<computeroutput>
        texto
----------------------
 Amy Semple McPherson
 Mary McCarthy
(2 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, 'Mc');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Amy Semple McPherson
Mary McCarthy
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos terminados por <quote>on</quote>.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%on';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ 'on$';</userinput>

<computeroutput>
                 texto
----------------------------------------
 Julia Margaret Cameron
 Amy Semple McPherson
 Jeanne Marie Bouvier de la Motte Guyon
(3 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, 'on$');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Julia Margaret Cameron
Amy Semple McPherson
Jeanne Marie Bouvier de la Motte Guyon
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos começando por <quote>J</quote> e terminando
       por <quote>n</quote>.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO 'J%n';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '^J.*n$';</userinput>

<computeroutput>
                 texto
----------------------------------------
 Julia Margaret Cameron
 Jeanne Marie Bouvier de la Motte Guyon
(2 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '^J.*n$');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Julia Margaret Cameron
Jeanne Marie Bouvier de la Motte Guyon
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo <quote>Cameron</quote> ou <quote>Marie</quote>
       em qualquer posição.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%(Cameron|Marie)%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '(Cameron|Marie)';</userinput>

<computeroutput>
                 texto
----------------------------------------
 Julia Margaret Cameron
 Jeanne Marie Bouvier de la Motte Guyon
(2 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '(Cameron|Marie)');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Julia Margaret Cameron
Jeanne Marie Bouvier de la Motte Guyon
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo <quote>Maria</quote>, <quote>Marie</quote>
       ou <quote>Mary</quote> (não seleciona <quote>Margaret</quote>).
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%Mar(ia|ie|y)%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ 'Mar(ia|ie|y)';</userinput>

<computeroutput>
                 texto
----------------------------------------
 Mary McCarthy
 Jeanne Marie Bouvier de la Motte Guyon
 Maria Tinteretto
(3 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, 'Mar(ia|ie|y)');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Mary McCarthy
Jeanne Marie Bouvier de la Motte Guyon
Maria Tinteretto
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos sem nenhum caractere, ou com somente espaços em branco
       (no Oracle texto sem nenhum caractere é igual a nulo).
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto, length(texto) FROM textos WHERE texto SIMILAR TO '[[:space:]]*';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto, length(texto) FROM textos WHERE texto SIMILAR TO '\\s*';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto, length(texto) FROM textos WHERE texto ~ '^[[:space:]]*$';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto, length(texto) FROM textos WHERE texto ~ '^\\s*$';</userinput>

<computeroutput>
 texto | length
-------+--------
       |      0
       |      7
(2 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto, length(texto) FROM textos WHERE REGEXP_LIKE(texto, '^[[:space:]]*$');</userinput>

<computeroutput>
TEXTO                                    LENGTH(TEXTO)
---------------------------------------- -------------
                                                     7
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo a letra <quote>W</quote> minúscula ou
       maiúscula, seguida por uma ou mais letras <quote>W</quote> minúsculas
       ou maiúsculas.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%[Ww]([Ww]+)%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '[Ww]([Ww]+)';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '[Ww]{2,}';</userinput>

<computeroutput>
      texto
-----------------
 www.apache.org
 WWW.PHP.NET
 www-130.ibm.com
(3 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '[Ww]([Ww]+)');</userinput>
-- ou
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '[Ww]{2,}');</userinput>

<computeroutput>
TEXTO
----------------------------------------
www.apache.org
WWW.PHP.NET
www-130.ibm.com
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo <quote>Inês</quote>, com letras maiúsculas
       ou minúsculas, com ou sem acento, em qualquer posição.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%[Ii][nN][eéêEÉÊ][Ss]%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE lower(to_ascii(texto)) SIMILAR TO '%ines%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '[Ii][nN][eéêEÉÊ][Ss]';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE lower(to_ascii(texto)) ~ 'ines';</userinput>

<computeroutput>
           texto
---------------------------
 Sor Juana Inés de la Cruz
 Inês Pedrosa
(2 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '[Ii][nN][eéêEÉÊ][Ss]');</userinput>

<computeroutput>
TEXTO
----------------------------------------
Sor Juana Inés de la Cruz
Inês Pedrosa
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos contendo dígitos.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%[0-9]+%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%[[:digit:]]+%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto SIMILAR TO '%\\d+%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '[0-9]+';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '[[:digit:]]+';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto ~ '\\d+';</userinput>

<computeroutput>
       texto
-------------------
 www-130.ibm.com
 192.168.0.15
 00:08:54:15:E5:FB
(3 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '[0-9]+');</userinput>
-- ou
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE REGEXP_LIKE(texto, '[[:digit:]]+');</userinput>

<computeroutput>
TEXTO
-----------------
www-130.ibm.com
192.168.0.15
00:08:54:15:E5:FB
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos não contendo espaços em branco (texto sem nenhum
       caractere não possui espaço em branco, mas no Oracle texto sem nenhum
       caractere é igual a nulo).
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto NOT SIMILAR TO '%\\s%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto NOT SIMILAR TO '%[[:space:]]%';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto !~ '\\s';</userinput>
-- ou
<prompt>=&gt;</prompt> <userinput>SELECT texto FROM textos WHERE texto !~ '[[:space:]]';</userinput>

<computeroutput>
              texto
---------------------------------
 www.apache.org
 pgdocptbr.sourceforge.net
 WWW.PHP.NET
 www-130.ibm.com

 192.168.0.15
 pgsql-bugs-owner@postgresql.org
 00:08:54:15:E5:FB
(8 linhas)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto FROM textos WHERE NOT REGEXP_LIKE(texto, '[[:space:]]');</userinput>

<computeroutput>
TEXTO
----------------------------------------
www.apache.org
pgdocptbr.sourceforge.net
WWW.PHP.NET
www-130.ibm.com
192.168.0.15
pgsql-bugs-owner@postgresql.org
00:08:54:15:E5:FB
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos que podem ser endereços de IPv4.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>-&gt;</prompt> <userinput>FROM textos</userinput>
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^[[:digit:]]{1,3}[.][[:digit:]]{1,3}[.][[:digit:]]{1,3}[.][[:digit:]]{1,3}$';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^([[:digit:]]{1,3}[.]){3}[[:digit:]]{1,3}$';</userinput>

<computeroutput>
    texto
--------------
 192.168.0.15
(1 linha)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>  2 </prompt> <userinput>FROM textos</userinput>
<prompt>  3 </prompt> <userinput>WHERE REGEXP_LIKE(texto, '^[[:digit:]]{1,3}[.][[:digit:]]{1,3}[.][[:digit:]]{1,3}[.][[:digit:]]{1,3}$');</userinput>
-- ou
<prompt>  3 </prompt> <userinput>WHERE REGEXP_LIKE(texto, '^([[:digit:]]{1,3}[.]){3}[[:digit:]]{1,3}$');</userinput>

<computeroutput>
TEXTO
------------
192.168.0.15
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos que podem ser endereços de correio eletrônico.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>-&gt;</prompt> <userinput>FROM textos</userinput>
<prompt>-&gt;</prompt> <userinput>WHERE texto SIMILAR TO '[a-zA-Z][\\w.-]*@[a-zA-Z][\\w.-]*.[a-zA-Z]+';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto SIMILAR TO '[a-zA-Z][[:alnum:]\\_.-]*@[a-zA-Z][[:alnum:]\\_.-]*.[a-zA-Z]+';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^[a-zA-Z][\\w.-]*@[a-zA-Z][\\w.-]*[.][a-zA-Z]+$';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^[a-zA-Z][[:alnum:]_.-]*@[a-zA-Z][[:alnum:]_.-]*[.][a-zA-Z]+$';</userinput>

<computeroutput>
              texto
---------------------------------
 pgsql-bugs-owner@postgresql.org
(1 linha)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>  2 </prompt> <userinput>FROM textos</userinput>
<prompt>  3 </prompt> <userinput>WHERE REGEXP_LIKE(texto, '^[[:alnum:]_\.-]+@[[:alnum:]_\.-]+\.[a-zA-Z]+$');</userinput>

<computeroutput>
TEXTO
-------------------------------
pgsql-bugs-owner@postgresql.org
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>

     <listitem>
      <para>
       Selecionar textos que podem ser endereços de <literal>hardware</literal>
       de placa <literal>Ethernet</literal>, formados por 48 bits, expressos
       como 12 dígitos hexadecimais (0-9 e A-F maiúsculas), no formato
       <literal>12:34:56:78:9A:BC</literal>.
      </para>
      <itemizedlist mark='bullet'>
       <listitem>
        <para>
         <productname>PostgreSQL &version;</productname>
        </para>
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>-&gt;</prompt> <userinput>FROM textos</userinput>
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$';</userinput>
-- ou
<prompt>-&gt;</prompt> <userinput>WHERE texto ~ '^([0-9A-F]{2}:){5}[0-9A-F]{2}$';</userinput>

<computeroutput>
       texto
-------------------
 00:08:54:15:E5:FB
(1 linha)
</computeroutput>
</screen>
       </listitem>
       <listitem>
        <para>
         <productname>Oracle 10g</productname>
        </para>
<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT texto</userinput>
<prompt>  2 </prompt> <userinput>FROM textos</userinput>
<prompt>  3 </prompt> <userinput>WHERE REGEXP_LIKE(texto, '^[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}:[0-9A-F]{2}$');</userinput>
-- ou
<prompt>  3 </prompt> <userinput>WHERE REGEXP_LIKE(texto, '^([0-9A-F]{2}:){5}[0-9A-F]{2}$');</userinput>

<computeroutput>
TEXTO
-----------------
00:08:54:15:E5:FB
</computeroutput>
</screen>
       </listitem>
      </itemizedlist>
     </listitem>
    </orderedlist>
   </example>

   <example id="func-match-example-check">
    <title>Utilização de expressão regular em restrição de verificação</title>
    <para>
     Neste exemplo são utilizadas expressões regulares em restrição de
     verificação na criação de uma tabela.
     São utilizadas expressões regulares para verificar se os dados fornecidos
     para os campos de endereço de correio eletrônico, CEP de 9 dígitos com
     hífen, CEP de 8 dígitos sem hífen e unidade da federação são válidos.
     É mostrada, também, a criação de uma tabela semelhantes utilizando a função
     <function>REGEXP_LIKE</function> do <productname>Oracle 10g</productname>
     na restrição de verificação, para efeitos de comparação.
     <footnote>
      <para>
       Exemplo escrito pelo tradutor, não fazendo parte do manual original.
       As informações usadas neste exemplo foram retiradas da página
       <ulink url="http://www2.camara.gov.br/conheca/ouvidoria/dicas/dicasLegislativo.html">
       Comissão de Legislação Participativa da Câmara dos Deputados</ulink>.
       Outros exemplos de expressões regulares podem ser encontrados em
       <ulink url="http://www.regexplib.com/">Regular Expression Library</ulink>,
       <ulink url="http://www.15seconds.com/issue/010301.htm">Server-Side
       Validations Using Regular Expressions</ulink> e
       <ulink url="http://www.amk.ca/python/howto/regex/">Regular Expression
       HOWTO</ulink>.
      </para>
     </footnote>
    </para>
    <para>
     Deve ser observado que no <productname>Oracle 10g</productname> só é
     necessário utilizar uma contrabarra antes do ponto, e não duas como
     no <productname>PostgreSQL &version;</productname>.
    </para>
    <para>
     Abaixo está mostrada a execução do exemplo no
     <productname>PostgreSQL &version;</productname>:
    </para>
<screen>
<prompt>=&gt;</prompt> <userinput>CREATE TABLE contactos(</userinput>
<prompt>(&gt;</prompt> <userinput>   email VARCHAR(40)</userinput>   -- endereço de correio eletrônico
<prompt>(&gt;</prompt> <userinput>       CONSTRAINT chk_email</userinput>
<prompt>(&gt;</prompt> <userinput>           CHECK (email ~ '^[a-zA-Z][[:alnum:]_.-]*@[a-zA-Z][[:alnum:]_.-]*[.][a-zA-Z]+$'),</userinput>
<prompt>(&gt;</prompt> <userinput>   cep8 CHAR(8)</userinput>        -- CEP com oito dígitos sem hífen
<prompt>(&gt;</prompt> <userinput>       CONSTRAINT chk_cep8</userinput>
<prompt>(&gt;</prompt> <userinput>           CHECK (cep8 ~ '^[[:digit:]]{8}$'),</userinput>
<prompt>(&gt;</prompt> <userinput>   cep9 CHAR(9)</userinput>        -- CEP com nove dígitos com hífen
<prompt>(&gt;</prompt> <userinput>       CONSTRAINT chk_cep9</userinput>
<prompt>(&gt;</prompt> <userinput>           CHECK (cep9 ~ '^[[:digit:]]{5}-[[:digit:]]{3}$'),</userinput>
<prompt>(&gt;</prompt> <userinput>   uf CHAR(2)</userinput>          -- unidade da federação
<prompt>(&gt;</prompt> <userinput>       CONSTRAINT chk_uf</userinput>
<prompt>(&gt;</prompt> <userinput>           CHECK (uf ~ '^A(C|L|M|P)|BA|CE|DF|ES|GO|M(A|G|S|T)|P(A|B|E|I|R)|R(J|N|O|R|S)|S(C|E|P)|TO$')</userinput>
<prompt>(&gt;</prompt> <userinput>);</userinput>

<prompt>=&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160-900','DF');</userinput>
<prompt>=&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decomcamara.gov.br','70160900','70160-900','DF');</userinput>
<computeroutput>ERRO: a nova linha para a relação "contactos" viola a restrição de verificação "chk_email"</computeroutput>
<prompt>=&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','7016090','70160-900','DF');</userinput>
<computeroutput>ERRO: a nova linha para a relação "contactos" viola a restrição de verificação "chk_cep8"</computeroutput>
<prompt>=&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160900','DF');</userinput>
<computeroutput>ERRO: a nova linha para a relação "contactos" viola a restrição de verificação "chk_cep9"</computeroutput>
<prompt>=&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160-900','DG');</userinput>
<computeroutput>ERRO: a nova linha para a relação "contactos" viola a restrição de verificação "chk_uf"</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT * FROM contactos;</userinput>

<computeroutput>
          email          |   cep8   |   cep9    | uf
-------------------------+----------+-----------+----
 clp.decom@camara.gov.br | 70160900 | 70160-900 | DF
(1 linha)
</computeroutput>
</screen>

    <para>
     Abaixo está mostrada a execução de exemplo semelhante no
     <productname>Oracle 10g</productname>:
    </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>CREATE TABLE contactos(</userinput>
<prompt>  2 </prompt> <userinput>    email VARCHAR(40)</userinput>   -- endereço de correio eletrônico
<prompt>  3 </prompt> <userinput>        CONSTRAINT chk_email</userinput>
<prompt>  4 </prompt> <userinput>            CHECK (REGEXP_LIKE(email, '^[a-zA-Z][[:alnum:]_.-]*@[a-zA-Z][[:alnum:]_.-]*[.][a-zA-Z]+$')),</userinput>
<prompt>  5 </prompt> <userinput>    cep8 CHAR(8)</userinput>        -- CEP com oito dígitos sem hífen
<prompt>  6 </prompt> <userinput>        CONSTRAINT chk_cep8</userinput>
<prompt>  7 </prompt> <userinput>            CHECK (REGEXP_LIKE(cep8, '^[[:digit:]]{8}$')),</userinput>
<prompt>  8 </prompt> <userinput>    cep9 CHAR(9)</userinput>        -- CEP com nove dígitos com hífen
<prompt>  9 </prompt> <userinput>        CONSTRAINT chk_cep9</userinput>
<prompt> 10 </prompt> <userinput>            CHECK (REGEXP_LIKE(cep9, '^[[:digit:]]{5}-[[:digit:]]{3}$')),</userinput>
<prompt> 11 </prompt> <userinput>    uf CHAR(2)</userinput>          -- unidade da federação
<prompt> 12 </prompt> <userinput>        CONSTRAINT chk_uf</userinput>
<prompt> 13 </prompt> <userinput>            CHECK (REGEXP_LIKE(uf, '^A(C|L|M|P)|BA|CE|DF|ES|GO|M(A|G|S|T)|P(A|B|E|I|R)|R(J|N|O|R|S)|S(C|E|P)|TO$'))</userinput>
<prompt> 14 </prompt> <userinput>);</userinput>

<prompt>SQL&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160-900','DF');</userinput>

<prompt>SQL&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decomcamara.gov.br','70160900','70160-900','DF');</userinput>
<computeroutput>
INSERT INTO contactos VALUES('clp.decomcamara.gov.br','70160900','70160-900','DF')
*
ERRO na linha 1:
ORA-02290: restrição de verificação (SCOTT.CHK_EMAIL) violada
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','7016090','70160-900','DF');</userinput>
<computeroutput>
INSERT INTO contactos VALUES('clp.decom@camara.gov.br','7016090','70160-900','DF')
*
ERRO na linha 1:
ORA-02290: restrição de verificação (SCOTT.CHK_CEP8) violada
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160900','DF');</userinput>
<computeroutput>
INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160900','DF')
*
ERRO na linha 1:
ORA-02290: restrição de verificação (SCOTT.CHK_CEP9) violada
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160-900','DG');</userinput>
<computeroutput>
INSERT INTO contactos VALUES('clp.decom@camara.gov.br','70160900','70160-900','DG')
*
ERRO na linha 1:
ORA-02290: restrição de verificação (SCOTT.CHK_UF) violada
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT * FROM contactos;</userinput>

<computeroutput>
EMAIL                                    CEP8     CEP9      UF
---------------------------------------- -------- --------- --
clp.decom@camara.gov.br                  70160900 70160-900 DF
</computeroutput>
</screen>
   </example>

   <example id="func-match-example-cat-fields">
    <title>Utilização de expressão regular em colunas concatenadas</title>
    <para>
     Neste exemplo é utilizada uma expressão regular na consulta a uma tabela,
     onde o primeiro nome e o sobrenome estão armazenados em colunas diferentes,
     para localizar o nome de uma pessoa que pode estar armazenado de várias
     formas diferentes. Abaixo está mostrado o script usado para criar e
     carregar a tabela:
    </para>

<programlisting>
CREATE TEMPORARY TABLE nomes (nome TEXT, sobrenome TEXT);
INSERT INTO nomes VALUES ('Manuel','da Paróquia');
INSERT INTO nomes VALUES ('SEU MANUEL','DA PAROQUIA');
INSERT INTO nomes VALUES ('Manuel','da Paroquia dos Anjos');
INSERT INTO nomes VALUES ('Manuel da Paróquia',NULL);
INSERT INTO nomes VALUES ('Seu','MANUEL DA PARÓQUIA');
INSERT INTO nomes VALUES ('Dona Maria','da Capela');
</programlisting>

    <para>
     Abaixo está mostrada a consulta realizada sobre os campos nome e sobrenome
     concatenados, para localizar uma pessoa com <quote>Manuel</quote> no nome e
     <quote>Paróquia</quote> no sobrenome, juntamente com os resultados obtidos.
    </para>

<screen>
<prompt>=&gt; </prompt><userinput>\pset null '(nulo)'</userinput>
<computeroutput>A visualização de nulos é "(nulo)".</computeroutput>
<prompt>=&gt; </prompt><userinput>SELECT *</userinput>
<prompt>-&gt; </prompt><userinput>FROM nomes</userinput>
<prompt>-&gt; </prompt><userinput>WHERE (COALESCE(nome,'')||COALESCE(sobrenome,'')) ~* 'manuel.*par[oóÓ]quia';</userinput>
<computeroutput>
        nome        |       sobrenome
--------------------+-----------------------
 Manuel             | da Paróquia
 SEU MANUEL         | DA PAROQUIA
 Manuel             | da Paroquia dos Anjos
 Manuel da Paróquia | (nulo)
 Seu                | MANUEL DA PARÓQUIA
(5 linhas)
</computeroutput>
</screen>
   </example>

   <example id="func-match-example-php">
    <title>Comparação entre o PostgreSQL e o PHP</title>
    <para>
     Neste exemplo é feita a comparação entre a função
     <function>substring</function> do <productname>PostgreSQL</productname> e
     a função <function>preg_match</function> do <productname>PHP</productname>,
     utilizando uma expressão regular voraz e outra não voraz, para capturar o
     texto entre as marcas &lt;a...&gt; e &lt;/a&gt; na cadeia de caracteres:
<screen>O &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt; possui um excelente &lt;a href=&quot;http://php.net/manual&quot;&gt;manual&lt;/a&gt;.</screen>
     Os resultados são idênticos, mas a função <function>preg_match</function>
     retorna uma matriz onde o elemento [0] contém o texto que corresponde a
     todo o padrão, o elemento [1] contém o texto que corresponde à primeira
     subexpressão entre parênteses capturada, e assim por diante, enquanto a
     função <function>substring</function> retorna o texto que corresponde à
     primeira subexpressão entre parênteses apenas.
     <footnote>
      <para>
       Exemplo escrito pelo tradutor, baseado no exemplo do livro
       PHP 5 Programação Poderosa de Andi Gutmans, Stig Saether Bakken e
       Derik Rethans - Editora Alta Books - 2005 - pág. 187
      </para>
     </footnote>
    </para>
     <itemizedlist mark='bullet'>
      <listitem>
       <para>
        <productname>PostgreSQL &version;</productname>
       </para>
<screen>
<prompt>=&gt; </prompt><userinput>\set texto '\'O &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt; possui um excelente '</userinput>
<prompt>=&gt; </prompt><userinput>\set texto :texto '&lt;a href=&quot;http://php.net/manual&quot;&gt;manual&lt;/a&gt;.\''</userinput>

<prompt>=&gt; </prompt><userinput>SELECT substring(:texto,'&lt;a.*&gt;(.*)&lt;/a&gt;');</userinput>

<computeroutput>
 substring
-----------
 manual
(1 linha)
</computeroutput>

<prompt>=&gt; </prompt><userinput>SELECT substring(:texto,'&lt;a.*?&gt;(.*?)&lt;/a&gt;');</userinput>

<computeroutput>
 substring
-----------
 PHP
(1 linha)
</computeroutput>
</screen>
      </listitem>
      <listitem>
       <para>
        <productname>PHP</productname>
       </para>
<programlisting>
&lt;?php
    $texto = 'O &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt; possui um excelente '
           . '&lt;a href=&quot;http://php.net/manual&quot;&gt;manual&lt;/a&gt;.';
    preg_match('|&lt;a.*&gt;(.*)&lt;/a&gt;|', $texto, $corresp);
    print_r($corresp);
    preg_match('|&lt;a.*?&gt;(.*?)&lt;/a&gt;|', $texto, $corresp);
    print_r($corresp);
?&gt;
</programlisting>
<screen>
<computeroutput>
Array
(
    [0] =&gt; &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt; possui um excelente &lt;a href=&quot;http://php.net/manual&quot;&gt;manual&lt;/a&gt;
    [1] =&gt; manual
)
Array
(
    [0] =&gt; &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt;
    [1] =&gt; PHP
)</computeroutput>
</screen>
      </listitem>
     </itemizedlist>
   </example>

   <example id="func-match-example-pcre">
    <title>Comparação entre o PostgreSQL e o PCRE</title>
    <para>
     Neste exemplo é feita a comparação entre a função
     <function>substring</function> do <productname>PostgreSQL</productname> e
     o programa <application>pcredemo</application> do
     <ulink url="http://www.pcre.org/">PCRE - Perl Compatible Regular
     Expressions</ulink>, utilizando uma expressão regular voraz e outra não
     voraz, para capturar o texto entre as marcas &lt;a...&gt; e &lt;/a&gt;
     na cadeia de caracteres:
<screen>O &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt; possui um excelente &lt;a href=&quot;http://php.net/manual&quot;&gt;manual&lt;/a&gt;.</screen>
     Os resultados são idênticos, mas o programa
     <application>pcredemo</application> com a opção <option>-g</option> retorna
     todas as correspondências encontradas, enquanto a função
     <function>substring</function> retorna o texto que corresponde à primeira
     subexpressão entre parênteses apenas. Sem a opção <option>-g</option>,
     o resultado do <application>pcredemo</application> é idêntico ao do
     <ulink url="http://br.php.net/manual/pt_BR/ref.pcre.php">PHP</ulink>, que
     utiliza a biblioteca <acronym>PCRE</acronym> como suporte às expressões
     regulares.
     <footnote>
      <para>
       Exemplo escrito pelo tradutor, utilizando os parâmetros do exemplo
       anterior.
      </para>
     </footnote>
    </para>
     <itemizedlist mark='bullet'>
      <listitem>
       <para>
        <productname>PostgreSQL &version;</productname>
       </para>
<screen>
<prompt>=&gt; </prompt><userinput>\set texto '\'O &lt;a href=&quot;http://php.net/&quot;&gt;PHP&lt;/a&gt; possui um excelente '</userinput>
<prompt>=&gt; </prompt><userinput>\set texto :texto '&lt;a href=&quot;http://php.net/manual&quot;&gt;manual&lt;/a&gt;.\''</userinput>

<prompt>=&gt; </prompt><userinput>SELECT substring(:texto,'&lt;a.*&gt;(.*)&lt;/a&gt;');</userinput>

<computeroutput>
 substring
-----------
 manual
(1 linha)
</computeroutput>

<prompt>=&gt; </prompt><userinput>SELECT substring(:texto,'&lt;a.*?&gt;(.*?)&lt;/a&gt;');</userinput>

<computeroutput>
 substring
-----------
 PHP
(1 linha)
</computeroutput>
</screen>
      </listitem>
      <listitem>
       <para>
        <productname>PCRE</productname>
       </para>
<screen>
<prompt>$ </prompt><userinput>./pcredemo -g \</userinput>
<prompt>&gt; </prompt><userinput>'&lt;a.*&gt;(.*)&lt;/a&gt;' \</userinput>
<prompt>&gt; </prompt><userinput>'O &lt;a href="http://php.net/"&gt;PHP&lt;/a&gt; possui um excelente &lt;a href="http://php.net/manual"&gt;manual&lt;/a&gt;.'</userinput>

<computeroutput>
Correspondência bem sucedida no deslocamento 2
 0: &lt;a href="http://php.net/"&gt;PHP&lt;/a&gt; possui um excelente &lt;a href="http://php.net/manual"&gt;manual&lt;/a&gt;
 1: manual
</computeroutput>

<prompt>$ </prompt><userinput>./pcredemo -g \</userinput>
<prompt>&gt; </prompt><userinput>'&lt;a.*?&gt;(.*?)&lt;/a&gt;' \</userinput>
<prompt>&gt; </prompt><userinput>'O &lt;a href="http://php.net/"&gt;PHP&lt;/a&gt; possui um excelente &lt;a href="http://php.net/manual"&gt;manual&lt;/a&gt;.'</userinput>

<computeroutput>
Correspondência bem sucedida no deslocamento 2
 0: &lt;a href="http://php.net/"&gt;PHP&lt;/a&gt;
 1: PHP

Correspondência bem sucedida novamente no deslocamento 56
 0: &lt;a href="http://php.net/manual"&gt;manual&lt;/a&gt;
 1: manual
</computeroutput>
</screen>
      </listitem>
     </itemizedlist>
   </example>

  </sect2>

 </sect1>

  <sect1 id="functions-formatting">
   <title>Funções para formatar tipo de dado</title>

   <indexterm zone="functions-formatting">
    <primary>formatação</primary>
   </indexterm>

   <indexterm zone="functions-formatting">
    <primary>to_char</primary>
   </indexterm>

   <para>
    As funções de formatação do <productname>PostgreSQL</productname>
    fornecem um poderoso conjunto de ferramentas para converter vários tipos
    de dado (<literal>date/time, integer, floating point, numeric</literal>) em
    cadeias de caracteres formatadas, e para converter cadeias de caracteres
    formatadas em tipos de dado específicos.
    A <xref linkend="functions-formatting-table"> mostra estas funções, que
    seguem uma convenção de chamada comum: o primeiro argumento é o valor a ser
    formatado, e o segundo argumento é o modelo que define o formato da entrada
    ou da saída.
   </para>

    <table id="functions-formatting-table">
     <title>Funções de formatação</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>to_char</function>(<type>timestamp</type>, <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>converte carimbo do tempo (<literal>time stamp</literal>) em cadeia de caracteres</entry>
        <entry><literal>to_char(current_timestamp, 'HH12:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>interval</type>, <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>converte intervalo em cadeia de caracteres</entry>
        <entry><literal>to_char(interval '15h&nbsp;2m&nbsp;12s', 'HH24:MI:SS')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>int</type>, <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>converte inteiro em cadeia de caracteres</entry>
        <entry><literal>to_char(125, '999')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>double precision</type>,
        <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>converte real e precisão dupla em cadeia de caracteres</entry>
        <entry><literal>to_char(125.8::real, '999D9')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_char</function>(<type>numeric</type>, <type>text</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>converte numérico em cadeia de caracteres</entry>
        <entry><literal>to_char(-125.8, '999D99S')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_date</function>(<type>text</type>, <type>text</type>)</literal></entry>
        <entry><type>date</type></entry>
        <entry>converte cadeia de caracteres em data</entry>
        <entry><literal>to_date('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_timestamp</function>(<type>text</type>, <type>text</type>)</literal></entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>converte cadeia de caracteres em carimbo do tempo</entry>
        <entry><literal>to_timestamp('05&nbsp;Dec&nbsp;2000', 'DD&nbsp;Mon&nbsp;YYYY')</literal></entry>
       </row>
       <row>
        <entry><literal><function>to_number</function>(<type>text</type>, <type>text</type>)</literal></entry>
        <entry><type>numeric</type></entry>
        <entry>converte cadeia de caracteres em numérico</entry>
        <entry><literal>to_number('12,454.8-', '99G999D9S')</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Advertência: <literal><function>to_char</function>(<type>interval</type>,
    <type>text</type>)</literal> está obsoleta, não devendo ser utilizada nos
    novos aplicativos. Será removida na próxima versão.
   </para>

   <para>
    Em uma cadeia de caracteres modelo de saída (para <function>to_char</function>),
    existem certos padrões que são reconhecidos e substituídos pelos dados
    devidamente formatados a partir do valor a ser formatado.
    Qualquer texto que não seja um modelo padrão é simplesmente copiado sem
    alteração.
    Da mesma forma, em uma cadeia de caracteres modelo de entrada (para qualquer
    coisa menos <function>to_char</function>), os modelos padrão identificam as
    partes da cadeia de caracteres da entrada de dados a serem procuradas, e os
    valores a serem encontrados nestas partes.
   </para>

  <para>
   A <xref linkend="functions-formatting-datetime-table"> mostra os
   modelos padrão disponíveis para formatar valores de data e de hora.
  </para>

    <table id="functions-formatting-datetime-table">
     <title>Modelos padrão para formatação de data e hora</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Modelo</entry>
        <entry>Descrição</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>HH</literal></entry>
        <entry>hora do dia (01-12)</entry>
       </row>
       <row>
        <entry><literal>HH12</literal></entry>
        <entry>hora do dia (01-12)</entry>
       </row>
       <row>
        <entry><literal>HH24</literal></entry>
        <entry>hora do dia (00-23)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <entry>minuto (00-59)</entry>
       </row>
       <row>
        <entry><literal>SS</literal></entry>
        <entry>segundo (00-59)</entry>
       </row>
       <row>
        <entry><literal>MS</literal></entry>
        <entry>milissegundo (000-999)</entry>
       </row>
       <row>
        <entry><literal>US</literal></entry>
        <entry>microssegundo (000000-999999)</entry>
       </row>
       <row>
        <entry><literal>SSSS</literal></entry>
        <entry>segundos após a meia-noite (0-86399)</entry>
       </row>
       <row>
        <entry><literal>AM</literal> ou <literal>A.M.</literal> ou
        <literal>PM</literal> ou <literal>P.M.</literal></entry>
        <entry>indicador de meridiano (maiúsculas)</entry>
       </row>
       <row>
        <entry><literal>am</literal> ou <literal>a.m.</literal> ou
        <literal>pm</literal> ou <literal>p.m.</literal></entry>
        <entry>indicador de meridiano (minúsculas)</entry>
       </row>
       <row>
        <entry><literal>Y,YYY</literal></entry>
        <entry>ano (4 e mais dígitos) com vírgula</entry>
       </row>
       <row>
        <entry><literal>YYYY</literal></entry>
        <entry>ano (4 e mais dígitos)</entry>
       </row>
       <row>
        <entry><literal>YYY</literal></entry>
        <entry>últimos 3 dígitos do ano</entry>
       </row>
       <row>
        <entry><literal>YY</literal></entry>
        <entry>últimos 2 dígitos do ano</entry>
       </row>
       <row>
        <entry><literal>Y</literal></entry>
        <entry>último dígito do ano</entry>
       </row>
       <row>
        <entry><literal>IYYY</literal></entry>
        <entry>ano ISO (4 ou mais dígitos)</entry>
       </row>
       <row>
        <entry><literal>IYY</literal></entry>
        <entry>últimos 3 dígitos do ano ISO</entry>
       </row>
       <row>
        <entry><literal>IY</literal></entry>
        <entry>últimos 2 dígitos do ano ISO</entry>
       </row>
       <row>
        <entry><literal>I</literal></entry>
        <entry>último dígito do ano ISO</entry>
       </row>
       <row>
        <entry><literal>BC</literal> ou <literal>B.C.</literal> ou
        <literal>AD</literal> ou <literal>A.D.</literal></entry>
        <entry>indicador de era (maiúscula)</entry>
       </row>
       <row>
        <entry><literal>bc</literal> ou <literal>b.c.</literal> ou
        <literal>ad</literal> ou <literal>a.d.</literal></entry>
        <entry>indicador de era (minúscula)</entry>
       </row>
       <row>
        <entry><literal>MONTH</literal></entry>
        <entry>nome completo do mês em maiúsculas (9 caracteres completado com
        espaços)</entry>
       </row>
       <row>
        <entry><literal>Month</literal></entry>
        <entry>nome completo do mês em maiúsculas e minúsculas (9 caracteres
        completado com espaços)</entry>
       </row>
       <row>
        <entry><literal>month</literal></entry>
        <entry>nome completo do mês em minúsculas (9 caracteres completado com
        espaços)</entry>
       </row>
       <row>
        <entry><literal>MON</literal></entry>
        <entry>nome abreviado do mês em maiúsculas (3 caracteres)</entry>
       </row>
       <row>
        <entry><literal>Mon</literal></entry>
        <entry>nome abreviado do mês em maiúsculas e minúsculas (3 caracteres)</entry>
       </row>
       <row>
        <entry><literal>mon</literal></entry>
        <entry>nome abreviado do mês em minúsculas (3 caracteres)</entry>
       </row>
       <row>
        <entry><literal>MM</literal></entry>
        <entry>número do mês (01-12)</entry>
       </row>
       <row>
        <entry><literal>DAY</literal></entry>
        <entry>nome completo do dia em maiúsculas (9 caracteres completado com
        espaços)</entry>
       </row>
       <row>
        <entry><literal>Day</literal></entry>
        <entry>nome completo do dia em maiúsculas e minúsculas (9 caracteres
        completado com espaços)</entry>
       </row>
       <row>
        <entry><literal>day</literal></entry>
        <entry>nome completo do dia em minúsculas (9 caracteres completado com
        espaços)</entry>
       </row>
       <row>
        <entry><literal>DY</literal></entry>
        <entry>nome abreviado do dia em maiúsculas (3 caracteres)</entry>
       </row>
       <row>
        <entry><literal>Dy</literal></entry>
        <entry>nome abreviado do dia em maiúsculas e minúsculas (3 caracteres)</entry>
       </row>
       <row>
        <entry><literal>dy</literal></entry>
        <entry>nome abreviado do dia em minúsculas (3 caracteres)</entry>
       </row>
       <row>
        <entry><literal>DDD</literal></entry>
        <entry>dia do ano (001-366)</entry>
       </row>
       <row>
        <entry><literal>DD</literal></entry>
        <entry>dia do mês (01-31)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <entry>dia da semana (1-7; Domingo é 1)</entry>
       </row>
       <row>
        <entry><literal>W</literal></entry>
        <entry>semana do mês (1-5) onde a primeira semana começa no primeiro
        dia do mês</entry>
       </row>
       <row>
        <entry><literal>WW</literal></entry>
        <entry>número da semana do ano (1-53) onde a primeira semana começa no
        primeiro dia do ano</entry>
       </row>
       <row>
        <entry><literal>IW</literal></entry>
        <entry>número da semana do ano ISO (A primeira quinta-feira do novo ano
        está na semana 1)</entry>
       </row>
       <row>
        <entry><literal>CC</literal></entry>
        <entry>século (2 dígitos)</entry>
       </row>
       <row>
        <entry><literal>J</literal></entry>
        <entry>Dia Juliano (dias desde 1 de janeiro de 4712 AC)</entry>
       </row>
       <row>
        <entry><literal>Q</literal></entry>
        <entry>trimestre</entry>
       </row>
       <row>
        <entry><literal>RM</literal></entry>
        <entry>mês em algarismos romanos (I-XII; I=Janeiro) - maiúsculas</entry>
       </row>
       <row>
        <entry><literal>rm</literal></entry>
        <entry>mês em algarismos romanos (I-XII; I=Janeiro) - minúsculas</entry>
       </row>
       <row>
        <entry><literal>TZ</literal></entry>
        <entry>nome da zona horária - maiúsculas</entry>
       </row>
       <row>
        <entry><literal>tz</literal></entry>
        <entry>nome da zona horária - minúsculas</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Certos modificadores podem ser aplicados aos modelos padrão
    para alterar seu comportamento. Por exemplo, <literal>FMMonth</literal>
    é o modelo <quote><literal>Month</literal></quote> com o modificador
    <quote><literal>FM</literal></quote>. A
    <xref linkend="functions-formatting-datetimemod-table"> mostra os
    modificadores de modelo para formatação de data e hora.
   </para>

    <table id="functions-formatting-datetimemod-table">
     <title>Modificadores de modelo padrão para formatação de data e hora</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Modificador</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>prefixo <literal>FM</literal></entry>
        <entry>modo de preenchimento (suprime completar com brancos e zeros)</entry>
        <entry><literal>FMMonth</literal></entry>
       </row>
       <row>
        <entry>sufixo <literal>TH</literal></entry>
        <entry>sufixo de número ordinal maiúsculo</entry>
        <entry><literal>DDTH</literal></entry>
       </row>
       <row>
        <entry>sufixo <literal>th</literal></entry>
        <entry>sufixo de número ordinal minúsculo</entry>
        <entry><literal>DDth</literal></entry>
       </row>
       <row>
        <entry>prefixo <literal>FX</literal></entry>
        <entry>opção global de formato fixo (veja nota de utilização)</entry>
        <entry><literal>FX&nbsp;Month&nbsp;DD&nbsp;Day</literal></entry>
       </row>
       <row>
        <entry>sufixo <literal>SP</literal></entry>
        <entry>modo de falar (<literal>spell mode</literal>) (ainda não implementado)</entry>
        <entry><literal>DDSP</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Notas sobre a utilização da formatação de data e hora:

    <itemizedlist>
     <listitem>
      <para>
       O <literal>FM</literal> suprime zeros à esquerda e espaços à direita,
       que de outra forma seriam adicionados para fazer a
       saída do modelo ter comprimento fixo.
      </para>
     </listitem>

     <listitem>
      <para>
       As funções <function>to_timestamp</function> e <function>to_date</function>
       saltam espaços em branco múltiplos na cadeia de caracteres de entrada
       quando a opção <literal>FX</literal> não é utilizada.
       O <literal>FX</literal> deve ser especificado como o primeiro item do
       modelo; por exemplo,
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','YYYY MON')</literal>
       está correto, mas
       <literal>to_timestamp('2000&nbsp;&nbsp;&nbsp;&nbsp;JUN','FXYYYY MON')</literal>
       retorna erro, porque <function>to_timestamp</function> espera um único
       espaço apenas.
      </para>
     </listitem>

     <listitem>
      <para>
       É permitida a presença de texto comum nos modelos para
       <function>to_char</function>, sendo mostrados literalmente na saída.
       Uma parte da cadeia de caracteres pode ser colocada
       entre aspas, para obrigar sua interpretação como um texto literal
       mesmo contendo palavras chave do modelo. Por exemplo, em
       <literal>'"Hello Year "YYYY'</literal>, o <literal>YYYY</literal>
       será substituído pelo ano do fornecido, mas o único <literal>Y</literal>
       em <literal>Year</literal> não será substituído.
      </para>
     </listitem>

     <listitem>
      <para>
       Se for desejada a presença de aspas na saída, as mesmas devem ser
       precedidas por contrabarra. Por exemplo <literal>'\\"YYYY
       Month\\"'</literal>. <!-- "" font-lock sanity :-) -->
       (Duas contrabarras são necessárias, porque a contrabarra
       possui significado especial em uma constante cadeia de caracteres).
      </para>
     </listitem>

     <listitem>
      <para>
       A conversão <literal>YYYY</literal> de cadeia de caracteres para
       <type>timestamp</type> ou para <type>date</type> tem restrição quando
       são utilizados anos com mais de 4 dígitos.
       Deve ser utilizado um modelo, ou algum caractere que não seja um dígito,
       após <literal>YYYY</literal>, senão o ano será sempre interpretado como
       tendo 4 dígitos.
       Por exemplo, (com o ano 20000):
       <literal>to_date('200001121', 'YYYYMMDD')</literal> é
       interpretado como um ano de 4 dígitos; em vez disso, deve ser utilizado
       um separador que não seja um dígito após o ano, como
       <literal>to_date('20000-1121', 'YYYY-MMDD')</literal> ou
       <literal>to_date('20000Nov21', 'YYYYMonDD')</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       Os valores de milissegundos <literal>MS</literal> e microssegundos
       <literal>US</literal> na conversão de uma cadeia de caracteres para um
       carimbo do tempo (<type>timestamp</type>), são interpretados como a sendo
       parte dos segundos após o ponto decimal.
       Por exemplo, <literal>to_timestamp('12:3', 'SS:MS')</literal> não são 3
       milissegundos, mas 300, porque a conversão interpreta como sendo 12 + 0.3
       segundos.
       Isto significa que, para o formato <literal>SS:MS</literal>, os valores
       de entrada <literal>12:3</literal>, <literal>12:30</literal> e
       <literal>12:300</literal> especificam o mesmo número de milissegundos.
       Para especificar três milissegundos deve ser utilizado
       <literal>12:003</literal>, que na conversão é interpretado como
       12 + 0.003 = 12.003 segundos.
      </para>

      <para>
       A seguir está mostrado um exemplo mais complexo:
       <literal>to_timestamp('15:12:02.020.001230','HH:MI:SS.MS.US')</literal>
       é interpretado como 15 horas, 12 minutos e 2 segundos + 20 milissegundos
       + 1230 microssegundos = 2.021230 segundos.
      </para>
     </listitem>

     <listitem>
      <para>A numeração do dia da semana de <function>to_char</function>
       (veja o modelo padrão de formatação 'D') é diferente do dia da semana da
       função <function>extract</function>.
      </para>
     </listitem>
    </itemizedlist>
   </para>

  <para>
   A <xref linkend="functions-formatting-numeric-table"> mostra os
   modelos padrão disponíveis para formatar valores numéricos.
  </para>

    <table id="functions-formatting-numeric-table">
     <title>Modelos padrão para formatação de números</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Modelo</entry>
        <entry>Descrição</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>9</literal></entry>
        <entry>valor com o número especificado de dígitos</entry>
       </row>
       <row>
        <entry><literal>0</literal></entry>
        <entry>valor com zeros à esquerda</entry>
       </row>
       <row>
        <entry><literal>.</literal> (ponto)</entry>
        <entry>ponto decimal</entry>
       </row>
       <row>
        <entry><literal>,</literal> (vírgula)</entry>
        <entry>separador de grupo (milhares)</entry>
       </row>
       <row>
        <entry><literal>PR</literal></entry>
        <entry>valor negativo entre &lt; e &gt;</entry>
       </row>
       <row>
        <entry><literal>S</literal></entry>
        <entry>sinal preso ao número (utiliza o idioma)</entry>
       </row>
       <row>
        <entry><literal>L</literal></entry>
        <entry>símbolo da moeda (utiliza o idioma)</entry>
       </row>
       <row>
        <entry><literal>D</literal></entry>
        <entry>ponto decimal (utiliza o idioma)</entry>
       </row>
       <row>
        <entry><literal>G</literal></entry>
        <entry>separador de grupo (utiliza o idioma)</entry>
       </row>
       <row>
        <entry><literal>MI</literal></entry>
        <entry>sinal de menos na posição especificada (se número &lt; 0)</entry>
       </row>
       <row>
        <entry><literal>PL</literal></entry>
        <entry>sinal de mais na posição especificada (se número &gt; 0)</entry>
       </row>
       <row>
        <entry><literal>SG</literal></entry>
        <entry>sinal de mais/menos na posição especificada</entry>
       </row>
       <row>
        <entry><literal>RN</literal>
         <footnote>
          <para>
           RN &mdash; roman numerals.
          </para>
         </footnote>
        </entry>
        <entry>algarismos romanos (entrada entre 1 e 3999)</entry>
       </row>
       <row>
        <entry><literal>TH</literal> ou <literal>th</literal></entry>
        <entry>sufixo de número ordinal</entry>
       </row>
       <row>
        <entry><literal>V</literal></entry>
        <entry>desloca o número especificado de dígitos (veja as notas sobre utilização)</entry>
       </row>
       <row>
        <entry><literal>EEEE</literal></entry>
        <entry>notação científica (ainda não implementada)</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Notas sobre a utilização da formatação numérica:

    <itemizedlist>
     <listitem>
      <para>
       O sinal formatado utilizando <literal>SG</literal>, <literal>PL</literal>
       ou <literal>MI</literal> não está ancorado ao número; por exemplo,
       <literal>to_char(-12, 'S9999')</literal> produz
       <literal>'&nbsp;&nbsp;-12'</literal>,
       mas <literal>to_char(-12, 'MI9999')</literal> produz
       <literal>'-&nbsp;&nbsp;12'</literal>.
       A implementação do Oracle não permite utilizar o <literal>MI</literal>
       antes do <literal>9</literal>, requerendo que o <literal>9</literal>
       preceda o <literal>MI</literal>.
      </para>
     </listitem>

     <listitem>
      <para>
       O <literal>9</literal> resulta em um valor com o mesmo número de
       dígitos que o número de <literal>9</literal>s. Se não houver um dígito
       para colocar, é colocado espaço.
      </para>
     </listitem>

     <listitem>
      <para>
       O <literal>TH</literal> não converte valores menores que zero
       e não converte números fracionários.
      </para>
     </listitem>

     <listitem>
      <para>
       O <literal>PL</literal>, o <literal>SG</literal> e o
       <literal>TH</literal> são extensões do
       <productname>PostgreSQL</productname>.
      </para>
     </listitem>

     <listitem>
      <para>
       O <literal>V</literal> multiplica efetivamente os valores da entrada por
       <literal>10^<replaceable>n</replaceable></literal>, onde
       <replaceable>n</replaceable> é o número de dígitos após o
       <literal>V</literal>.
       A função <function>to_char</function> não permite o uso de
       <literal>V</literal> junto com o ponto decimal
       (Por exemplo, <literal>99.9V99</literal> não é permitido).
      </para>
     </listitem>
    </itemizedlist>
   </para>

  <para>
   A <xref linkend="functions-formatting-examples-table"> mostra alguns
   exemplos de uso da função <function>to_char</function>.
  </para>

    <table id="functions-formatting-examples-table">
     <title>Exemplos de utilização da função to_char</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Expressão</entry>
        <entry>PostgreSQL &version;
         <footnote>
          <para>
           idioma &mdash; set lc_numeric to 'pt_BR';
           set lc_monetary to 'pt_BR'; (N. do T.)
          </para>
         </footnote>
        </entry>
        <entry>Oracle 10g (N. do T.)
         <footnote>
          <para>
           idioma &mdash; ALTER SESSION SET NLS_TERRITORY="BRAZIL"; (N. do T.)
          </para>
         </footnote>
        </entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal>to_char(current_timestamp, 'Day,&nbsp;DD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Friday&nbsp;&nbsp;&nbsp;,&nbsp;04&nbsp;&nbsp;02:22:24'</literal></entry>
        <entry><literal>'Friday&nbsp;&nbsp;&nbsp;,&nbsp;04&nbsp;&nbsp;02:22:24'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(current_timestamp, 'FMDay,&nbsp;FMDD&nbsp;&nbsp;HH12:MI:SS')</literal></entry>
        <entry><literal>'Friday,&nbsp;4&nbsp;&nbsp;02:22:24'</literal></entry>
        <entry><literal>'Friday,&nbsp;04&nbsp;&nbsp;02:22:24'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, '99.99')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
        <entry><literal>'&nbsp;&nbsp;-.10'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-0.1, 'FM9.99')</literal></entry>
        <entry><literal>'-.1'</literal></entry>
        <entry><literal>'-.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(0.1, '0.9')</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
        <entry><literal>'&nbsp;0.1'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '9990999.9')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;0012.0'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, 'FM9990999.9')</literal></entry>
        <entry><literal>'0012.'</literal></entry>
        <entry><literal>'0012.'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999')</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
        <entry><literal>'&nbsp;485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
        <entry><literal>'-485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '9&nbsp;9&nbsp;9')</literal></entry>
        <entry><literal>'&nbsp;4&nbsp;8&nbsp;5'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9,999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(1485, '9G999')</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
        <entry><literal>'&nbsp;1,485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999.999')</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
        <entry><literal>'&nbsp;148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.999')</literal></entry>
        <entry><literal>'148.5'</literal></entry>
        <entry><literal>'148.5'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, 'FM999.990')</literal></entry>
        <entry><literal>'148.500'</literal></entry>
        <entry><literal>'148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(148.5, '999D999') -- com idioma</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
        <entry><literal>'&nbsp;148,500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(3148.5, '9G999D999')</literal></entry>
        <entry><literal>'&nbsp;3,148.500'</literal></entry>
        <entry><literal>'&nbsp;3,148.500'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999S')</literal></entry>
        <entry><literal>'485-'</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999MI')</literal></entry>
        <entry><literal>'485-'</literal></entry>
        <entry><literal>'485-'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '999MI')</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
        <entry><literal>'485&nbsp;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FM999MI')</literal></entry>
        <entry><literal>'485'</literal></entry>
        <entry><literal>'485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'PL999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'SG999')</literal></entry>
        <entry><literal>'+485'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, 'SG999')</literal></entry>
        <entry><literal>'-485'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '9SG99')</literal></entry>
        <entry><literal>'4-85'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(-485, '999PR')</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
        <entry><literal>'&lt;485&gt;'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'L999') -- com idioma</literal></entry>
        <entry><literal>'R$&nbsp;485'</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;R$485'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'RN')</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
        <entry><literal>'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, 'FMRN')</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
        <entry><literal>'CDLXXXV'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(5.2, 'FMRN')</literal></entry>
        <entry><literal>'V'</literal></entry>
        <entry><literal>'V'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(482, '999th')</literal></entry>
        <entry><literal>'&nbsp;482nd'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485, '"Good&nbsp;number:"999')</literal></entry>
        <entry><literal>'Good&nbsp;number:&nbsp;485'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(485.8, '"Pre:"999"&nbsp;Post:"&nbsp;.999')</literal></entry>
        <entry><literal>'Pre:&nbsp;485&nbsp;Post:&nbsp;.800'</literal></entry>
        <entry><literal>formato inválido</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
        <entry><literal>'&nbsp;12000'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.4, '99V999')</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
        <entry><literal>'&nbsp;12400'</literal></entry>
       </row>
       <row>
        <entry><literal>to_char(12.45, '99V9')</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
        <entry><literal>'&nbsp;125'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect1>


  <sect1 id="functions-datetime">
   <title>Funções e operadores para data e hora</title>

  <para>
   A <xref linkend="functions-datetime-table"> mostra as funções disponíveis
   para processamento de valor de data e de hora. Os detalhes são mostrados
   nas próximas subseções.
   A <xref linkend="operators-datetime-table"> mostra o comportamento dos
   operadores aritméticos básicos (<literal>+</literal>,
   <literal>*</literal>, etc.). Para as funções de formatação consulte a
   <xref linkend="functions-formatting">. É necessário estar familiarizado com
   os tipos de dado para data e hora presentes na
   <xref linkend="datatype-datetime">.
  </para>

  <para>
   Todas as funções e operadores descritos abaixo, que recebem os tipos
   <type>time</type> ou <type>timestamp</type> como entrada, estão presentes em
   duas formas: uma que recebe <type>time with time zone</type> ou
   <type>timestamp with time zone</type>, e outra que recebe
   <type>time without time zone</type> ou <type>timestamp without time zone</type>.
   Para abreviar, estas formas não são mostradas em separado.
   Também, os operadores <literal>+</> e <literal>*</> ocorrem em pares
   comutativos (por exemplo, pares data + inteiro e inteiro + data);
   é mostrado apenas um destes pares.
  </para>

    <table id="operators-datetime-table">
     <title>Operadores para data e hora</title>

     <tgroup cols="3">
      <thead>
       <row>
        <entry>Operador</entry>
        <entry>Exemplo</entry>
        <entry>Resultado</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + integer '7'</literal></entry>
        <entry><literal>date '2001-10-05'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-28 01:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>date '2001-09-28' + time '03:00'</literal></entry>
        <entry><literal>timestamp '2001-09-28 03:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>interval '1 day' + interval '1 hour'</literal></entry>
        <entry><literal>interval '1 day 01:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>timestamp '2001-09-28 01:00' + interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-29 00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>+</literal> </entry>
        <entry><literal>time '01:00' + interval '3 hours'</literal></entry>
        <entry><literal>time '04:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>- interval '23 hours'</literal></entry>
        <entry><literal>interval '-23:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - date '2001-09-28'</literal></entry>
        <entry><literal>integer '3'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-10-01' - integer '7'</literal></entry>
        <entry><literal>date '2001-09-24'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>date '2001-09-28' - interval '1 hour'</literal></entry>
        <entry><literal>timestamp '2001-09-27 23:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - time '03:00'</literal></entry>
        <entry><literal>interval '02:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>time '05:00' - interval '2 hours'</literal></entry>
        <entry><literal>time '03:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-28 23:00' - interval '23 hours'</literal></entry>
        <entry><literal>timestamp '2001-09-28 00:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>interval '1 day' - interval '1 hour'</literal></entry>
        <entry><literal>interval '23:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>-</literal> </entry>
        <entry><literal>timestamp '2001-09-29 03:00' - timestamp '2001-09-27 12:00'</literal></entry>
        <entry><literal>interval '1 day 15:00'</literal></entry>
       </row>

       <row>
        <entry> <literal>*</literal> </entry>
        <entry><literal>interval '1 hour' * double precision '3.5'</literal></entry>
        <entry><literal>interval '03:30'</literal></entry>
       </row>

       <row>
        <entry> <literal>/</literal> </entry>
        <entry><literal>interval '1 hour' / double precision '1.5'</literal></entry>
        <entry><literal>interval '00:40'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

    <table id="functions-datetime-table">
     <title>Funções para data e hora</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
        <entry>Resultado</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><literal><function>age</function>(<type>timestamp</type>, <type>timestamp</type>)</literal></entry>
        <entry><type>interval</type></entry>
        <entry>Subtrai os argumentos, produzindo um resultado
        <quote>simbólico</> que utiliza anos e meses</entry>
        <entry><literal>age(timestamp '2001-04-10', timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 9 mons 27 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>age</function>(<type>timestamp</type>)</literal></entry>
        <entry><type>interval</type></entry>
        <entry>Subtrai de <function>current_date</function></entry>
        <entry><literal>age(timestamp '1957-06-13')</literal></entry>
        <entry><literal>43 years 8 mons 3 days</literal></entry>
       </row>

       <row>
        <entry><literal><function>current_date</function></literal></entry>
        <entry><type>date</type></entry>
        <entry>Data de hoje; consulte a <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry><literal><function>current_time</function></literal></entry>
        <entry><type>time with time zone</type></entry>
        <entry>Hora do dia; consulte a <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry><literal><function>current_timestamp</function></literal></entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Data e hora; consulte a <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry><literal><function>date_part</function>(<type>text</type>, <type>timestamp</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>Retorna subcampo (equivale ao <function>extract</function>);
         consulte a <xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>date_part('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_part</function>(<type>text</type>, <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>Retorna subcampo (equivale ao <function>extract</function>);
         consulte a <xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>date_part('month', interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry><literal><function>date_trunc</function>(<type>text</type>, <type>timestamp</type>)</literal></entry>
        <entry><type>timestamp</type></entry>
        <entry>Trunca na precisão especificada; consulte a
         <xref linkend="functions-datetime-trunc">
        </entry>
        <entry><literal>date_trunc('hour', timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>2001-02-16 20:00:00</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>campo</parameter> from
         <type>timestamp</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>Retorna subcampo; consulte a <xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>extract(hour from timestamp '2001-02-16 20:38:40')</literal></entry>
        <entry><literal>20</literal></entry>
       </row>

       <row>
        <entry><literal><function>extract</function>(<parameter>campo</parameter> from
         <type>interval</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>Retorna subcampo; consulte a <xref linkend="functions-datetime-extract">
        </entry>
        <entry><literal>extract(month from interval '2 years 3 months')</literal></entry>
        <entry><literal>3</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite</function>(<type>timestamp</type>)</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>Testa carimbo do tempo finito (diferente de infinito)</entry>
        <entry><literal>isfinite(timestamp '2001-02-16 21:28:30')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>isfinite</function>(<type>interval</type>)</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>Testa intervalo finito</entry>
        <entry><literal>isfinite(interval '4 hours')</literal></entry>
        <entry><literal>true</literal></entry>
       </row>

       <row>
        <entry><literal><function>localtime</function></literal></entry>
        <entry><type>time</type></entry>
        <entry>Hora do dia; consulte a <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry><literal><function>localtimestamp</function></literal></entry>
        <entry><type>timestamp</type></entry>
        <entry>Data e hora; consulte a <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry><literal><function>now</function>()</literal></entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Data e hora corrente (equivale ao
         <function>current_timestamp</function>);
         consulte a <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

       <row>
        <entry><literal><function>timeofday()</function></literal></entry>
        <entry><type>text</type></entry>
        <entry>Data e hora corrente; consulte a
         <xref linkend="functions-datetime-current">
        </entry>
        <entry></entry>
        <entry></entry>
       </row>

      </tbody>
     </tgroup>
    </table>

   <para>
    Além destas funções, é suportado o operador <literal>OVERLAPS</literal>
    do SQL:
<synopsis>
( <replaceable>inicio1</replaceable>, <replaceable>fim1</replaceable> ) OVERLAPS ( <replaceable>inicio2</replaceable>, <replaceable>fim2</replaceable> )
( <replaceable>inicio1</replaceable>, <replaceable>duração1</replaceable> ) OVERLAPS ( <replaceable>inicio2</replaceable>, <replaceable>duração2</replaceable> )
</synopsis>
    O resultado desta expressão é verdade quando dois períodos de tempo
    (definidos por seus pontos limites) se sobrepõem, e falso quando não se
    sobrepõem. Os pontos limites podem ser especificados como pares de datas,
    horas, ou carimbo do tempo; ou como data, hora ou carimbo do tempo seguido
    por um intervalo.
   </para>

<screen>
<userinput>
SELECT (DATE '2001-02-16', DATE '2001-12-21') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>verdade</computeroutput>
<userinput>
SELECT (DATE '2001-02-16', INTERVAL '100 days') OVERLAPS
       (DATE '2001-10-30', DATE '2002-10-30');
</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>falso</computeroutput>
</screen>

  <sect2 id="functions-datetime-extract">
   <title>Funções EXTRACT e date_part</title>

<synopsis>
EXTRACT (<replaceable>campo</replaceable> FROM <replaceable>fonte</replaceable>)
</synopsis>

   <para>
    A função <function>extract</function> retorna subcampos dos valores
    de data e hora, como o ano ou a hora.
    A <replaceable>fonte</replaceable> deve ser uma expressão de valor
    do tipo <type>timestamp</type>, <type>time</type> ou <type>interval</type>
    (As expressões do tipo <type>date</type> são convertidas em
    <type>timestamp</type>, podendo, portanto serem utilizadas também.
    O <replaceable>campo</replaceable> é um identificador, ou uma
    cadeia de caracteres, que seleciona o campo a ser extraído do valor fonte.
    A função <function>extract</function> retorna valores do tipo
    <type>double precision</type>.
    Abaixo estão mostrados os nomes de campo válidos:

    <!-- alphabetical -->
    <variablelist>
     <varlistentry>
      <term><literal>century</literal></term>
      <listitem>
       <para>
        O século
       </para>

<screen>
<userinput>SELECT extract(CENTURY FROM TIMESTAMP '2000-12-16 12:21:13');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>20</computeroutput>
<userinput>SELECT extract(CENTURY FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>21</computeroutput>
</screen>

       <para>
        O primeiro século começou em 0001-01-01 00:00:00 DC, embora não se
        soubesse disso naquela época. Esta definição se aplica a todos os
        países que utilizam o calendário Gregoriano. Não existe o século
        número 0, vai direto de -1 para 1.

        Se você não concorda com isto, por favor envie sua reclamação para:
        Papa, Basílica de São Pedro, Cidade do Vaticano.
       </para>

       <para>
        As versões do <productname>PostgreSQL</productname> anteriores a 8.0
        não seguiam a numeração dos séculos convencional, retornando
        simplesmente o campo ano dividido por 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>day</literal></term>
      <listitem>
       <para>
        O campo dia (do mês) (1 - 31)
       </para>

<screen>
<userinput>SELECT extract(DAY FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>16</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>decade</literal></term>
      <listitem>
       <para>
        O campo ano dividido por 10
       </para>

<screen>
<userinput>SELECT extract(DECADE FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>200</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>dow</literal></term>
      <listitem>
       <para>
        O dia da semana (0 - 6; Domingo é 0) (para valores
        <type>timestamp</type> apenas)
       </para>

<screen>
<userinput>SELECT extract(DOW FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>5</computeroutput>
</screen>
       <para>
        Deve ser observado que a numeração do dia da semana da função
        <function>extract</function> (0 a 6) é diferente da numeração do
        dia da semana da função <function>to_char</function> (1 a 7).
<screen>
<prompt>=&gt; </prompt><userinput>SELECT extract(DOW FROM TIMESTAMP '2005-08-14 20:38:40') AS Domingo;</userinput>

<computeroutput>
 domingo
---------
       0
(1 linha)
</computeroutput>

<prompt>=&gt; </prompt><userinput>SELECT to_char(TIMESTAMP '2005-08-14 20:38:40','D') AS Domingo;</userinput>

<computeroutput>
 domingo
---------
 1
(1 linha)
</computeroutput>

<prompt>=&gt; </prompt><userinput>SELECT extract(DOW FROM TIMESTAMP '2005-08-20 20:38:40') AS Sábado;</userinput>

<computeroutput>
 sábado
--------
      6
(1 linha)
</computeroutput>

<prompt>=&gt; </prompt><userinput>SELECT to_char(TIMESTAMP '2005-08-20 20:38:40','D') AS Sábado;</userinput>

<computeroutput>
 sábado
--------
 7
(1 linha)
</computeroutput>
</screen>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>doy</literal></term>
      <listitem>
       <para>
        O dia do ano (1 - 365/366) (para valores <type>timestamp</type> apenas)
       </para>

<screen>
<userinput>SELECT extract(DOY FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>47</computeroutput>
</screen>
       <para>
        Deve ser observado que a numeração do dia do ano da função
        <function>extract</function> (1 a 366) é igual a numeração do
        dia do ano da função <function>to_char</function> (1 a 366).
<screen>
<prompt>=&gt; </prompt><userinput>SELECT extract(DOY FROM TIMESTAMP '2004-12-31 23:59:59') AS dia;</userinput>

<computeroutput>
 dia
-----
 366
(1 linha)
</computeroutput>

<prompt>=&gt; </prompt><userinput>SELECT to_char(TIMESTAMP '2004-12-31 23:59:59', 'DDD') AS dia;</userinput>

<computeroutput>
 dia
-----
 366
(1 linha)
</computeroutput>
</screen>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>epoch</literal></term>
      <listitem>
       <para>
        Para valores <type>date</type> e <type>timestamp</type>, o
        número de segundos desde 1970-01-01 00:00:00-00 (pode ser negativo);
        para valores <type>interval</type>, o número total de segundos
        do intervalo
       </para>

<screen>
<userinput>SELECT extract(EPOCH FROM TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-08');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>982384720</computeroutput>

<userinput>SELECT extract(EPOCH FROM INTERVAL '5 days 3 hours');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>442800</computeroutput>
</screen>

       <para>
        Abaixo está mostrado como converter de volta um valor de época
        para um valor de carimbo do tempo:
       </para>

<screen>
<userinput>SELECT TIMESTAMP WITH TIME ZONE 'epoch' + 982384720 * INTERVAL '1 second';</userinput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>hour</literal></term>
      <listitem>
       <para>
        O campo hora (0 - 23)
       </para>

<screen>
<userinput>SELECT extract(HOUR FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>20</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>microseconds</literal></term>
      <listitem>
       <para>
        O campo segundos, incluindo a parte fracionária, multiplicado por
        1 milhão (1.000.000). Deve ser observado que inclui os segundos
        decorridos, e não apenas a fração de segundos.
       </para>

<screen>
<userinput>SELECT extract(MICROSECONDS FROM TIME '17:12:28.5');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>28500000</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>millennium</literal></term>
      <listitem>
       <para>
        O milênio
       </para>

<screen>
<userinput>SELECT extract(MILLENNIUM FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>3</computeroutput>
</screen>

       <para>
        Os anos em 1900 estão no segundo milênio.
        O terceiro milênio começou em 1 de janeiro de 2001.
       </para>

       <para>
        As versões do <productname>PostgreSQL</productname> anteriores a 8.0
        não seguiam a numeração dos milênios convencional, retornando
        simplesmente o campo ano dividido por 1000.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>milliseconds</literal></term>
      <listitem>
       <para>
        O campo segundos, incluindo a parte fracionária, multiplicado por
        mil (1.000). Deve ser observado que inclui os segundos decorridos,
        e não apenas a fração de segundos.
       </para>

<screen>
<userinput>SELECT extract(MILLISECONDS FROM TIME '17:12:28.5');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>28500</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>minute</literal></term>
      <listitem>
       <para>
        O campo minutos (0 - 59)
       </para>

<screen>
<userinput>SELECT extract(MINUTE FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>38</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>month</literal></term>
      <listitem>
       <para>
        Para valores <type>timestamp</type>, o número do mês do ano
        dentro do ano (1 - 12); para valores <type>interval</type>,
        o número de meses, módulo 12 (0 - 11)
       </para>

<screen>
<userinput>SELECT extract(MONTH FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2</computeroutput>

<userinput>SELECT extract(MONTH FROM INTERVAL '2 years 3 months');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>3</computeroutput>

<userinput>SELECT extract(MONTH FROM INTERVAL '2 years 13 months');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>quarter</literal></term>
      <listitem>
       <para>
        O trimestre do ano (1 - 4) onde o dia se encontra (para valores
        <type>timestamp</type> apenas)
       </para>

<screen>
<userinput>SELECT extract(QUARTER FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>1</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>second</literal></term>
      <listitem>
       <para>
        O campo segundos, incluindo a parte fracionária (0 - 59)
        <footnote>
         <para>
          60 se estiverem implementados no sistema operacional
          os segundos intercalados (<literal>leap seconds</literal>).
         </para>
        </footnote>
        <footnote>
         <para>
          Em certas ocasiões, o UTC é ajustado pela omissão de um segundo ou a
          inserção do <quote>segundo intercalado</quote> para manter sincronismo
          com o tempo sideral. Isto implica que às vezes, mas muito raramente,
          um determinado minuto contém exatamente 59, 61 ou 62 segundos. Se a
          implementação do SQL suporta os segundos intercalados, e as
          conseqüências deste suporte para aritmética de data e intervalo,
          é definido pela implementação.
          (ISO-ANSI Working Draft) Foundation (SQL/Foundation), August 2003,
          ISO/IEC JTC 1/SC 32, 25-jul-2003, ISO/IEC 9075-2:2003 (E) (N. do T.)
         </para>
        </footnote>
       </para>

<screen>
<userinput>SELECT extract(SECOND FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>40</computeroutput>

<userinput>SELECT extract(SECOND FROM TIME '17:12:28.5');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>28.5</computeroutput>
</screen>
      </listitem>
     </varlistentry>
     <varlistentry>
      <term><literal>timezone</literal></term>
      <listitem>
       <para>
        O deslocamento da zona horária em relação à UTC, medido em segundos.
        Os valores positivos correspondem às zonas horárias a leste da UTC,
        e os valores negativos correspondem às zonas horárias a oeste da UTC.
        <footnote>
         <para>
          O Brasil está a oeste da UTC (ocidente). O horário de Brasília normal
          corresponde ao GMT-3, e durante o horário de verão corresponde ao
          GMT-2. (N. do T.)
         </para>
        </footnote>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_hour</literal></term>
      <listitem>
       <para>
        O componente hora do deslocamento da zona horária
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>timezone_minute</literal></term>
      <listitem>
       <para>
        O componente minuto do deslocamento da zona horária
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>week</literal></term>
      <listitem>
       <para>
        O número da semana do ano onde o dia se encontra. Por definição
        (<acronym>ISO</acronym> 8601), a primeira semana do ano contém
        o dia 4 de janeiro deste ano; a semana <acronym>ISO</acronym>-8601
        começa na segunda-feira. Em outras palavras, a primeira quinta-feira do
        ano está na primeira semana do ano.
        (apenas para valores <type>timestamp</type>)
       </para>

<screen>
<userinput>SELECT extract(WEEK FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>7</computeroutput>
</screen>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>year</literal></term>
      <listitem>
       <para>
        O campo ano. Deve-se ter em mente que não existe o ano <literal>0 DC</>
        e, portanto, subtrair anos <literal>AC</> de <literal>DC</> deve ser
        feito com cautela.
       </para>

<screen>
<userinput>SELECT extract(YEAR FROM TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001</computeroutput>
</screen>
      </listitem>
     </varlistentry>

    </variablelist>

   </para>

   <para>
    A função <function>extract</function> é voltada principalmente para o
    processamento computacional. Para formatar valores de data e hora para
    exibição, consulte a <xref linkend="functions-formatting">.
   </para>

   <para>
    A função <function>date_part</function> é modelada segundo a função
    equivalente tradicional do <productname>Ingres</productname> à função
    <function>extract</function> do padrão <acronym>SQL</acronym>:
<synopsis>
date_part('<replaceable>campo</replaceable>', <replaceable>fonte</replaceable>)
</synopsis>
    Deve ser observado que, neste caso, o parâmetro
    <replaceable>campo</replaceable> deve ser um valor cadeia de caracteres,
    e não um nome. Os nomes de <replaceable>campo</replaceable> válidos para
    <function>date_part</function> são os mesmos da função
    <function>extract</function>.
   </para>

<screen>
<userinput>SELECT date_part('day', TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>16</computeroutput>

<userinput>SELECT date_part('hour', INTERVAL '4 hours 3 minutes');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>4</computeroutput>
</screen>

  </sect2>

  <sect2 id="functions-datetime-trunc">
   <title>date_trunc</title>

   <para>
    A função <function>date_trunc</function> é conceitualmente
    similar à função <function>trunc</function> para números.
   </para>

   <para>
<synopsis>
date_trunc('<replaceable>campo</replaceable>', <replaceable>fonte</replaceable>)
</synopsis>
    <replaceable>fonte</replaceable> é uma expressão de valor do tipo
    <type>timestamp</type> ou <type>interval</type>
    (valores do tipo <type>date</type> e
    <type>time</type> são convertidos automaticamente em <type>timestamp</type>
    ou <type>interval</type>, respectivamente). O
    <replaceable>campo</replaceable> seleciona a precisão a ser utilizada para
    truncar o valor da entrada. O valor retornado é do tipo
    <type>timestamp</type> ou <type>interval</type>,
    com todos os campos menos significativos do que
    valor selecionado tornados zero (ou um, para o dia do mês).
   </para>

   <para>
    Os valores válidos para <replaceable>campo</replaceable> são:
    <simplelist>
     <member><literal>microseconds</literal></member>
     <member><literal>milliseconds</literal></member>
     <member><literal>second</literal></member>
     <member><literal>minute</literal></member>
     <member><literal>hour</literal></member>
     <member><literal>day</literal></member>
     <member><literal>week</literal></member>
     <member><literal>month</literal></member>
     <member><literal>year</literal></member>
     <member><literal>decade</literal></member>
     <member><literal>century</literal></member>
     <member><literal>millennium</literal></member>
    </simplelist>
   </para>

   <para>
    Exemplos:
<screen>
<userinput>SELECT date_trunc('hour', TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-02-16 20:00:00</computeroutput>

<userinput>SELECT date_trunc('year', TIMESTAMP '2001-02-16 20:38:40');</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-01-01 00:00:00</computeroutput>
</screen>
   </para>
  </sect2>

  <sect2 id="functions-datetime-zoneconvert">
   <title>AT TIME ZONE</title>

   <indexterm>
    <primary>zona horária</primary>
    <secondary>conversão</secondary>
   </indexterm>

   <para>
    A construção <function>AT TIME ZONE</function> permite a conversão do
    carimbo do tempo para uma zona horária diferente.
    A <xref linkend="functions-datetime-zoneconvert-table"> mostra suas
    variantes.
   </para>

    <table id="functions-datetime-zoneconvert-table">
     <title>Variantes de AT TIME ZONE</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Expressão</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry>
         <literal><type>timestamp without time zone</type> AT TIME ZONE <replaceable>zona</replaceable></literal>
        </entry>
        <entry><type>timestamp with time zone</type></entry>
        <entry>Converte hora local de uma determinada zona horária para UTC</entry>
       </row>

       <row>
        <entry>
         <literal><type>timestamp with time zone</type> AT TIME ZONE <replaceable>zona</replaceable></literal>
        </entry>
        <entry><type>timestamp without time zone</type></entry>
        <entry>Converte de UTC para a hora local em uma determinada zona horária</entry>
       </row>

       <row>
        <entry>
         <literal><type>time with time zone</type> AT TIME ZONE <replaceable>zona</replaceable></literal>
        </entry>
        <entry><type>time with time zone</type></entry>
        <entry>Converte hora local entre zonas horárias</entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    Nestas expressões, a <replaceable>zona</replaceable> da zona horária desejada,
    pode ser especificada tanto por meio de um texto em uma cadeia de caracteres
    (por exemplo, <literal>'PST'</literal>), quanto por um intervalo
    (por exemplo, <literal>INTERVAL '-08:00'</literal>).
    No caso do texto, os nomes disponíveis para zona horária são os mostrados na
    <xref linkend="datetime-timezone-input-table"> (seria mais útil suportar
    os nomes mais gerais mostrados na
    <xref linkend="datetime-timezone-set-table">, mas isto ainda não está
    implementado).
   </para>

   <para>
    Exemplos (supondo que a zona horária local seja <literal>PST8PDT</literal>):
<screen>
<userinput>SELECT TIMESTAMP '2001-02-16 20:38:40' AT TIME ZONE 'MST';</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-02-16 19:38:40-08</computeroutput>

<userinput>SELECT TIMESTAMP WITH TIME ZONE '2001-02-16 20:38:40-05' AT TIME ZONE 'MST';</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-02-16 18:38:40</computeroutput>
</screen>
    O primeiro exemplo recebe um carimbo do tempo sem zona horária e o
    interpreta como hora MST (UTC-7) para produzir um carimbo do tempo UTC,
    o qual é então rotacionado para PST (UTC-8) para ser exibido. O segundo
    exemplo recebe um carimbo do tempo especificado em EST (UTC-5) e converte
    para hora local MST (UTC-7).
   </para>

   <para>
    A função
    <literal><function>timezone</function>(<replaceable>zona</replaceable>,
    <replaceable>carimbo_do_tempo</replaceable>)</literal>
    equivale à construção em conformidade com o padrão SQL
    <literal><replaceable>carimbo_do_tempo</replaceable> AT TIME ZONE
    <replaceable>zona</replaceable></literal>.
   </para>
  </sect2>

  <sect2 id="functions-datetime-current">
   <title>Data e hora corrente</title>

   <indexterm>
    <primary>data</primary>
    <secondary>corrente</secondary>
   </indexterm>

   <indexterm>
    <primary>hora</primary>
    <secondary>corrente</secondary>
   </indexterm>

   <para>
    Estão disponíveis as seguintes funções para obter a
    data e hora corrente:
<synopsis>
CURRENT_DATE
CURRENT_TIME
CURRENT_TIMESTAMP
CURRENT_TIME ( <replaceable>precisão</replaceable> )
CURRENT_TIMESTAMP ( <replaceable>precisão</replaceable> )
LOCALTIME
LOCALTIMESTAMP
LOCALTIME ( <replaceable>precisão</replaceable> )
LOCALTIMESTAMP ( <replaceable>precisão</replaceable> )
</synopsis>
    </para>

    <para>
     <function>CURRENT_TIME</function> e
     <function>CURRENT_TIMESTAMP</function> retornam valores com zona horária;
     <function>LOCALTIME</function> e
     <function>LOCALTIMESTAMP</function> retornam valores sem zona horária.
    </para>

    <para>
     <function>CURRENT_TIME</function>,
     <function>CURRENT_TIMESTAMP</function>,
     <function>LOCALTIME</function> e
     <function>LOCALTIMESTAMP</function>
     podem, opcionalmente, receber o parâmetro precisão fazendo o resultado ser
     arredondado nesta quantidade de dígitos fracionários no campo de segundos.
     Sem o parâmetro de precisão, o resultado é produzido com toda a precisão
     disponível.
    </para>

    <note>
     <para>
      Antes do <productname>PostgreSQL</productname> versão 7.2, os parâmetros
      de precisão não estavam implementados, e o resultado era sempre retornado
      em segundos inteiros.
     </para>
    </note>

   <para>
    Alguns exemplos:
<screen>
<userinput>SELECT CURRENT_TIME;</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>14:39:53.662522-05</computeroutput>

<userinput>SELECT CURRENT_DATE;</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-12-23</computeroutput>

<userinput>SELECT CURRENT_TIMESTAMP;</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-12-23 14:39:53.662522-05</computeroutput>

<userinput>SELECT CURRENT_TIMESTAMP(2);</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-12-23 14:39:53.66-05</computeroutput>

<userinput>SELECT LOCALTIMESTAMP;</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>2001-12-23 14:39:53.662522</computeroutput>
</screen>
   </para>

   <para>
    A função <function>now()</function> é o equivalente tradicional do
    <productname>PostgreSQL</productname> para
    <function>CURRENT_TIMESTAMP</function>.
   </para>

   <para>
    Também existe a função <function>timeofday()</function>, que por motivos
    históricos retorna uma cadeia de caracteres do tipo <type>text</type>,
    e não um valor do tipo <type>timestamp</type>:
<screen>
<userinput>SELECT timeofday();</userinput>
<lineannotation>Resultado: </lineannotation><computeroutput>Sat Feb 17 19:07:32.000126 2001 EST</computeroutput>
</screen>
   </para>

   <para>
    É importante saber que <function>CURRENT_TIMESTAMP</function>, e as funções
    relacionadas, retornam a data e hora do começo da transação corrente; seus
    valores não mudam durante a transação. Isto é considerado uma funcionalidade:
    o objetivo é permitir que a transação possua uma noção consistente do tempo
    <quote>corrente</quote>, de forma que várias modificações dentro da mesma
    transação compartilhem o mesmo carimbo do tempo.
    A função <function>timeofday()</function> retorna a hora do relógio,
    avançando durante as transações.
   </para>

   <note>
    <para>
     Outros sistemas de banco de dados podem avançar estes valores com mais
     freqüência.
    </para>
   </note>

   <para>
    Todos os tipos de dado para data e hora também aceitam o valor literal
    especial <literal>now</literal> para especificar a data e hora corrente.
    Portanto, os três comandos abaixo retornam o mesmo resultado:
<screen>
<userinput>SELECT CURRENT_TIMESTAMP;</userinput>
<userinput>SELECT now();</userinput>
<userinput>SELECT TIMESTAMP 'now';</userinput> -- incorreto para uso com DEFAULT
</screen>
   </para>

    <tip>
     <para>
      Não se utiliza a terceira forma ao especificar a cláusula
      <literal>DEFAULT</literal> na criação da tabela. O sistema converte
      <literal>now</literal> em <type>timestamp</type> tão logo a constante é
      analisada e, portanto, quando o valor padrão for utilizado será utilizada
      a hora da criação da tabela! As duas primeiras formas não são avaliadas
      até que o valor padrão seja utilizado, porque são chamadas de função.
      Assim sendo, as duas primeiras formas fornecem o comportamento desejado
      quando o padrão for a hora de inserção da linha.
     </para>
    </tip>
  </sect2>

  <sect2 id="functions-datetime-pg-mssql-oracle">

   <sect2info>
    <author>
     <firstname>Halley</firstname>
     <surname>Pacheco de Oliveira</surname>
     <affiliation>
      <orgname>Câmara Municipal do Rio de Janeiro</orgname>
      <orgdiv>Assessoria de Informática</orgdiv>
      <address>
       <city>Rio de Janeiro</city>
       <country>Brasil</country>
      </address>
     </affiliation>
    </author>
    <date>2005-08-10</date>
   </sect2info>

   <title>Comparação entre o PostgreSQL, o Oracle, o SQL Server e o DB2</title>

   <note>
    <para>
     Seção escrita pelo tradutor, não fazendo parte do manual original.
    </para>
   </note>

   <para>
    Esta seção tem por finalidade comparar, através de exemplos práticos, as
    funções e operadores para data e hora do
    <productname>PostgreSQL</productname>, do <productname>Oracle</productname>,
    do <productname>SQL Server</productname> e do <productname>DB2</productname>.
   </para>

   <example id="func-interval-use">
    <title>Utilização de INTERVAL</title>
    <para>
     Abaixo estão mostrados exemplos comparando a utilização de
     <function>INTERVAL</function> no <productname>PostgreSQL</productname> e no
     <productname>Oracle</productname>.
     Consulte também
     <ulink url="http://www.stanford.edu/dept/itss/docs/oracle/9i/server.920/a96540/sql_elements3a.htm#38599">
     Interval Literals</ulink>.
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT INTERVAL'20 DAY' - INTERVAL'240 HOUR' AS intervalo;</userinput>

<computeroutput>
 intervalo
-----------
 10 days
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT INTERVAL '4 DAYS 5 HOURS 12 MINUTES';</userinput>

<computeroutput>
    interval
-----------------
 4 days 05:12:00
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT INTERVAL'20' DAY - INTERVAL'240' HOUR(3) FROM sys.dual;</userinput>

<computeroutput>
INTERVAL'20'DAY-INTERVAL'240'HOUR(3)
------------------------------------
+000000010 00:00:00.000000000
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT INTERVAL '4 5:12' DAY TO MINUTE  FROM sys.dual;</userinput>

<computeroutput>
INTERVAL'45:12'DAYTOMINUTE
--------------------------
+04 05:12:00
</computeroutput>
</screen>
   </example>

   <example id="func-days-between-dates">
    <title>Número de dias entre duas datas</title>
    <para>
     Abaixo estão mostrados exemplos de funções do
     <productname>PostgreSQL</productname>, do
     <productname>SQL Server</productname>, do <productname>Oracle</productname>
     e do <productname>DB2</productname>, para obter o número de dias entre
     duas datas. Consulte também
     <ulink url="http://asktom.oracle.com/~tkyte/Misc/DateDiff.html">
     Getting the difference between Dates</ulink>,
     <ulink url="http://www-128.ibm.com/developerworks/db2/library/techarticle/0211yip/0211yip3.html">
     DB2 Basics:  Fun with Dates and Times</ulink> e
     <ulink url="http://msdn.microsoft.com/library/en-us/tsqlref/ts_da-db_5vxi.asp?frame=true">
     SQL Server, DATEDIFF</ulink>
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT date('1950-07-16') - date('1949-11-21') AS dias;</userinput>

<computeroutput>
 dias
------
  237
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT datediff(DAY, convert(datetime,'1949-11-21',120), convert(datetime,'1950-07-16',120)) AS dias</userinput>

<computeroutput>
dias
----
237
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';</userinput>

<prompt>SQL&gt;</prompt> <userinput>SELECT to_date('1950-07-16') - to_date('1949-11-21') AS dias FROM sys.dual;</userinput>

<computeroutput>
      DIAS
----------
       237
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT days(date('1950-07-16'))- days(date('1949-11-21')) AS dias FROM sysibm.sysdummy1;</userinput>

<computeroutput>
DIAS
-------------
        237
</computeroutput>
</screen>
   </example>

   <example id="func-month-day">
    <title>Obtenção do dia do mês</title>
    <para>
     Abaixo estão mostrados exemplos de funções do
     <productname>PostgreSQL</productname>, do
     <productname>SQL Server</productname>, do <productname>Oracle</productname>
     e do <productname>DB2</productname>, para obter o dia do mês. Consulte também
     <ulink url="http://www.stanford.edu/dept/itss/docs/oracle/9i/server.920/a96540/functions134a.htm">
     TO_CHAR (datetime) no Oracle</ulink>,
     <ulink url="ftp://ftp.software.ibm.com/ps/products/db2/info/vr82/pdf/en_US/db2s1e81.pdf">
     DAY no DB2</ulink> e
     <ulink url="http://msdn.microsoft.com/library/en-us/tsqlref/ts_fa-fz_2c1f.asp">
     SQL Server Date and Time Functions</ulink>
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT date_part('day',CURRENT_TIMESTAMP) AS dia;</userinput>

<computeroutput>
 dia
-----
  14
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT extract(DAY FROM CURRENT_TIMESTAMP) AS dia;</userinput>

<computeroutput>
 dia
-----
  14
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT to_char(CURRENT_TIMESTAMP,'DD') AS dia;</userinput>

<computeroutput>
 dia
-----
 14
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT datepart(DAY, CURRENT_TIMESTAMP) AS dia</userinput>

<computeroutput>
dia
---
14
(1 row(s) affected)
</computeroutput>

<userinput>SELECT day(CURRENT_TIMESTAMP) AS dia</userinput>

<computeroutput>
dia
---
14
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT to_char(CURRENT_TIMESTAMP,'DD') AS dia FROM sys.dual;</userinput>

<computeroutput>
DI
--
14
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT extract(DAY FROM CURRENT_TIMESTAMP) AS dia FROM sys.dual;</userinput>

<computeroutput>
DI
--
14
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT day(CURRENT_TIMESTAMP) FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
-------------
         14
</computeroutput>
</screen>
   </example>

   <example id="func-current-date-time">
    <title>Utilização das funções para data e hora corrente</title>
    <para>
     Abaixo estão mostrados exemplos comparando a utilização das funções que
     retornam a data e hora corrente no <productname>PostgreSQL</productname>,
     no <productname>SQL Server</productname>, no
     <productname>Oracle</productname> e no <productname>DB2</productname>.
     <footnote>
      <para>
       A função CURRENT_TIMESTAMP é definida no padrão SQL possuindo o formato
       <literal>&lt;current timestamp value function&gt; ::= CURRENT_TIMESTAMP
       [ &lt;left paren&gt; &lt;timestamp precision&gt; &lt;right paren&gt; ]
       </literal>
       (Second Informal Review Draft)
       ISO/IEC 9075:1992, Database Language SQL- July 30, 1992. (N. do T.)
      </para>
     </footnote>
     Consulte também
     <ulink url="http://www.stanford.edu/dept/itss/docs/oracle/9i/server.920/a96540/functions31a.htm">
     CURRENT_TIMESTAMP no Oracle</ulink>,
     <ulink url="http://msdn.microsoft.com/library/en-us/tsqlref/ts_cr-cz_60mo.asp?frame=true">
     CURRENT_TIMESTAMP no SQL Server</ulink> e
     <ulink url="ftp://ftp.software.ibm.com/ps/products/db2/info/vr82/pdf/en_US/db2s1e81.pdf">
     CURRENT_TIMESTAMP no DB2</ulink>.
   </para>

   <para>
    Como o <productname>PostgreSQL</productname>, o
    <productname>SQL Server</productname> e o
    <productname>Oracle</productname> foram executados no
    <systemitem class=osname>Windows 2000</systemitem>, enquanto o
    <productname>DB2</productname> foi executado no
    <systemitem class=osname>Linux</systemitem>,
    deve ser observado que a precisão da fração de segundos varia.
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_DATE;</userinput>

<computeroutput>
    date
------------
 2005-03-04
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_TIME;</userinput>

<computeroutput>
       timetz
--------------------
 16:42:07.33-03
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP;</userinput>

<computeroutput>
          timestamptz
-------------------------------
 2005-03-04 16:42:07.38-03
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_TIME(0);</userinput>

<computeroutput>
   timetz
-------------
 16:42:07-03
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP(0);</userinput>

<computeroutput>
      timestamptz
------------------------
 2005-03-04 16:42:07-03
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT LOCALTIME AS agora;</userinput>

<computeroutput>
    agora
-------------
 16:42:07.53
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT LOCALTIMESTAMP;</userinput>

<computeroutput>
         timestamp
----------------------------
 2005-03-04 16:42:07.58
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT LOCALTIME (0) AS agora;</userinput>

<computeroutput>
  agora
----------
 16:42:08
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT LOCALTIMESTAMP (0) AS agora;</userinput>

<computeroutput>
        agora
---------------------
 2005-03-04 16:42:08
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP AT TIME ZONE 'UTC' AS UTC;</userinput>

<computeroutput>
            utc
----------------------------
 2005-03-04 19:42:07.73
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT now();</userinput>

<computeroutput>
              now
-------------------------------
 2005-03-04 16:42:07.891-03
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT timeofday();</userinput>

<computeroutput>
              timeofday
-------------------------------------
 Fri Mar 04 16:42:07.941000 2005 BRT
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT to_char(CURRENT_TIMESTAMP, 'DD-MM-YYYY HH24:MI:SS') AS agora;</userinput>

<computeroutput>
        agora
--------------------
 04-03-2005 16:42:07
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT CURRENT_TIMESTAMP AS agora</userinput>

<computeroutput>
agora
-----------------------
2005-03-04 16:39:51.207
(1 row(s) affected)
</computeroutput>

<userinput>SELECT getdate() AS agora</userinput>

<computeroutput>
agora
-----------------------
2005-03-04 16:39:51.207
(1 row(s) affected)
</computeroutput>

<userinput>SELECT getutcdate() AS UTC</userinput>

<computeroutput>
UTC
-----------------------
2005-03-04 19:39:51.207
(1 row(s) affected)
</computeroutput>

<userinput>SELECT convert(VARCHAR, CURRENT_TIMESTAMP, 121) AS agora</userinput>

<computeroutput>
agora
-----------------------
2005-03-04 16:39:51.207
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET TIME_ZONE = local;</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_TIMESTAMP_FORMAT  = 'YYYY-MM-DD HH24:MI:SS.FF';</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT  = 'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM';</userinput>

<prompt>SQL&gt;</prompt> <userinput>SELECT CURRENT_DATE FROM sys.dual;</userinput>

<computeroutput>
CURRENT_DA
----------
2005-03-26
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP FROM sys.dual;</userinput>

<computeroutput>
CURRENT_TIMESTAMP
---------------------------------
2005-03-26 17:31:33.934000 -03:00
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP(0) FROM sys.dual;</userinput>

<computeroutput>
CURRENT_TIMESTAMP(0)
---------------------------
2005-03-26 17:31:34. -03:00
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT LOCALTIMESTAMP FROM sys.dual;</userinput>

<computeroutput>
LOCALTIMESTAMP
--------------------------
2005-03-26 17:31:33.954000
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT LOCALTIMESTAMP (0) FROM sys.dual;</userinput>

<computeroutput>
LOCALTIMESTAMP(0)
--------------------
2005-03-26 17:31:34.
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP AT TIME ZONE 'UTC' AS UTC FROM sys.dual;</userinput>

<computeroutput>
UTC
---------------------------------
2005-03-26 20:31:33.984000 +00:00
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT to_char(CURRENT_TIMESTAMP, 'DD-MM-YYYY HH24:MI:SS') AS agora FROM sys.dual;</userinput>

<computeroutput>
AGORA
-------------------
26-03-2005 17:31:33
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT_DATE AS data FROM sysibm.sysdummy1;</userinput>

<computeroutput>
DATA
------------
26/03/2005
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT DATE AS data FROM sysibm.sysdummy1;</userinput>

<computeroutput>
DATA
------------
26/03/2005
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT_TIME AS hora FROM sysibm.sysdummy1;</userinput>

<computeroutput>
HORA
----------
21:55:05
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT TIME AS hora FROM sysibm.sysdummy1;</userinput>

<computeroutput>
HORA
----------
21:55:25
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT_TIMESTAMP AS agora FROM sysibm.sysdummy1;</userinput>

<computeroutput>
AGORA
----------------------------
2005-03-26-21.55.47.195177
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT TIMESTAMP AS agora FROM sysibm.sysdummy1;</userinput>

<computeroutput>
AGORA
----------------------------
2005-03-26-21.56.13.294096
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT TIMESTAMP - MICROSECOND (CURRENT TIMESTAMP) MICROSECONDS</userinput>
<prompt>DB2SQL92&gt;</prompt> <userinput>       AS "CURRENT_TIMESTAMP(0)" FROM sysibm.sysdummy1;</userinput>

<computeroutput>
CURRENT_TIMESTAMP(0)
----------------------------
2005-03-26-21.56.42.000000
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT TIMESTAMP - CURRENT TIMEZONE AS utc FROM sysibm.sysdummy1;</userinput>

<computeroutput>
UTC
----------------------------
2005-03-27-00.57.19.704003
</computeroutput>
</screen>

   </example>

   <example id="func-data-type-timestamp">
    <title>Tipo de dado timestamp</title>
    <para>
     Abaixo são mostrados exemplos comparando a utilização do tipo de dado
     <type>timestamp</type> no <productname>PostgreSQL</productname>, no
     <productname>SQL Server</productname>, no <productname>Oracle</productname>
     e no <productname>DB2</productname>.
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT TIMESTAMP '1999-01-01 12:34:56' AS timestamp;</userinput>

<computeroutput>
      timestamp
---------------------
 1999-01-01 12:34:56
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT cast('1999-01-01 12:34:56' AS TIMESTAMP) AS timestamp;</userinput>

<computeroutput>
      timestamp
---------------------
 1999-01-01 12:34:56
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT cast('1999-01-01 12:34:56' AS datetime) AS timestamp</userinput>

<computeroutput>
timestamp
-----------------------
1999-01-01 12:34:56.000
(1 row(s) affected)
</computeroutput>

<userinput>SELECT convert(datetime,'1999-01-01 12:34:56',120) AS timestamp</userinput>

<computeroutput>
timestamp
-----------------------
1999-01-01 12:34:56.000
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET TIME_ZONE = local;</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD';</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_TIMESTAMP_FORMAT  = 'YYYY-MM-DD HH24:MI:SS.FF';</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT  = 'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM';</userinput>

<prompt>SQL&gt;</prompt> <userinput>SELECT TIMESTAMP '1999-01-01 12:34:56' AS timestamp FROM sys.dual;</userinput>

<computeroutput>
TIMESTAMP
-----------------------------
1999-01-01 12:34:56.000000000
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT cast('1999-01-01 12:34:56' AS TIMESTAMP) AS timestamp FROM sys.dual;</userinput>

<computeroutput>
TIMESTAMP
--------------------------
1999-01-01 12:34:56.000000
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT timestamp('1999-01-01','12.34.56') AS timestamp FROM sysibm.sysdummy1;</userinput>

<computeroutput>
TIMESTAMP
----------------------------
1999-01-01-12.34.56.000000
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT cast('1999-01-01 12:34:56' AS TIMESTAMP) AS timestamp FROM sysibm.sysdummy1;</userinput>

<computeroutput>
TIMESTAMP
----------------------------
1999-01-01-12.34.56.000000
</computeroutput>
</screen>
   </example>

   <example id="func-date-add-days-hours">
    <title>Somar dias e horas a uma data</title>
    <para>
     Abaixo são mostrados exemplos de aritmética com datas, somando 30 dias a
     uma data sem hora, 30 dias a uma data com hora, e 3 dias e 3 horas ao
     carimbo do tempo corrente, no <productname>PostgreSQL</productname>,
     no <productname>Oracle</productname>, no
     <productname>SQL Server</productname> e no <productname>DB2</productname>.
     <footnote>
      <para>
       Exemplo escrito pelo tradutor, não fazendo parte do manual original.
      </para>
     </footnote>
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT cast('2004-07-16' AS date) + interval'30 days' AS data;</userinput>

<computeroutput>
        data
---------------------
 2004-08-15 00:00:00
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT cast('2004-07-16 15:00:00' AS timestamp) + interval'30 days' AS data;</userinput>

<computeroutput>
        data
---------------------
 2004-08-15 15:00:00
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT current_timestamp as agora,</userinput>
<prompt>-&gt;</prompt> <userinput>current_timestamp + interval'3 days 3 hours' AS depois;</userinput>

<computeroutput>
             agora             |            depois
-------------------------------+-------------------------------
 2005-04-01 08:16:44.029386-03 | 2005-04-04 11:16:44.029386-03
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>
SELECT dateadd(DAY,30,convert(smalldatetime,'2004-07-16',120)) as data
</userinput>

<computeroutput>
data
-------------------
2004-08-15 00:00:00
(1 row(s) affected)
</computeroutput>

<userinput>
SELECT dateadd(DAY,30,convert(datetime,'2004-07-16 15:00:00',120)) as data
</userinput>

<computeroutput>
data
-----------------------
2004-08-15 15:00:00.000
(1 row(s) affected)
</computeroutput>

<userinput>
SELECT current_timestamp as agora,
       dateadd(DAY,3,dateadd(HOUR,3,current_timestamp)) as depois
</userinput>

<computeroutput>
agora                   depois
----------------------- -----------------------
2005-04-01 06:27:41.367 2005-04-04 09:27:41.367
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET TIME_ZONE = local;</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI:SS';</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_TIMESTAMP_FORMAT  = 'YYYY-MM-DD HH24:MI:SS.FF';</userinput>
<prompt>SQL&gt;</prompt> <userinput>ALTER SESSION SET NLS_TIMESTAMP_TZ_FORMAT  = 'YYYY-MM-DD HH24:MI:SS.FF TZH:TZM';</userinput>

<prompt>SQL&gt;</prompt> <userinput>SELECT cast('2004-07-16' AS date) + 30</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>

<computeroutput>
CAST('2004-07-16'AS
-------------------
2004-08-15 00:00:00
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT cast('2004-07-16' AS date) + INTERVAL '30' DAY</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>

<computeroutput>
CAST('2004-07-16'AS
-------------------
2004-08-15 00:00:00
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT cast('2004-07-16 15:00:00' AS timestamp) + 30</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>

<computeroutput>
CAST('2004-07-1615:
-------------------
2004-08-15 15:00:00
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT cast('2004-07-16 15:00:00' AS timestamp) + INTERVAL '30' DAY</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>

<computeroutput>
CAST('2004-07-1615:00:00'ASTIMESTAMP)+INTERVAL'30'DAY
-----------------------------------------------------
2004-08-15 15:00:00.000000000
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT current_timestamp AS agora, current_timestamp + 3 + 3/24 AS depois</userinput>
<prompt>  2 </prompt> <userinput>FROM sys.dual;</userinput>

<computeroutput>
AGORA                                DEPOIS
------------------------------------ ------------------------------------
2005-04-01 18:04:58.702000 -03:00    2005-04-04 21:04:58
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT current_timestamp AS agora,</userinput>
<prompt>  2 </prompt> <userinput>current_timestamp + interval '3' day + interval '3' hour AS depois</userinput>
<prompt>  3 </prompt> <userinput>FROM sys.dual;</userinput>

<computeroutput>
AGORA                                DEPOIS
------------------------------------ ------------------------------------
2005-04-01 18:04:59.253000 -03:00    2005-04-04 21:04:59.253000000 -03:00
</computeroutput>
</screen>

   <para>
    <productname>DB2 8.1</productname>:
   </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT cast('2004-07-16' AS date) + 30 days</userinput>
<prompt>DB2SQL92&gt;</prompt> <userinput>FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
------------
15/08/2004
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT cast('2004-07-16 15:00:00' AS timestamp) + 30 days</userinput>
<prompt>DB2SQL92&gt;</prompt> <userinput>FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
----------------------------
2004-08-15-15.00.00.000000
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT current_timestamp, current_timestamp + 3 days + 3 hours</userinput>
<prompt>DB2SQL92&gt;</prompt> <userinput>FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1                           2
--------------------------------------------------------
2005-04-01-07.34.41.953274  2005-04-04-10.34.41.953274
</computeroutput>
</screen>
   </example>
  </sect2>
 </sect1>

 <sect1 id="functions-geometry">
  <title>Funções e operadores geométricos</title>

   <para>
    Os tipos geométricos <type>point</type>, <type>box</type>,
    <type>lseg</type>, <type>line</type>, <type>path</type>,
    <type>polygon</type> e <type>circle</type> possuem um amplo conjunto de
    funções e operadores nativos para apoiá-los, mostrados na <xref
    linkend="functions-geometry-op-table">, na <xref
    linkend="functions-geometry-func-table"> e na <xref
    linkend="functions-geometry-conv-table">.
   </para>

   <table id="functions-geometry-op-table">
     <title>Operadores geométricos</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Operador</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>+</literal> </entry>
        <entry>Translação</entry>
        <entry><literal>box '((0,0),(1,1))' + point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>-</literal> </entry>
        <entry>Translação</entry>
        <entry><literal>box '((0,0),(1,1))' - point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>*</literal> </entry>
        <entry>Escala/rotação</entry>
        <entry><literal>box '((0,0),(1,1))' * point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>/</literal> </entry>
        <entry>Escala/rotação</entry>
        <entry><literal>box '((0,0),(2,2))' / point '(2.0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <entry>Ponto ou caixa de interseção</entry>
        <entry><literal>'((1,-1),(-1,1))' # '((1,1),(-1,-1))'</literal></entry>
       </row>
       <row>
        <entry> <literal>#</literal> </entry>
        <entry>Número de pontos do caminho ou do polígono</entry>
        <entry><literal># '((1,0),(0,1),(-1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@-@</literal> </entry>
        <entry>Comprimento ou circunferência</entry>
        <entry><literal>@-@ path '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>@@</literal> </entry>
        <entry>Centro</entry>
        <entry><literal>@@ circle '((0,0),10)'</literal></entry>
       </row>
       <row>
        <entry> <literal>##</literal> </entry>
        <entry>Ponto mais próximo do primeiro operando no segundo operando</entry>
        <entry><literal>point '(0,0)' ## lseg '((2,0),(0,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;-&gt;</literal> </entry>
        <entry>Distância entre</entry>
        <entry><literal>circle '((0,0),1)' &lt;-&gt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&amp;</literal> </entry>
        <entry>Se sobrepõem?</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&amp; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&lt;</literal> </entry>
        <entry>Não se estende à direita de?</entry>
        <entry><literal>box '((0,0),(1,1))' &amp;&lt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&amp;&gt;</literal> </entry>
        <entry>Não se estende à esquerda de?</entry>
        <entry><literal>box '((0,0),(3,3))' &amp;&gt; box '((0,0),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>Está à esquerda?</entry>
        <entry><literal>circle '((0,0),1)' &lt;&lt; circle '((5,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>Está à direita?</entry>
        <entry><literal>circle '((5,0),1)' &gt;&gt; circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;^</literal> </entry>
        <entry>Está abaixo?</entry>
        <entry><literal>circle '((0,0),1)' &lt;^ circle '((0,5),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;^</literal> </entry>
        <entry>Está acima?</entry>
        <entry><literal>circle '((0,5),1)' &gt;^ circle '((0,0),1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?#</literal> </entry>
        <entry>Se intersectam?</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?# box '((-2,-2),(2,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <entry>É horizontal?</entry>
        <entry><literal>?- lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-</literal> </entry>
        <entry>São alinhados horizontalmente?</entry>
        <entry><literal>point '(1,0)' ?- point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <entry>É vertical?</entry>
        <entry><literal>?| lseg '((-1,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?|</literal> </entry>
        <entry>São alinhados verticalmente</entry>
        <entry><literal>point '(0,1)' ?| point '(0,0)'</literal></entry>
       </row>
       <row>
        <entry> <literal>?-|</literal> </entry>
        <entry>São perpendiculares?</entry>
        <entry><literal>lseg '((0,0),(0,1))' ?-| lseg '((0,0),(1,0))'</literal></entry>
       </row>
       <row>
        <entry> <literal>?||</literal> </entry>
        <entry>São paralelos?</entry>
        <entry><literal>lseg '((-1,0),(1,0))' ?|| lseg '((-1,2),(1,2))'</literal></entry>
       </row>
       <row>
        <entry> <literal>~</literal> </entry>
        <entry>Contém?</entry>
        <entry><literal>circle '((0,0),2)' ~ point '(1,1)'</literal></entry>
       </row>
       <row>
        <entry> <literal>@</literal> </entry>
        <entry>Está contido ou sobre?</entry>
        <entry><literal>point '(1,1)' @ circle '((0,0),2)'</literal></entry>
       </row>
       <row>
        <entry> <literal>~=</literal> </entry>
        <entry>O mesmo que?</entry>
        <entry><literal>polygon '((0,0),(1,1))' ~= polygon '((1,1),(0,0))'</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>


   <table id="functions-geometry-func-table">
     <title>Funções geométricas</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>area</function>(<replaceable>object</>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>área</entry>
        <entry><literal>area(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box_intersect</function>(<type>box</>, <type>box</>)</literal></entry>
        <entry><type>box</type></entry>
        <entry>caixa de interseção</entry>
        <entry><literal>box_intersect(box '((0,0),(1,1))',box '((0.5,0.5),(2,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>center</function>(<replaceable>object</>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>centro</entry>
        <entry><literal>center(box '((0,0),(1,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>diameter</function>(<type>circle</>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>diâmetro do círculo</entry>
        <entry><literal>diameter(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>height</function>(<type>box</>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>tamanho vertical da caixa</entry>
        <entry><literal>height(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isclosed</function>(<type>path</>)</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>é um caminho fechado?</entry>
        <entry><literal>isclosed(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>isopen</function>(<type>path</>)</literal></entry>
        <entry><type>boolean</type></entry>
        <entry>é um caminho aberto?</entry>
        <entry><literal>isopen(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>length</function>(<replaceable>object</>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>comprimento</entry>
        <entry><literal>length(path '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints</function>(<type>path</>)</literal></entry>
        <entry><type>integer</type></entry>
        <entry>número de pontos</entry>
        <entry><literal>npoints(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
       <row>
        <entry><literal><function>npoints</function>(<type>polygon</>)</literal></entry>
        <entry><type>integer</type></entry>
        <entry>número de pontos</entry>
        <entry><literal>npoints(polygon '((1,1),(0,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>pclose</function>(<type>path</>)</literal></entry>
        <entry><type>path</type></entry>
        <entry>converte o caminho em caminho fechado</entry>
        <entry><literal>pclose(path '[(0,0),(1,1),(2,0)]')</literal></entry>
       </row>
<![IGNORE[
<!-- Not defined by this name. Implements the intersection operator '#' -->
       <row>
        <entry><literal><function>point</function>(<type>lseg</>, <type>lseg</>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>intersection</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))',lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
]]>
       <row>
        <entry><literal><function>popen</function>(<type>path</>)</literal></entry>
        <entry><type>path</type></entry>
        <entry>converte o caminho em caminho aberto</entry>
        <entry><literal>popen(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>radius</function>(<type>circle</type>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>raio do círculo</entry>
        <entry><literal>radius(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>width</function>(<type>box</>)</literal></entry>
        <entry><type>double precision</type></entry>
        <entry>tamanho horizontal da caixa</entry>
        <entry><literal>width(box '((0,0),(1,1))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>


   <table id="functions-geometry-conv-table">
     <title>Funções de conversão de tipo geométrico</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>box</function>(<type>circle</type>)</literal></entry>
        <entry><type>box</type></entry>
        <entry>círculo em caixa</entry>
        <entry><literal>box(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box</function>(<type>point</type>, <type>point</type>)</literal></entry>
        <entry><type>box</type></entry>
        <entry>pontos em caixa</entry>
        <entry><literal>box(point '(0,0)', point '(1,1)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>box</function>(<type>polygon</type>)</literal></entry>
        <entry><type>box</type></entry>
        <entry>polígono em caixa</entry>
        <entry><literal>box(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle</function>(<type>box</type>)</literal></entry>
        <entry><type>circle</type></entry>
        <entry>caixa em círculo</entry>
        <entry><literal>circle(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>circle</function>(<type>point</type>, <type>double precision</type>)</literal></entry>
        <entry><type>circle</type></entry>
        <entry>centro e raio em círculo</entry>
        <entry><literal>circle(point '(0,0)', 2.0)</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg</function>(<type>box</type>)</literal></entry>
        <entry><type>lseg</type></entry>
        <entry>diagonal de caixa em segmento de linha</entry>
        <entry><literal>lseg(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>lseg</function>(<type>point</type>, <type>point</type>)</literal></entry>
        <entry><type>lseg</type></entry>
        <entry>ponto em segmento de linha</entry>
        <entry><literal>lseg(point '(-1,0)', point '(1,0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>path</function>(<type>polygon</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>polígono em caminho</entry>
        <entry><literal>path(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point</function>(<type>double
         precision</type>, <type>double precision</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>constrói ponto</entry>
        <entry><literal>point(23.4, -44.5)</literal></entry>
       </row>
       <row>
        <entry><literal><function>point</function>(<type>box</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>centro da caixa</entry>
        <entry><literal>point(box '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point</function>(<type>circle</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>centro do círculo</entry>
        <entry><literal>point(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point</function>(<type>lseg</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>centro do segmento de linha</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point</function>(<type>lseg</type>, <type>lseg</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>intersecção</entry>
        <entry><literal>point(lseg '((-1,0),(1,0))', lseg '((-2,-2),(2,2))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>point</function>(<type>polygon</type>)</literal></entry>
        <entry><type>point</type></entry>
        <entry>centro do polígono</entry>
        <entry><literal>point(polygon '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon</function>(<type>box</type>)</literal></entry>
        <entry><type>polygon</type></entry>
        <entry>caixa em polígono de 4 pontos</entry>
        <entry><literal>polygon(box '((0,0),(1,1))')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon</function>(<type>circle</type>)</literal></entry>
        <entry><type>polygon</type></entry>
        <entry>círculo em polígono de 12 pontos</entry>
        <entry><literal>polygon(circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon</function>(<replaceable class="parameter">npts</replaceable>, <type>circle</type>)</literal></entry>
        <entry><type>polygon</type></entry>
        <entry>círculo em polígono de <replaceable class="parameter">npts</replaceable>-pontos</entry>
        <entry><literal>polygon(12, circle '((0,0),2.0)')</literal></entry>
       </row>
       <row>
        <entry><literal><function>polygon</function>(<type>path</type>)</literal></entry>
        <entry><type>polygon</type></entry>
        <entry>caminho em polígono</entry>
        <entry><literal>polygon(path '((0,0),(1,1),(2,0))')</literal></entry>
       </row>
      </tbody>
     </tgroup>
   </table>

    <para>
     É possível acessar os dois números que compõem um <type>point</type>
     como se este fosse uma matriz com os índices 0 e 1. Por exemplo, se
     <literal>t.p</literal> for uma coluna do tipo <type>point</type>, então
     <literal>SELECT p[0] FROM t</literal> retorna a coordenada X, e
     <literal>UPDATE t SET p[1] = ...</literal> altera a coordenada Y.
     Do mesmo modo, um valor do tipo <type>box</type> ou <type>lseg</type> pode
     ser tratado como sendo uma matriz contendo dois valores do tipo
     <type>point</type>.
    </para>

    <para>
     As funções <function>area</function> operam sobre os tipos
     <type>box</type>, <type>circle</type> e <type>path</type>.
     A função <function>area</function> somente opera sobre o tipo de dado
     <type>path</type> se os pontos em <type>path</type> não se intersectarem.
     Por exemplo, não opera sobre o <type>path</type>
     <literal>'((0,0),(0,1),(2,1),(2,2),(1,2),(1,0),(0,0))'::PATH</literal>,
     entretanto opera sobre o <type>path</type> visualmente idêntico
     <literal>'((0,0),(0,1),(1,1),(1,2),(2,2),(2,1),(1,1),(1,0),(0,0))'::PATH</literal>.
     Se o conceito de <type>path</type> que intersecta e que não intersecta
     estiver confuso, desenhe os dois caminhos acima lado a lado
     em uma folha de papel gráfico.
    </para>

  </sect1>

 <sect1 id="functions-net">
  <title>Funções e operadores para endereço de rede</title>

  <para>
   A <xref linkend="cidr-inet-operators-table"> mostra os operadores
   disponíveis para uso com os tipos <type>cidr</type> e <type>inet</type>.
   Os operadores <literal>&lt;&lt;</literal>,
   <literal>&lt;&lt;=</literal>, <literal>&gt;&gt;</literal> e
   <literal>&gt;&gt;=</literal> testam a inclusão na subrede: somente
   consideram a parte de rede dos dois endereços, ignorando qualquer
   parte de hospedeiro, determinando se a parte de rede é idêntica,
   ou se uma é subrede da outra.
  </para>

    <table id="cidr-inet-operators-table">
     <title>Operadores para os tipos cidr e inet</title>
     <tgroup cols="3">
      <thead>
       <row>
        <entry>Operador</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>menor</entry>
        <entry><literal>inet '192.168.1.5' &lt; inet '192.168.1.6'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>menor ou igual</entry>
        <entry><literal>inet '192.168.1.5' &lt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>igual</entry>
        <entry><literal>inet '192.168.1.5' = inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>maior ou igual</entry>
        <entry><literal>inet '192.168.1.5' &gt;= inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>maior</entry>
        <entry><literal>inet '192.168.1.5' &gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>diferente</entry>
        <entry><literal>inet '192.168.1.5' &lt;&gt; inet '192.168.1.4'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;</literal> </entry>
        <entry>está contido em</entry>
        <entry><literal>inet '192.168.1.5' &lt;&lt; inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&lt;&lt;=</literal> </entry>
        <entry>está contido ou é igual</entry>
        <entry><literal>inet '192.168.1/24' &lt;&lt;= inet '192.168.1/24'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;</literal> </entry>
        <entry>contém</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt; inet '192.168.1.5'</literal></entry>
       </row>
       <row>
        <entry> <literal>&gt;&gt;=</literal> </entry>
        <entry>contém ou é igual</entry>
        <entry><literal>inet '192.168.1/24' &gt;&gt;= inet '192.168.1/24'</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   A <xref linkend="cidr-inet-functions-table"> mostra as funções
   disponíveis para uso com os tipos de dado <type>cidr</type>
   e <type>inet</type>. As funções <function>host()</function>,
   <function>text()</function> e <function>abbrev()</function> se destinam,
   principalmente, a oferecer formatos de exibição alternativos. Um valor texto
   pode ser convertido em <type>inet</type> utilizando a sintaxe normal de
   conversão: <literal>inet(<replaceable>expressão</replaceable>)</literal> ou
   <literal><replaceable>nome_da_coluna</replaceable>::inet</literal>.
  </para>

    <table id="cidr-inet-functions-table">
     <title>Funções para os tipos cidr e inet</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
        <entry>Resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>broadcast</function>(<type>inet</type>)</literal></entry>
        <entry><type>inet</type></entry>
        <entry>endereço de difusão da rede</entry>
        <entry><literal>broadcast('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.255/24</literal></entry>
       </row>
       <row>
        <entry><literal><function>host</function>(<type>inet</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>extrai o endereço de IP como texto</entry>
        <entry><literal>host('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.5</literal></entry>
       </row>
       <row>
        <entry><literal><function>masklen</function>(<type>inet</type>)</literal></entry>
        <entry><type>integer</type></entry>
        <entry>extrai o comprimento da máscara de rede</entry>
        <entry><literal>masklen('192.168.1.5/24')</literal></entry>
        <entry><literal>24</literal></entry>
       </row>
       <row>
        <entry><literal><function>set_masklen</function>(<type>inet</type>, <type>integer</type>)</literal></entry>
        <entry><type>inet</type></entry>
        <entry>define o comprimento da máscara de rede para o valor do tipo <type>inet</type></entry>
        <entry><literal>set_masklen('192.168.1.5/24', 16)</literal></entry>
        <entry><literal>192.168.1.5/16</literal></entry>
       </row>
       <row>
        <entry><literal><function>netmask</function>(<type>inet</type>)</literal></entry>
        <entry><type>inet</type></entry>
        <entry>constrói máscara de rede para a rede</entry>
        <entry><literal>netmask('192.168.1.5/24')</literal></entry>
        <entry><literal>255.255.255.0</literal></entry>
       </row>
       <row>
        <entry><literal><function>hostmask</function>(<type>inet</type>)</literal></entry>
        <entry><type>inet</type></entry>
        <entry>constrói máscara de hospedeiro para a rede</entry>
        <entry><literal>hostmask('192.168.23.20/30')</literal></entry>
        <entry><literal>0.0.0.3</literal></entry>
       </row>
       <row>
        <entry><literal><function>network</function>(<type>inet</type>)</literal></entry>
        <entry><type>cidr</type></entry>
        <entry>extrai do endereço a parte de rede</entry>
        <entry><literal>network('192.168.1.5/24')</literal></entry>
        <entry><literal>192.168.1.0/24</literal></entry>
       </row>
       <row>
        <entry><literal><function>text</function>(<type>inet</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>extrai o endereço de IP e o comprimento da máscara de rede como texto</entry>
        <entry><literal>text(inet '192.168.1.5')</literal></entry>
        <entry><literal>192.168.1.5/32</literal></entry>
       </row>
       <row>
        <entry><literal><function>abbrev</function>(<type>inet</type>)</literal></entry>
        <entry><type>text</type></entry>
        <entry>formato de exibição abreviado como texto</entry>
        <entry><literal>abbrev(cidr '10.1.0.0/16')</literal></entry>
        <entry><literal>10.1/16</literal></entry>
       </row>
       <row>
    <entry><literal><function>family</function>(<type>inet</type>)</literal></entry>
    <entry><type>integer</type></entry>
    <entry>extrai a família de endereços; <literal>4</literal> para IPv4, e
    <literal>6</literal> para IPv6</entry>
    <entry><literal>family('::1')</literal></entry>
    <entry><literal>6</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   A <xref linkend="macaddr-functions-table"> mostra as funções
   disponíveis para uso com o tipo <type>macaddr</type>. A função
   <literal><function>trunc</function>(<type>macaddr</type>)</literal> retorna
   o endereço MAC com os últimos 3 bytes tornados zero, podendo ser utilizado
   para associar o prefixo remanescente com o fabricante. Na distribuição do
   código fonte o diretório <filename>contrib/mac</filename> contém alguns
   utilitários para criar e manter esta tabela de associação.
   <footnote>
    <para>
     A tabela de associação pode ser vista em
     <ulink url="http://standards.ieee.org/regauth/oui/oui.txt"></ulink>
     (N. do T.)
    </para>
   </footnote>
  </para>

    <table id="macaddr-functions-table">
     <title>Funções para o tipo macaddr</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
        <entry>Resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry><literal><function>trunc</function>(<type>macaddr</type>)</literal></entry>
        <entry><type>macaddr</type></entry>
        <entry>torna os 3 últimos bytes iguais a zero</entry>
        <entry><literal>trunc(macaddr '12:34:56:78:90:ab')</literal></entry>
        <entry><literal>12:34:56:00:00:00</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

   <para>
    O tipo <type>macaddr</type> também suporta os operadores relacionais
    padrão (<literal>&gt;</literal>, <literal>&lt;=</literal>, etc.) para a
    ordenação lexicográfica.
   </para>

  </sect1>


 <sect1 id="functions-sequence">
  <title>Funções para manipulação de seqüências</title>

  <indexterm>
   <primary>seqüência</primary>
  </indexterm>
  <indexterm>
   <primary>nextval</primary>
  </indexterm>
  <indexterm>
   <primary>currval</primary>
  </indexterm>
  <indexterm>
   <primary>setval</primary>
  </indexterm>

  <para>
   Esta seção descreve as funções do <productname>PostgreSQL</productname>
   que operam com <firstterm>objetos de seqüência</firstterm>.
   Os objetos de seqüência (também chamados de geradores de seqüência, ou
   simplesmente de seqüências), são tabelas especiais de um única linha criadas
   pelo comando <command>CREATE SEQUENCE</command>. O objeto de seqüência
   é usado normalmente para gerar identificadores únicos para linhas de
   tabelas. As funções de seqüência, listadas na
   <xref linkend="functions-sequence-table">, fornecem métodos simples, seguros
   para multiusuários, para obter valores sucessivos da seqüência a partir dos
   objetos de seqüência.
  </para>

   <table id="functions-sequence-table">
    <title>Funções de seqüência</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Função</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
        <entry><literal><function>nextval</function>(<type>text</type>)</literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Avança a seqüência e retorna o novo valor</entry>
      </row>
      <row>
        <entry><literal><function>currval</function>(<type>text</type>)</literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Retorna o valor obtido mais recentemente por <function>nextval</function></entry>
      </row>
      <row>
        <entry><literal><function>setval</function>(<type>text</type>, <type>bigint</type>)</literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Define o valor corrente da seqüência</entry>
      </row>
      <row>
        <entry><literal><function>setval</function>(<type>text</type>, <type>bigint</type>, <type>boolean</type>)</literal></entry>
        <entry><type>bigint</type></entry>
        <entry>Define o valor corrente da seqüência e o sinalizador <literal>is_called</literal></entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Por motivos históricos, a seqüência a ser operada pela chamada da função
   de seqüência é especificada por um argumento que é um texto em uma cadeia
   de caracteres. Para obter alguma compatibilidade com o tratamento usual dos
   nomes <acronym>SQL</acronym>, a função de seqüência converte as letras do
   argumento em minúsculas, a não ser que a cadeia de caracteres esteja entre
   aspas. Portanto
<screen>
<userinput>nextval('foo')</userinput>      <lineannotation>opera na seqüência <literal>foo</literal></lineannotation>
<userinput>nextval('FOO')</userinput>      <lineannotation>opera na seqüência <literal>foo</literal></lineannotation>
<userinput>nextval('"Foo"')</userinput>    <lineannotation>opera na seqüência <literal>Foo</literal></lineannotation>
</screen>
   Havendo necessidade, o nome da seqüência pode ser qualificado pelo esquema:
<screen>
<userinput>nextval('meu_esquema.foo')</userinput>     <lineannotation>opera em <literal>meu_esquema.foo</literal></lineannotation>
<userinput>nextval('"meu_esquema".foo')</userinput>   <lineannotation>o mesmo acima</lineannotation>
<userinput>nextval('foo')</userinput>                 <lineannotation>procura por <literal>foo</literal> no caminho de procura</lineannotation>
</screen>
   É claro que o texto do argumento pode ser o resultado de uma expressão,
   e não somente um literal simples, o que algumas vezes é útil.
  </para>

  <para>
   As funções de seqüência disponíveis são:

    <variablelist>
     <varlistentry>
      <term><function>nextval</function></term>
      <listitem>
       <para>
        Avança o objeto de seqüência para seu próximo valor e retorna este
        valor. Isto é feito atomicamente: mesmo que várias sessões executem
        <function>nextval</function> simultaneamente, cada uma recebe um valor
        distinto da seqüência com segurança.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>currval</function></term>
      <listitem>
       <para>
        Retorna o valor retornado mais recentemente por
        <function>nextval</function> para esta seqüência na sessão corrente
        (relata erro se <function>nextval</function> nunca tiver sido chamada
        para esta seqüência nesta sessão). Deve ser observado que como é
        retornado o valor da sessão local, uma resposta previsível é obtida
        mesmo que outras sessões tenham executado <function>nextval</function>
        após a sessão corrente tê-lo feito.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><function>setval</function></term>
      <listitem>
       <para>
        Redefine o valor do contador do objeto de seqüência. A forma com dois
        parâmetros define o campo <literal>last_value</literal> (último valor)
        da seqüência com o valor especificado, e define o campo
        <literal>is_called</literal> como <literal>true</literal>, indicando
        que o próximo <function>nextval</function> avançará a seqüência
        antes de retornar o valor. Na forma com três parâmetros,
        <literal>is_called</literal> pode ser definido tanto como
        <literal>true</literal> quanto como <literal>false</literal>.
        Se for definido como <literal>false</literal>, o próximo
        <function>nextval</function> retornará o próprio valor especificado,
        e o avanço da seqüência somente começará no
        <function>nextval</function> seguinte. Por exemplo,

<screen>
<userinput>SELECT setval('foo', 42);</userinput>           <lineannotation>o próximo <function>nextval()</function> retorna 43</lineannotation>
<userinput>SELECT setval('foo', 42, true);</userinput>     <lineannotation>o mesmo acima</lineannotation>
<userinput>SELECT setval('foo', 42, false);</userinput>    <lineannotation>o próximo <function>nextval()</function> retorna 42</lineannotation>
</screen>

        O resultado retornado por <function>setval</function> é simplesmente o
        valor de seu segundo argumento.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
  </para>

  <important>
   <para>
    Para evitar o bloqueio de transações simultâneas que obtêm números de uma
    mesma seqüência, a operação <function>nextval</function> nunca é desfeita
    (<literal>rolled back</literal>); ou seja, após o valor ser obtido este
    passa a ser considerado como tendo sido usado, mesmo que a transação que
    executou o <function>nextval</function> seja interrompida posteriormente.
    Isto significa que as transações interrompidas podem deixar
    <quote>buracos</quote> não utilizados na seqüência de valores atribuídos.
    Além disso, as operações <function>setval</function> nunca são desfeitas,
    também.
   </para>
  </important>

  <para>
   Se o objeto de seqüência tiver sido criado com os parâmetros padrão,
   as chamadas à <function>nextval()</function> retornam valores sucessivos
   começando por um. Outros comportamentos podem ser obtidos utilizando
   parâmetros especiais no comando <xref linkend="SQL-CREATESEQUENCE">; consulte
   a página de referência deste comando para obter informações adicionais.
  </para>

 </sect1>


 <sect1 id="functions-conditional">
  <title>Expressões condicionais</title>

  <indexterm>
   <primary>CASE</primary>
  </indexterm>

  <indexterm>
   <primary>expressão condicional</primary>
  </indexterm>

  <para>
   Esta seção descreve as expressões condicionais em conformidade com o
   <acronym>SQL</acronym> disponíveis no <productname>PostgreSQL</productname>.
  </para>

  <tip>
   <para>
    Havendo alguma necessidade não atendida pelas funcionalidades destas
    expressões condicionais, deve ser considerado o desenvolvimento de um
    procedimento armazenado usando uma linguagem de programação com mais recursos.
   </para>
  </tip>

  <sect2 id="functions-case">
   <title>CASE</title>

  <para>
   A expressão <token>CASE</token> do <acronym>SQL</acronym> é uma expressão
   condicional genérica, semelhante às declarações <literal>if/else</literal>
   de outras linguagens:

<synopsis>
CASE WHEN <replaceable>condição</replaceable> THEN <replaceable>resultado</replaceable>
     <optional>WHEN ...</optional>
     <optional>ELSE <replaceable>resultado</replaceable></optional>
END
</synopsis>

   A cláusula <token>CASE</token> pode ser usada em qualquer lugar onde uma
   expressão for válida. A <replaceable>condição</replaceable> é uma expressão
   que retorna um resultado <type>boolean</type>. Se o resultado for verdade,
   então o valor da expressão <token>CASE</token> é o
   <replaceable>resultado</replaceable> que segue a condição. Se o resultado
   for falso, todas as cláusulas <token>WHEN</token> seguintes são analisadas
   da mesma maneira. Se o resultado de nenhuma <replaceable>condição</replaceable>
   <token>WHEN</token> for verdade, então o valor da expressão <token>CASE</token>
   é o valor do <replaceable>resultado</replaceable> na cláusula
   <token>ELSE</token>. Se a cláusula <token>ELSE</token> for omitida,
   e nenhuma condição for satisfeita, o resultado será nulo.
  </para>

   <para>
    Exemplo:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT * FROM teste;</userinput>

<computeroutput>
 a
---
 1
 2
 3
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT a,</userinput>
<prompt>-&gt;</prompt> <userinput>    CASE WHEN a=1 THEN 'um'</userinput>
<prompt>-&gt;</prompt> <userinput>         WHEN a=2 THEN 'dois'</userinput>
<prompt>-&gt;</prompt> <userinput>         ELSE 'outro'</userinput>
<prompt>-&gt;</prompt> <userinput>    END AS caso</userinput>
<prompt>-&gt;</prompt> <userinput>FROM teste;</userinput>

<computeroutput>
 a | caso
---+-------
 1 | um
 2 | dois
 3 | outro
</computeroutput>
</screen>
   </para>

  <para>
   Os tipos de dado de todas as expressões <replaceable>resultado</replaceable>
   devem ser conversíveis em um único tipo de dado de saída.
   Consulte a <xref linkend="typeconv-union-case"> para obter mais detalhes.
  </para>

  <para>
   A expressão <token>CASE</token> <quote>simplificada</quote>, mostrada abaixo,
   é uma variante especializada da forma geral mostrada acima
   <footnote>
    <para>
     <productname>SQL Server 2000</productname> &mdash;
     Aceita tanto a forma geral quanto a forma simplificada da expressão
     <token>CASE</token>. (N. do T.)
    </para>
   </footnote>
   <footnote>
    <para>
     <productname>Oracle 10g</productname> &mdash;
     Aceita tanto a forma geral quanto a forma simplificada da expressão
     <token>CASE</token>. (N. do T.)
    </para>
   </footnote>
   :

<synopsis>
CASE <replaceable>expressão</replaceable>
    WHEN <replaceable>valor</replaceable> THEN <replaceable>resultado</replaceable>
    <optional>WHEN ...</optional>
    <optional>ELSE <replaceable>resultado</replaceable></optional>
END
</synopsis>

   A <replaceable>expressão</replaceable> é computada e comparada com
   todas as especificações de <replaceable>valor</replaceable> nas cláusulas
   <token>WHEN</token>, até encontrar um que seja igual. Se não for encontrado
   nenhum valor igual, é retornado o <replaceable>resultado</replaceable> na
   cláusula <token>ELSE</token> (ou o valor nulo). Esta forma é
   semelhante à declaração <function>switch</function> da linguagem C.
  </para>

   <para>
    O exemplo mostrado acima pode ser escrito utilizando a sintaxe simplificada
    da expressão <token>CASE</token>:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT a,</userinput>
<prompt>-&gt;</prompt> <userinput>    CASE a WHEN 1 THEN 'um'</userinput>
<prompt>-&gt;</prompt> <userinput>           WHEN 2 THEN 'dois'</userinput>
<prompt>-&gt;</prompt> <userinput>           ELSE 'outro'</userinput>
<prompt>-&gt;</prompt> <userinput>    END AS caso</userinput>
<prompt>-&gt;</prompt> <userinput>FROM teste;</userinput>

<computeroutput>
 a | caso
---+-------
 1 | um
 2 | dois
 3 | outro
</computeroutput>
</screen>
   </para>

   <para>
    A expressão <token>CASE</token> não processa nenhuma subexpressão
    que não seja necessária para determinar o resultado. Por exemplo, esta
    é uma forma possível de evitar o erro gerado pela divisão por zero:
<programlisting>
SELECT ... WHERE CASE WHEN x &lt;&gt; 0 THEN y/x &gt; 1.5 ELSE false END;
</programlisting>
   </para>
  </sect2>

  <sect2 id="functions-coalesce">
   <title>COALESCE</title>

  <indexterm>
   <primary>COALESCE</primary>
  </indexterm>

<synopsis>
<function>COALESCE</function>(<replaceable>valor</replaceable> <optional>, ...</optional>)
</synopsis>

  <para>
   A função <function>COALESCE</function> retorna o primeiro de seus
   argumentos que não for nulo. Só retorna nulo quando todos os seus
   argumentos são nulos. Geralmente é útil para substituir o valor padrão
   quando este é o valor nulo, quando os dados são usados para exibição.
   Por exemplo:
<screen>
<userinput>SELECT coalesce(descrição, descrição_curta, '(nenhuma)') ...</userinput>
</screen>
  </para>

   <para>
    Como a expressão <token>CASE</token>, a função <function>COALESCE</function>
    não processa os argumentos que não são necessários para determinar o
    resultado, ou seja, os argumentos à direita do primeiro argumento que não
    for nulo não são avaliados.
   </para>
  </sect2>

  <sect2 id="functions-nullif">
   <title>NULLIF</title>

  <indexterm>
   <primary>NULLIF</primary>
  </indexterm>

<synopsis>
<function>NULLIF</function>(<replaceable>valor1</replaceable>, <replaceable>valor2</replaceable>)
</synopsis>

  <para>
   A função <function>NULLIF</function> retorna o valor nulo se, e somente se,
   <replaceable>valor1</replaceable> e <replaceable>valor2</replaceable> forem
   iguais. Senão, retorna <replaceable>valor1</replaceable>.
   Pode ser utilizada para realizar a operação inversa do exemplo para
   <function>COALESCE</function> mostrado acima:
<screen>
<userinput>SELECT nullif(valor, '(nenhuma)') ...</userinput>
</screen>
  </para>

  <example id="functions-nullif-example">
   <title>Inserir nulo quando a cadeia de caracteres estiver vazia</title>
   <para>
    Neste exemplo são utilizadas as funções <function>NULLIF</function> e
    <function>TRIM</function> para inserir o valor nulo na coluna da tabela
    quando a cadeia de caracteres passada como parâmetro para o comando
    <command>INSERT</command> preparado estiver vazia ou só contiver espaços.
    <footnote>
     <para>
      Exemplo escrito pelo tradutor, não fazendo parte do manual original.
     </para>
    </footnote>
<screen>
<prompt>=&gt; </prompt><userinput>CREATE TEMPORARY TABLE t (c1 SERIAL PRIMARY KEY, c2 TEXT);</userinput>
<prompt>=&gt; </prompt><userinput>PREPARE inserir (TEXT) AS</userinput>
<prompt>-&gt; </prompt><userinput>    INSERT INTO t VALUES(DEFAULT, nullif(trim(' ' from $1),''));</userinput>
<prompt>=&gt; </prompt><userinput>EXECUTE inserir('linha 1');</userinput>
<prompt>=&gt; </prompt><userinput>EXECUTE inserir('');</userinput>
<prompt>=&gt; </prompt><userinput>EXECUTE inserir('   ');</userinput>
<prompt>=&gt; </prompt><userinput>EXECUTE inserir(NULL);</userinput>
<prompt>=&gt; </prompt><userinput>\pset null (nulo)</userinput>
<prompt>=&gt; </prompt><userinput>SELECT * FROM t;</userinput>
<computeroutput>
 c1 |   c2
----+---------
  1 | linha 1
  2 | (nulo)
  3 | (nulo)
  4 | (nulo)
(4 linhas)
</computeroutput>
</screen>
   </para>
  </example>

  </sect2>

 </sect1>


 <sect1 id="functions-array">
  <title>Funções e operadores para matrizes</title>

  <para>
   A <xref linkend="array-operators-table"> mostra os operadores
   disponíveis para o tipo <type>array</type>.
  </para>

    <table id="array-operators-table">
     <title>Operadores para o tipo array</title>
     <tgroup cols="4">
      <thead>
       <row>
        <entry>Operador</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
        <entry>Resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry> <literal>=</literal> </entry>
        <entry>igual</entry>
        <entry><literal>ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;&gt;</literal> </entry>
        <entry>diferente</entry>
        <entry><literal>ARRAY[1,2,3] &lt;&gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;</literal> </entry>
        <entry>menor</entry>
        <entry><literal>ARRAY[1,2,3] &lt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;</literal> </entry>
        <entry>maior</entry>
        <entry><literal>ARRAY[1,4,3] &gt; ARRAY[1,2,4]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&lt;=</literal> </entry>
        <entry>menor ou igual</entry>
        <entry><literal>ARRAY[1,2,3] &lt;= ARRAY[1,2,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>&gt;=</literal> </entry>
        <entry>maior ou igual</entry>
        <entry><literal>ARRAY[1,4,3] &gt;= ARRAY[1,4,3]</literal></entry>
        <entry><literal>t</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>concatenação de matriz com matriz</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{1,2,3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>concatenação de matriz com matriz</entry>
        <entry><literal>ARRAY[1,2,3] || ARRAY[[4,5,6],[7,8,9]]</literal></entry>
        <entry><literal>{{1,2,3},{4,5,6},{7,8,9}}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>concatenação de elemento com matriz</entry>
        <entry><literal>3 || ARRAY[4,5,6]</literal></entry>
        <entry><literal>{3,4,5,6}</literal></entry>
       </row>

       <row>
        <entry> <literal>||</literal> </entry>
        <entry>concatenação de matriz com elemento</entry>
        <entry><literal>ARRAY[4,5,6] || 7</literal></entry>
        <entry><literal>{4,5,6,7}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  <para>
   Consulte a <xref linkend="arrays"> para obter informações adicionais
   sobre o comportamento dos operadores de matriz.
  </para>

  <para>
   A <xref linkend="array-functions-table"> mostra as funções disponíveis para
   uso com o tipo <type>array</type>. Veja na <xref linkend="arrays">
   uma discussão mais detalhada e exemplos de uso destas funções.
  </para>

    <table id="array-functions-table">
     <title>Funções para o tipo array</title>
     <tgroup cols="5">
      <thead>
       <row>
        <entry>Função</entry>
        <entry>Tipo retornado</entry>
        <entry>Descrição</entry>
        <entry>Exemplo</entry>
        <entry>Resultado</entry>
       </row>
      </thead>
      <tbody>
       <row>
        <entry>
     <literal>
      <function>array_cat</function>
      (<type>anyarray</type>, <type>anyarray</type>)
     </literal>
    </entry>
        <entry><type>anyarray</type></entry>
        <entry>concatena duas matrizes</entry>
        <entry><literal>array_cat(ARRAY[1,2,3], ARRAY[4,5])</literal></entry>
        <entry><literal>{1,2,3,4,5}</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>array_append</function>
      (<type>anyarray</type>, <type>anyelement</type>)
     </literal>
    </entry>
        <entry><type>anyarray</type></entry>
        <entry>anexa um elemento no final de uma matriz</entry>
        <entry><literal>array_append(ARRAY[1,2], 3)</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>array_prepend</function>
      (<type>anyelement</type>, <type>anyarray</type>)
     </literal>
    </entry>
        <entry><type>anyarray</type></entry>
        <entry>anexa um elemento no início de uma matriz</entry>
        <entry><literal>array_prepend(1, ARRAY[2,3])</literal></entry>
        <entry><literal>{1,2,3}</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>array_dims</function>
      (<type>anyarray</type>)
     </literal>
    </entry>
        <entry><type>text</type></entry>
        <entry>retorna a representação textual das dimensões da matriz</entry>
        <entry><literal>array_dims(array[[1,2,3], [4,5,6]])</literal></entry>
        <entry><literal>[1:2][1:3]</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>array_lower</function>
      (<type>anyarray</type>, <type>integer</type>)
     </literal>
    </entry>
        <entry><type>integer</type></entry>
        <entry>retorna o limite inferior da dimensão especificada da matriz</entry>
        <entry><literal>array_lower(array_prepend(0, ARRAY[1,2,3]), 1)</literal></entry>
        <entry><literal>0</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>array_upper</function>
      (<type>anyarray</type>, <type>integer</type>)
     </literal>
    </entry>
        <entry><type>integer</type></entry>
        <entry>retorna o limite superior da dimensão especificada da matriz</entry>
        <entry><literal>array_upper(ARRAY[1,2,3,4], 1)</literal></entry>
        <entry><literal>4</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>array_to_string</function>
      (<type>anyarray</type>, <type>text</type>)
     </literal>
    </entry>
        <entry><type>text</type></entry>
        <entry>concatena os elementos da matriz utilizando o delimitador especificado</entry>
        <entry><literal>array_to_string(array[1, 2, 3], '~^~')</literal></entry>
        <entry><literal>1~^~2~^~3</literal></entry>
       </row>
       <row>
        <entry>
     <literal>
      <function>string_to_array</function>
      (<type>text</type>, <type>text</type>)
     </literal>
    </entry>
        <entry><type>text[]</type></entry>
        <entry>divide uma cadeia de caracteres em elementos de matriz utilizando o delimitador especificado</entry>
        <entry><literal>string_to_array( 'xx~^~yy~^~zz', '~^~')</literal></entry>
        <entry><literal>{xx,yy,zz}</literal></entry>
       </row>
      </tbody>
     </tgroup>
    </table>
  </sect1>

 <sect1 id="functions-aggregate">
  <title>Funções de agregação</title>

  <indexterm zone="functions-aggregate">
   <primary>função de agregação</primary>
   <secondary>nativa</secondary>
  </indexterm>

  <para>
   As <firstterm>funções de agregação</firstterm> retornam um único valor
   como resultado de um conjunto de valores de entrada. A <xref
   linkend="functions-aggregate-table"> mostra as funções de agregação internas.
   As considerações especiais sobre a sintaxe das funções de agregação
   são explicadas na <xref linkend="syntax-aggregates">.
   Consulte a <xref linkend="tutorial-agg"> para obter informações introdutórias
   adicionais.
  </para>

  <table id="functions-aggregate-table">
   <title>Funções de agregação</title>

   <tgroup cols="4">
    <thead>
     <row>
      <entry>Função</entry>
      <entry>Tipo do argumento</entry>
      <entry>Tipo retornado</entry>
      <entry>Descrição</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry>
       <indexterm>
        <primary>média</primary>
       </indexterm>
       <function>avg(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type> ou <type>interval</type>
      </entry>
      <entry>
       <type>numeric</type> para qualquer argumento de tipo inteiro,
       <type>double precision</type> para argumento de tipo ponto flutuante,
       caso contrário o mesmo tipo de dado do argumento
      </entry>
      <entry>a média (média aritmética) de todos os valores de entrada</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_and</primary>
       </indexterm>
       <function>bit_and(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>integer</type>, <type>bigint</type> ou
       <type>bit</type>
      </entry>
      <entry>
        o mesmo tipo de dado do argumento
      </entry>
      <entry>o AND bit a bit de todos os valores de entrada não nulos, ou nulo se algum for nulo</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bit_or</primary>
       </indexterm>
       <function>bit_or(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>integer</type>, <type>bigint</type> ou
       <type>bit</type>
      </entry>
      <entry>
        o mesmo tipo de dado do argumento
      </entry>
      <entry>o OR bit a bit de todos os valores de entrada não nulos, ou nulo se algum for nulo</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_and</primary>
       </indexterm>
       <function>bool_and(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>verdade se todos os valores de entrada forem verdade, senão falso</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>bool_or</primary>
       </indexterm>
       <function>bool_or(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>verdade se ao menos um dos valores de entrada for verdade, senão falso</entry>
     </row>

     <row>
      <entry><function>count(*)</function></entry>
      <entry></entry>
      <entry><type>bigint</type></entry>
      <entry>número de valores de entrada</entry>
     </row>

     <row>
      <entry><function>count(<replaceable class="parameter">expressão</replaceable>)</function></entry>
      <entry>any</entry>
      <entry><type>bigint</type></entry>
      <entry>
       número de valores de entrada para os quais o valor da <replaceable
       class="parameter">expressão</replaceable> não é nulo
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>every</primary>
       </indexterm>
       <function>every(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>
       <type>bool</type>
      </entry>
      <entry>equivale ao <function>bool_and</function></entry>
     </row>

     <row>
      <entry><function>max(<replaceable class="parameter">expressão</replaceable>)</function></entry>
      <entry>qualquer tipo de dado matriz, numérico, cadeia de caracteres, data ou hora</entry>
      <entry>o mesmo tipo de dado do argumento</entry>
      <entry>
       valor máximo da <replaceable class="parameter">expressão</replaceable>
       entre todos os valores de entrada
      </entry>
     </row>

     <row>
      <entry><function>min(<replaceable class="parameter">expressão</replaceable>)</function></entry>
      <entry>qualquer tipo de dado matriz, numérico, cadeia de caracteres, data ou hora</entry>
      <entry>o mesmo tipo de dado do argumento</entry>
      <entry>
       valor mínimo da <replaceable class="parameter">expressão</replaceable>
       entre todos os valores de entrada
      </entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>desvio padrão</primary>
       </indexterm>
       <function>stddev(<replaceable class="parameter">expressão</replaceable>)</function>
      </entry>
      <entry>
       <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type> ou <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> para argumentos de ponto flutuante,
       caso contrário <type>numeric</type>.
      </entry>
      <entry>desvio padrão da amostra dos valores de entrada</entry>
     </row>

     <row>
      <entry><function>sum(<replaceable class="parameter">expressão</replaceable>)</function></entry>
      <entry>
       <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type>, <type>numeric</type> ou
       <type>interval</type>
      </entry>
      <entry>
       <type>bigint</type> para argumentos <type>smallint</type> ou
       <type>integer</type>, <type>numeric</type> para argumentos
       <type>bigint</type>, <type>double precision</type> para argumentos de
       ponto flutuante, caso contrário o mesmo tipo de dado do argumento
      </entry>
      <entry>somatório da <replaceable class="parameter">expressão</replaceable> para todos os valores de entrada</entry>
     </row>

     <row>
      <entry>
       <indexterm>
        <primary>variância</primary>
       </indexterm>
       <function>variance</function>(<replaceable class="parameter">expressão</replaceable>)
      </entry>
      <entry>
       <type>smallint</type>, <type>integer</type>,
       <type>bigint</type>, <type>real</type>, <type>double
       precision</type> ou <type>numeric</type>
      </entry>
      <entry>
       <type>double precision</type> para argumentos de ponto flutuante,
       caso contrário <type>numeric</type>.
      </entry>
      <entry>variância da amostra dos valores de entrada (quadrado do desvio padrão da amostra)</entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Deve ser observado que, com exceção do <function>count</function>,
   estas funções retornam o valor nulo quando nenhuma linha for selecionada. Em
   particular, <function>sum</function> de nenhuma linha retorna nulo, e não
   zero como poderia ser esperado. A função <function>coalesce</function> pode
   ser utilizada para substituir nulo por zero quando for necessário.
  </para>

  <note>
    <indexterm>
      <primary>ANY</primary>
    </indexterm>
    <indexterm>
      <primary>SOME</primary>
    </indexterm>
    <para>
      As agregações booleanas <function>bool_and</function> e
      <function>bool_or</function> correspondem às agregações do padrão SQL
      <function>every</function> e <function>any</function> ou
      <function>some</function>.
      Para <function>any</function> e <function>some</function> parece
      haver uma ambigüidade na sintaxe do padrão:
<programlisting>
SELECT b1 = ANY((SELECT b2 FROM t2 ...)) FROM t1 ...;
</programlisting>
      Neste caso <function>ANY</function> pode ser considerada tanto como
      levando a uma subconsulta quanto a uma agregação, se a expressão de
      seleção retornar 1 linha. Portanto, não pode ser dado o nome padrão a
      estas agregações.
    </para>
  </note>

  <note>
   <para>
    Os usuários acostumados a trabalhar com outros sistemas gerenciadores
    de banco de dados SQL podem ficar surpresos com as características
    de desempenho de certas funções de agregação do
    <productname>PostgreSQL</productname>, quando a agregação é aplicada
    a toda a tabela (em outras palavras, não é especificada nenhuma cláusula
    <literal>WHERE</literal>). Em particular, uma consulta como
<screen>
<userinput>SELECT min(col) FROM alguma_tabela;</userinput>
</screen>
    será executada pelo <productname>PostgreSQL</productname> usando
    a varredura seqüencial de toda a tabela. Outros sistemas de banco de dados
    podem otimizar as consultas deste tipo utilizando um índice na coluna, caso
    esteja disponível. De maneira semelhante, as funções de agregação
    <function>max()</function> e <function>count()</function> sempre
    requerem que seja aplicada uma varredura seqüencial em toda a tabela no
    <productname>PostgreSQL</productname>.
   </para>

   <para>
    O <productname>PostgreSQL</productname> não pode implementar facilmente
    esta otimização, porque também permite consultas em agregações definidas
    pelo usuário. Uma vez que <function>min()</function>,
    <function>max()</function> e <function>count()</function> são
    definidas usando uma API genérica para funções de agregação, não
    há dispositivo para executar casos especiais destas funções
    sob certas circunstâncias.
   </para>

   <para>
    Felizmente existe um recurso simples para contornar os problemas com
    <function>min()</function> e <function>max()</function>. A
    consulta mostrada abaixo é equivalente à consulta acima, exceto que
    tira vantagem de um índice <literal>B-tree</literal>, caso algum
    esteja presente na coluna em questão.
<screen>
<userinput>SELECT col FROM alguma_tabela ORDER BY col ASC LIMIT 1;</userinput>
</screen>
    Pode ser utilizada Uma consulta semelhante (obtida trocando
    <literal>DESC</literal> por <literal>ASC</literal> na consulta acima)
    no lugar de <function>max()</function>).
   </para>

   <para>
    Infelizmente, não existe uma consulta trivial semelhante que possa
    ser utilizada para melhorar o desempenho do <function>count()</function>
    aplicado a toda a tabela.
   </para>
  </note>

 </sect1>


 <sect1 id="functions-subquery">
  <title>Expressões de subconsulta</title>

  <indexterm>
   <primary>EXISTS</primary>
  </indexterm>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <primary>subconsulta</primary>
  </indexterm>

  <para>
   Esta seção descreve as expressões de subconsulta em conformidade com o padrão
   <acronym>SQL</acronym> disponíveis no <productname>PostgreSQL</productname>.
   Todas as formas das expressões documentadas nesta seção retornam
   resultados booleanos (verdade/falso).
  </para>

  <sect2 id="functions-exists">
   <title>EXISTS</title>

<synopsis>
EXISTS ( <replaceable>subconsulta</replaceable> )
</synopsis>

  <para>
   O argumento do <token>EXISTS</token> é uma declaração <command>SELECT</command>
   arbitrária, ou uma <firstterm>subconsulta</firstterm>. A
   subconsulta é processada para determinar se retorna alguma linha.
   Se retornar pelo menos uma linha, o resultado de <token>EXISTS</token> é
   <quote>verdade</quote>; se a subconsulta não retornar nenhuma linha, o
   resultado de <token>EXISTS</token> é <quote>falso</quote>.
  </para>

  <para>
   A subconsulta pode referenciar variáveis da consulta que a envolve,
   que atuam como constantes durante a execução da subconsulta.
  </para>

  <para>
   A subconsulta geralmente só é processada até ser determinado
   se retorna pelo menos uma linha, e não até o fim.
   Não é razoável escrever uma subconsulta que tenha efeitos colaterais (tal
   como chamar uma função de seqüência); pode ser difícil prever se o efeito
   colateral ocorrerá ou não.
  </para>

  <para>
   Como o resultado depende apenas de alguma linha ser retornada,
   e não do conteúdo da linha, normalmente não há interesse na saída
   da subconsulta. Uma convenção de codificação habitual
   é escrever todos os testes de <literal>EXISTS</literal> na forma
   <literal>EXISTS(SELECT 1 WHERE ...)</literal>. Entretanto, existem exceções
   para esta regra, como as subconsultas que utilizam <token>INTERSECT</token>.
  </para>

  <para>
   Este exemplo simples é como uma junção interna em <literal>col2</literal>, mas
   produz no máximo uma linha de saída para cada linha de <literal>tab1</literal>,
   mesmo havendo várias linhas correspondentes em <literal>tab2</literal>:
<screen>
<userinput>
SELECT col1 FROM tab1
    WHERE EXISTS(SELECT 1 FROM tab2 WHERE col2 = tab1.col2);
</userinput>
</screen>
  </para>

    <example id="func-example-case-exists">
     <title>Utilização das cláusulas CASE e EXISTS juntas</title>

     <para>
      Neste exemplo a tabela <classname>frutas</classname> é consultada para
      verificar se o alimento é uma fruta ou não. Caso o alimento conste da
      tabela <classname>frutas</classname> é uma fruta, caso não conste não é
      uma fruta. Abaixo está mostrado o script utilizado para criar e carregar
      as tabelas e executar a consulta.
      <footnote>
       <para>
        Exemplo escrito pelo tradutor, não fazendo parte do manual original.
       </para>
      </footnote>
     </para>

<programlisting>
CREATE TEMPORARY TABLE frutas (id SERIAL PRIMARY KEY, nome TEXT);
INSERT INTO frutas VALUES (DEFAULT, 'banana');
INSERT INTO frutas VALUES (DEFAULT, 'maçã');
CREATE TEMPORARY TABLE alimentos (id SERIAL PRIMARY KEY, nome TEXT);
INSERT INTO alimentos VALUES (DEFAULT, 'maçã');
INSERT INTO alimentos VALUES (DEFAULT, 'espinafre');
SELECT nome, CASE WHEN EXISTS (SELECT nome FROM frutas WHERE nome=a.nome)
                  THEN 'sim'
                  ELSE 'não'
             END AS fruta
FROM alimentos a;
</programlisting>

     <para>
      Abaixo está mostrado o resultado da execução do script.
     </para>
<screen>
<computeroutput>
   nome    | fruta
-----------+-------
 maçã      | sim
 espinafre | não
(2 linhas)
</computeroutput>
</screen>
   </example>
  </sect2>

  <sect2 id="functions-in-subq">
   <title>IN</title>

<synopsis>
<replaceable>expressão</replaceable> IN (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente uma coluna. A expressão à esquerda é processada e comparada com
   cada linha do resultado da subconsulta. O resultado do <token>IN</token> é
   <quote>verdade</quote> se for encontrada uma linha igual na subconsulta.
   O resultado é <quote>falso</quote> se não for encontrada nenhuma linha igual
   (incluindo o caso especial onde a subconsulta não retorna nenhuma linha).
  </para>

  <para>
   Deve ser observado que, se o resultado da expressão à esquerda for nulo,
   ou se não houver nenhum valor igual à direita e uma das linhas à direita
   tiver o valor nulo, o resultado da construção <token>IN</token> será nulo,
   e não falso. Isto está de acordo com as regras normais do SQL para
   combinações booleanas de valores nulos.
  </para>

  <para>
   Da mesma forma que no <token>EXISTS</token>, não é razoável assumir que a
   subconsulta será processada até o fim.
  </para>

<synopsis>
<replaceable>construtor_de_linha</replaceable> IN (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado esquerdo desta forma do <token>IN</token> é um construtor de linha,
   conforme descrito na <xref linkend="sql-syntax-row-constructors">.
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente tantas colunas quantas forem as expressões na linha do lado
   esquerdo. As expressões do lado esquerdo são processadas e comparadas, por
   toda a largura, com cada linha do resultado da subconsulta.
   O resultado do <token>IN</token> é <quote>verdade</quote> se for encontrada
   uma linha igual na subconsulta. O resultado é <quote>falso</quote> se não
   for encontrada nenhuma linha igual (incluindo o caso especial onde a
   subconsulta não retorna nenhuma linha).
  </para>

  <para>
   Da maneira usual, os valores nulos nas linhas são combinados de acordo com
   com as regras normais para expressões booleana do SQL.
   As linhas são consideradas iguais se todos os seus membros correspondentes
   forem não-nulos e iguais; as linhas são diferentes se algum membro
   correspondente for não-nulo e diferente; senão o resultado da comparação é
   desconhecido (nulo). Se o resultado de todas as linhas for diferente ou nulo,
   com pelo menos um nulo, o resultado do <token>IN</token> será nulo.
  </para>

    <example id="func-example-case-in">
     <title>Utilização das cláusulas CASE e IN juntas</title>

     <para>
      Este exemplo é idêntico ao <xref linkend="func-example-case-exists">, só
      que utiliza a cláusula <token>IN</token> para executar a consulta,
      conforme mostrado abaixo.
      <footnote>
       <para>
        Exemplo escrito pelo tradutor, não fazendo parte do manual original.
       </para>
      </footnote>
     </para>

<programlisting>
SELECT nome, CASE WHEN nome IN (SELECT nome FROM frutas)
                  THEN 'sim'
                  ELSE 'não'
             END AS fruta
FROM alimentos;
</programlisting>

     <para>
      Abaixo está mostrado o resultado da execução do script.
     </para>
<screen>
<computeroutput>
   nome    | fruta
-----------+-------
 maçã      | sim
 espinafre | não
(2 linhas)
</computeroutput>
</screen>
   </example>
  </sect2>

  <sect2 id="functions-not-in-subq">
   <title>NOT IN</title>

<synopsis>
<replaceable>expressão</replaceable> NOT IN (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente uma coluna. A expressão à esquerda é processada e comparada com
   cada linha do resultado da subconsulta. O resultado de <token>NOT IN</token>
   é <quote>verdade</quote> se somente forem encontradas linhas diferentes na
   subconsulta (incluindo o caso especial onde a subconsulta não retorna nenhuma
   linha). O resultado é <quote>falso</quote> se for encontrada alguma linha igual.
  </para>

  <para>
   Deve ser observado que se o resultado da expressão à esquerda for nulo,
   ou se não houver nenhum valor igual à direita e uma das linhas à direita
   tiver o valor nulo, o resultado da construção <token>NOT IN</token> será
   nulo, e não verdade. Isto está de acordo com as regras normais do SQL para
   combinações booleanas de valores nulos.
  </para>

  <para>
   Da mesma forma que no <token>EXISTS</token>, não é razoável assumir que a
   subconsulta será processada até o fim.
  </para>

<synopsis>
<replaceable>construtor_de_linha</replaceable> NOT IN (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado esquerdo desta forma do <token>NOT IN</token> é um construtor de
   linha, conforme descrito na <xref linkend="sql-syntax-row-constructors">.
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente tantas colunas quantas forem as expressões na linha do lado
   esquerdo. As expressões do lado esquerdo são processadas e comparadas, por
   toda a largura, com cada linha do resultado da subconsulta.
   O resultado do <token>NOT IN</token> é <quote>verdade</quote> se somente
   forem encontradas linhas diferentes na subconsulta (incluindo o caso especial
   onde a subconsulta não retorna nenhuma linha).
   O resultado é <quote>falso</quote> se for encontrada alguma linha igual.
  </para>

  <para>
   Da maneira usual, os valores nulos nas linhas são combinados de acordo com
   com as regras normais para expressões booleana do SQL.
   As linhas são consideradas iguais se todos os seus membros correspondentes
   forem não-nulos e iguais; as linhas são diferentes se algum membro
   correspondente for não-nulo e diferente; senão o resultado da comparação é
   desconhecido (nulo). Se o resultado de todas as linhas for diferente ou nulo,
   com pelo menos um nulo, o resultado do <token>NOT IN</token> será nulo.
  </para>
  </sect2>

  <sect2 id="functions-any-some-subq">
   <title>ANY/SOME</title>

<synopsis>
<replaceable>expressão</replaceable> <replaceable>operador</replaceable> ANY (<replaceable>subconsulta</replaceable>)
<replaceable>expressão</replaceable> <replaceable>operador</replaceable> SOME (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente uma coluna. A expressão à esquerda é processada e comparada com
   cada linha do resultado da subconsulta usando o
   <replaceable>operador</replaceable> especificado, devendo produzir um
   resultado booleano.
   O resultado do <token>ANY</token> é <quote>verdade</quote>
   se for obtido algum resultado verdade.
   O resultado é <quote>falso</quote> se nenhum resultado verdade for encontrado
   (incluindo o caso especial onde a subconsulta não retorna nenhuma linha).
   <footnote>
    <para>
     <productname>SQL Server 2000</productname> &mdash;
     <literal><token>SOME</token> | <token>ANY</token></literal> comparam um
     valor escalar com o conjunto de valores de uma única coluna.
     Sintaxe: <literal><replaceable>expressão_escalar</replaceable>
     { = | &lt; &gt; | ! = | &gt; | &gt; = | ! &gt; | &lt; | &lt; = | ! &lt; }
     { <token>SOME</token> | <token>ANY</token> } ( subconsulta )</literal>.
     A subconsulta possui o conjunto de resultados de uma coluna, e o mesmo tipo
     de dado da expressão escalar.
     <token>SOME</token> e <token>ANY</token> retornam verdade quando a
     comparação especificada é verdade para qualquer par
     (<replaceable>expressão_escalar</replaceable>, x), onde x é um valor do
     conjunto de uma única coluna. Senão retorna falso.
     <ulink url="http://msdn.microsoft.com/library/en-us/tsqlref/ts_setu-sus_17jt.asp">
     SOME | ANY</ulink> (N. do T.)
    </para>
   </footnote>
  </para>

  <para>
   <token>SOME</token> é sinônimo de <token>ANY</token>.
   <token>IN</token> equivale a <literal>= ANY</literal>.
  </para>

  <para>
   Deve ser observado que se não houver nenhuma comparação bem sucedida,
   e pelo menos uma linha da direita gerar nulo como resultado do operador,
   o resultado da construção <token>ANY</token> será nulo, e não falso.
   Isto está de acordo com as regras normais do SQL para combinações
   booleanas de valores nulos.
  </para>

  <para>
   Do mesmo modo que no <token>EXISTS</token>, não é razoável supor
   que a subconsulta será processada até o fim.
  </para>

<synopsis>
<replaceable>construtor_de_linha</replaceable> <replaceable>operador</replaceable> ANY (<replaceable>subconsulta</replaceable>)
<replaceable>construtor_de_linha</replaceable> <replaceable>operador</replaceable> SOME (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado esquerdo desta forma do <token>ANY</token> é um construtor de
   linha, conforme descrito na <xref linkend="sql-syntax-row-constructors">.
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente tantas colunas quantas forem as expressões existentes na linha do
   lado esquerdo.
   As expressões do lado esquerdo são processadas e comparadas, por toda a
   largura, com cada linha do resultado da subconsulta utilizando o
   <replaceable>operador</replaceable> especificado.
   Atualmente, somente são permitidos os operadores <literal>=</literal> e
   <literal>&lt;&gt;</literal> em construções <token>ANY</token> para toda a
   largura da linha.
   O resultado do <token>ANY</token> é <quote>verdade</quote> se for encontrada
   alguma linha igual ou diferente, respectivamente. O resultado será
   <quote>falso</quote> se não for encontrada nenhuma linha deste tipo
   (incluindo o caso especial onde a subconsulta não retorna nenhuma linha).
  </para>

  <para>
   Da maneira usual, os valores nulos nas linhas são combinados de acordo com
   com as regras normais para expressões booleana do SQL.
   As linhas são consideradas iguais se todos os seus membros correspondentes
   forem não-nulos e iguais; as linhas são diferentes se algum membro
   correspondente for não-nulo e diferente; senão o resultado da comparação é
   desconhecido (nulo).
   Se houver pelo menos um resultado de linha nulo, então o resultado de
   <token>ANY</token> não poderá ser falso; será verdade ou nulo.
  </para>

    <example id="func-example-case-any">
     <title>Utilização das cláusulas CASE e ANY juntas</title>

     <para>
      Este exemplo é idêntico ao <xref linkend="func-example-case-exists">, só
      que utiliza a cláusula <token>ANY</token> para executar a consulta,
      conforme mostrado abaixo.
      <footnote>
       <para>
        Exemplo escrito pelo tradutor, não fazendo parte do manual original.
       </para>
      </footnote>
     </para>

<programlisting>
SELECT nome, CASE WHEN nome = ANY (SELECT nome FROM frutas)
                  THEN 'sim'
                  ELSE 'não'
             END AS fruta
FROM alimentos;
</programlisting>

     <para>
      Abaixo está mostrado o resultado da execução do script.
     </para>
<screen>
<computeroutput>
   nome    | fruta
-----------+-------
 maçã      | sim
 espinafre | não
(2 linhas)
</computeroutput>
</screen>
   </example>
  </sect2>

  <sect2 id="functions-all-subq">
   <title>ALL</title>

<synopsis>
<replaceable>expressão</replaceable> <replaceable>operador</replaceable> ALL (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente uma coluna. A expressão à esquerda é processada e comparada com
   cada linha do resultado da subconsulta usando o
   <replaceable>operador</replaceable> especificado, devendo produzir um
   resultado booleano. O resultado do <token>ALL</token> é
   <quote>verdade</quote> se o resultado de todas as linhas for verdade
   (incluindo o caso especial onde a subconsulta não retorna nenhuma linha).
   O resultado é <quote>falso</quote> se for encontrado algum resultado falso.
  </para>

  <para>
   <token>NOT IN</token> equivale a <literal>&lt;&gt; ALL</literal>.
  </para>

  <para>
   Deve ser observado que se todas as comparações forem bem-sucedidas,
   mas pelo menos uma linha da direita gerar nulo como resultado do operador,
   o resultado da construção <token>ALL</token> será nulo, e não verdade.
   Isto está de acordo com as regras normais do SQL para combinações
   booleanas de valores nulos.
  </para>

  <para>
   Do mesmo modo que no <token>EXISTS</token>, não é razoável supor
   que a subconsulta será processada até o fim.
  </para>

<synopsis>
<replaceable>construtor_de_linha</replaceable> <replaceable>operador</replaceable> ALL (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado esquerdo desta forma do <token>ALL</token> é um construtor de
   linha, conforme descrito na <xref linkend="sql-syntax-row-constructors">.
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente tantas colunas quantas forem as expressões existentes na linha do
   lado esquerdo.
   As expressões do lado esquerdo são processadas e comparadas, por toda a
   largura, com cada linha do resultado da subconsulta utilizando o
   <replaceable>operador</replaceable> especificado.
   Atualmente, somente são permitidos os operadores <literal>=</literal> e
   <literal>&lt;&gt;</literal> em construções <token>ALL</token> para toda a
   largura da linha.
   O resultado do <token>ALL</token> é <quote>verdade</quote> se todas as linhas
   da subconsulta forem iguais ou diferentes, respectivamente (incluindo o caso
   especial onde a subconsulta não retorna nenhuma linha). O resultado será
   <quote>falso</quote> se não for encontrada nenhuma linha que seja igual
   ou diferente, respectivamente.
  </para>

  <para>
   Da maneira usual, os valores nulos nas linhas são combinados de acordo com
   com as regras normais para expressões booleana do SQL.
   As linhas são consideradas iguais se todos os seus membros correspondentes
   forem não-nulos e iguais; as linhas são diferentes se algum membro
   correspondente for não-nulo e diferente; senão o resultado da comparação é
   desconhecido (nulo).
   Se houver pelo menos um resultado de linha nulo, então o resultado de
   <token>ALL</token> não poderá ser verdade; será falso ou nulo.
  </para>
  </sect2>

  <sect2 id="functions-line-comparison-subq">
   <title>Comparação de toda a linha</title>

   <indexterm zone="functions-subquery">
    <primary>comparação</primary>
    <secondary>linha de resultado da subconsulta</secondary>
   </indexterm>

<synopsis>
<replaceable>construtor_de_linha</replaceable> <replaceable>operador</replaceable> (<replaceable>subconsulta</replaceable>)
</synopsis>

  <para>
   O lado esquerdo é um construtor de linha, conforme descrito na
   <xref linkend="sql-syntax-row-constructors">.
   O lado direito é uma subconsulta entre parênteses, que deve retornar
   exatamente tantas colunas quantas forem as expressões existentes na linha do
   lado esquerdo.
   Além disso, a subconsulta não pode retornar mais de uma linha
   (se não retornar nenhuma linha o resultado será considerado nulo).
   As expressões do lado esquerdo são processadas e comparadas, por toda a
   largura, com cada linha do resultado da subconsulta.
   Atualmente, somente são permitidos os operadores <literal>=</literal> e
   <literal>&lt;&gt;</literal> para comparação por toda a largura da linha.
   O resultado é <quote>verdade</quote> se as duas linhas forem iguais ou
   diferentes, respectivamente
  </para>

  <para>
   Da maneira usual, os valores nulos nas linhas são combinados de acordo com
   com as regras normais para expressões booleana do SQL.
   As linhas são consideradas iguais se todos os seus membros correspondentes
   forem não-nulos e iguais; as linhas são diferentes se algum membro
   correspondente for não-nulo e diferente; senão o resultado da comparação é
   desconhecido (nulo).
  </para>
  </sect2>
 </sect1>


 <sect1 id="functions-comparisons">
  <title>Comparações de linha e de matriz</title>

  <indexterm>
   <primary>IN</primary>
  </indexterm>

  <indexterm>
   <primary>NOT IN</primary>
  </indexterm>

  <indexterm>
   <primary>ANY</primary>
  </indexterm>

  <indexterm>
   <primary>ALL</primary>
  </indexterm>

  <indexterm>
   <primary>SOME</primary>
  </indexterm>

  <indexterm>
   <primary>comparação</primary>
   <secondary>toda a linha</secondary>
  </indexterm>

  <indexterm>
   <primary>IS DISTINCT FROM</primary>
  </indexterm>

  <indexterm>
   <primary>IS NULL</primary>
  </indexterm>

  <indexterm>
   <primary>IS NOT NULL</primary>
  </indexterm>

  <para>
   Esta seção descreve várias construções especializadas para fazer
   comparações múltiplas entre grupos de valores. Estas formas são
   relacionadas sintaticamente com as formas das subconsultas da
   seção anterior, mas não envolvem subconsultas.
   As formas envolvendo subexpressões de matrizes são
   extensões do <productname>PostgreSQL</productname>; o restante
   está em conformidade com o padrão <acronym>SQL</acronym>.
   Todas a formas de expressão documentadas nesta seção retornam
   resultados booleanos (verdade/falso).
  </para>

  <sect2 id="functions-in">
   <title>IN</title>

<synopsis>
<replaceable>expressão</replaceable> IN (<replaceable>valor</replaceable><optional>, ...</optional>)
</synopsis>

  <para>
   O lado direito é uma lista de expressões escalares entre parênteses.
   O resultado é <quote>verdade</quote> se o resultado da expressão
   à esquerda for igual a qualquer uma das expressões à direita. Esta é uma
   notação abreviada de

<synopsis>
<replaceable>expressão</replaceable> = <replaceable>valor1</replaceable>
OR
<replaceable>expressão</replaceable> = <replaceable>valor2</replaceable>
OR
...
</synopsis>
  </para>

  <para>
   Deve ser observado que se o resultado da expressão do lado esquerdo for nulo,
   ou se não houver valor igual do lado direito e pelo menos uma expressão do
   lado direito tiver resultado nulo, o resultado da construção <token>IN</token>
   será nulo, e não falso. Isto está de acordo com as regras normais do SQL
   para combinações booleanas de valores nulos.
  </para>
  </sect2>

  <sect2 id="functions-not-in">
   <title>NOT IN</title>

<synopsis>
<replaceable>expressão</replaceable> NOT IN (<replaceable>valor</replaceable><optional>, ...</optional>)
</synopsis>

  <para>
   O lado direito é uma lista de expressões escalares entre parênteses.
   O resultado é <quote>verdade</quote> se o resultado da expressão
   à esquerda for diferente do resultado de todas as expressões à direita.
   Esta é uma notação abreviada de

<synopsis>
<replaceable>expressão</replaceable> &lt;&gt; <replaceable>valor1</replaceable>
AND
<replaceable>expressão</replaceable> &lt;&gt; <replaceable>valor2</replaceable>
AND
...
</synopsis>
  </para>

  <para>
   Deve ser observado que se o resultado da expressão do lado esquerdo for nulo,
   ou se não houver valor igual do lado direito e pelo menos uma expressão do
   lado direito tiver resultado nulo, o resultado da construção
   <token>NOT IN</token> será nulo, e não verdade. Isto está de acordo com as
   regras normais do SQL para combinações booleanas de valores nulos.
  </para>

  <tip>
  <para>
   <literal>x NOT IN y</literal> equivale a <literal>NOT (x IN y)</literal>
   para todos os casos. Entretanto, os valores nulos tem muito mais facilidade
   de confundir uma pessoa inexperiente trabalhando com <token>NOT IN</token>
   do que trabalhando com <token>IN</token>.
   É melhor expressar a condição na forma positiva se for possível.
  </para>
  </tip>
  </sect2>

  <sect2 id="functions-any-some-matrix">
   <title>ANY/SOME (matriz)</title>

<synopsis>
<replaceable>expressão</replaceable> <replaceable>operador</replaceable> ANY (<replaceable>expressão_de_matriz</replaceable>)
<replaceable>expressão</replaceable> <replaceable>operador</replaceable> SOME (<replaceable>expressão_de_matriz</replaceable>)
</synopsis>

  <para>
   O lado direito é uma expressão entre parênteses, que deve produzir um valor
   matriz. A expressão do lado esquerdo é processada e comparada com cada
   elemento da matriz utilizando o <replaceable>operador</replaceable>
   especificado, que deve produzir um resultado booleano.
   O resultado de <token>ANY</token> é <quote>verdade</quote> se for obtido
   algum resultado verdade.
   O resultado é <quote>falso</quote> se não for obtido nenhum resultado verdade
   (incluindo o caso especial onde a matriz possui zero elementos).
  </para>

  <para>
   <token>SOME</token> é sinônimo de <token>ANY</token>.
  </para>
  </sect2>

  <sect2 id="functions-all-matrix">
   <title>ALL (matriz)</title>

<synopsis>
<replaceable>expressão</replaceable> <replaceable>operador</replaceable> ALL (<replaceable>expressão_de_matriz</replaceable>)
</synopsis>

  <para>
   O lado direito é uma expressão entre parênteses, que deve produzir um valor
   matriz. A expressão do lado esquerdo é processada e comparada com cada
   elemento da matriz utilizando o <replaceable>operador</replaceable>
   especificado, que deve produzir um resultado booleano.
   O resultado de <token>ALL</token> é <quote>verdade</quote> se o resultado de
   todas as comparações for verdade (incluindo o caso especial onde a matriz
   possui zero elementos).
   O resultado é <quote>falso</quote> se for encontrado algum resultado falso.
  </para>
  </sect2>

  <sect2 id="functions-comparison-line-width">
   <title>Comparação por toda a largura da linha</title>

<synopsis>
<replaceable>construtor_de_linha</replaceable> <replaceable>operador</replaceable> <replaceable>construtor_de_linha</replaceable>
</synopsis>

  <para>
   Cada um dos lados é um construtor de linha, conforme descrito na
   <xref linkend="sql-syntax-row-constructors">.
   Os valores das duas linhas devem possuir o mesmo número de campos.
   Cada lado é avaliado e depois comparados por toda a largura da linha.
   Atualmente, somente são permitidos os operadores <literal>=</literal> e
   <literal>&lt;&gt;</literal> para comparação por toda a largura da linha.
   O resultado é <quote>verdade</quote> se as duas linhas forem iguais ou
   diferentes, respectivamente
  </para>

  <para>
   Da maneira usual, os valores nulos nas linhas são combinados de acordo com
   com as regras normais para expressões booleana do SQL.
   As linhas são consideradas iguais se todos os seus membros correspondentes
   forem não-nulos e iguais; as linhas são diferentes se algum membro
   correspondente for não-nulo e diferente; senão o resultado da comparação é
   desconhecido (nulo).
  </para>

<synopsis>
<replaceable>construtor_de_linha</replaceable> IS DISTINCT FROM <replaceable>construtor_de_linha</replaceable>
</synopsis>

  <para>
   Esta construção é semelhante à comparação de linha <literal>&lt;&gt;</literal>,
   mas não retorna nulo para entradas nulas. Em vez disso, todos os valores
   nulos são considerados diferentes (distinto de) todos os valores não-nulos,
   e dois valores nulos são considerados iguais (não distintos).
   Portanto, o resultado será sempre verdade ou falso, e nunca nulo.
  </para>

<synopsis>
<replaceable>construtor_de_linha</replaceable> IS NULL
<replaceable>construtor_de_linha</replaceable> IS NOT NULL
</synopsis>

  <para>
   Estas construções testam um valor de linha para nulo e não nulo. Um valor de
   linha é considerado não-nulo se tiver pelo menos um campo que não seja nulo.
  </para>

  </sect2>
 </sect1>

 <sect1 id="functions-srf">
  <title>Funções que retornam conjunto</title>

  <indexterm zone="functions-srf">
   <primary>funções que retornam conjunto</primary>
   <secondary>funções</secondary>
  </indexterm>

  <para>
   Esta seção descreve as funções que têm possibilidade de retornar mais de uma
   linha. Atualmente as únicas funções nesta classe são as funções geradoras de
   séries, conforme detalhado na <xref linkend="functions-srf-series">.
  </para>

  <table id="functions-srf-series">
   <title>Funções geradoras de séries</title>
   <tgroup cols="4">
    <thead>
     <row>
      <entry>Função</entry>
      <entry>Tipo do argumento</entry>
      <entry>Tipo retornado</entry>
      <entry>Descrição</entry>
     </row>
    </thead>

    <tbody>
     <row>
      <entry><literal><function>generate_series</function>(<parameter>início</parameter>, <parameter>fim</parameter>)</literal></entry>
      <entry><type>int</type> ou <type>bigint</type></entry>
      <entry><type>setof int</type> ou <type>setof bigint</type> (o mesmo tipo do argumento)</entry>
      <entry>
       Gera uma série de valores, do <parameter>início</parameter> ao
       <parameter>fim</parameter>, com tamanho do passo igual a um.
      </entry>
     </row>

     <row>
      <entry><literal><function>generate_series</function>(<parameter>início</parameter>, <parameter>fim</parameter>, <parameter>passo</parameter>)</literal></entry>
      <entry><type>int</type> ou <type>bigint</type></entry>
      <entry><type>setof int</type> ou <type>setof bigint</type> (o mesmo tipo do argumento)</entry>
      <entry>
       Gera uma série de valores, do <parameter>início</parameter> ao
       <parameter>fim</parameter>, com tamanho do passo igual a
       <parameter>passo</parameter>.
      </entry>
     </row>

    </tbody>
   </tgroup>
  </table>

  <para>
   Quando o <parameter>passo</parameter> é positivo, são retornadas zero linhas
   se o <parameter>início</parameter> for maior que o <parameter>fim</parameter>.
   Inversamente, quando o <parameter>passo</parameter> é negativo são retornadas
   zero linhas se o <parameter>início</parameter> for menor que o
   <parameter>fim</parameter>.
   Também são retornadas zero linhas para entradas <literal>NULL</literal>.
   É errado o <parameter>passo</parameter> ser igual a zero. Alguns exemplos:
<screen>
<prompt>=&gt;</prompt> <userinput>select * from generate_series(2,4);</userinput>

<computeroutput>
 generate_series
-----------------
               2
               3
               4
(3 linhas)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>select * from generate_series(5,1,-2);</userinput>

<computeroutput>
 generate_series
-----------------
               5
               3
               1
(3 linhas)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>select * from generate_series(4,3);</userinput>

<computeroutput>
 generate_series
-----------------
(0 linhas)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>select current_date + s.a as dates from generate_series(0,14,7) as s(a);</userinput>

<computeroutput>
   dates
------------
 2004-02-05
 2004-02-12
 2004-02-19
(3 linhas)
</computeroutput>
</screen>
  </para>
 </sect1>

 <sect1 id="functions-info">
  <title>Funções de informação do sistema</title>

  <para>
   A <xref linkend="functions-info-session-table"> mostra várias
   funções para extrair informações da sessão e do sistema.
  </para>

   <table id="functions-info-session-table">
    <title>Funções de informação da sessão</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><function>current_database()</function></entry>
       <entry><type>name</type></entry>
       <entry>nome do banco de dados corrente</entry>
      </row>

      <row>
       <entry><function>current_schema()</function></entry>
       <entry><type>name</type></entry>
       <entry>nome do esquema corrente</entry>
      </row>

      <row>
       <entry><function>current_schemas(boolean)</function></entry>
       <entry><type>name[]</type></entry>
       <entry>
        nomes dos esquemas no caminho de procura incluindo, opcionalmente,
        os esquemas implícitos
       </entry>
      </row>

      <row>
       <entry><function>current_user</function></entry>
       <entry><type>name</type></entry>
       <entry>nome do usuário do contexto de execução corrente</entry>
      </row>

      <row>
       <entry><function>inet_client_addr()</function></entry>
       <entry><type>inet</type></entry>
       <entry>endereço da conexão remota</entry>
      </row>

      <row>
       <entry><function>inet_client_port()</function></entry>
       <entry><type>int4</type></entry>
       <entry>porta da conexão remota</entry>
      </row>

      <row>
       <entry><function>inet_server_addr()</function></entry>
       <entry><type>inet</type></entry>
       <entry>endereço da conexão local</entry>
      </row>

      <row>
       <entry><function>inet_server_port()</function></entry>
       <entry><type>int4</type></entry>
       <entry>port da conexão local</entry>
      </row>

      <row>
       <entry><function>session_user</function></entry>
       <entry><type>name</type></entry>
       <entry>nome do usuário da sessão</entry>
      </row>

      <row>
       <entry><function>user</function></entry>
       <entry><type>name</type></entry>
       <entry>equivale a <function>current_user</function></entry>
      </row>

      <row>
       <entry><function>version()</function></entry>
       <entry><type>text</type></entry>
       <entry>informação da versão do PostgreSQL</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm zone="functions-info">
    <primary>usuário</primary>
    <secondary>corrente</secondary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>esquema</primary>
    <secondary>corrente</secondary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>caminho de procura</primary>
    <secondary>corrente</secondary>
   </indexterm>

   <para>
    A função <function>session_user</function> normalmente retorna o usuário que
    iniciou a conexão com o banco de dados corrente; mas os superusuários podem
    mudar esta definição através de
    <xref linkend="sql-set-session-authorization">.
    A função <function>current_user</function> retorna o identificador do
    usuário utilizado na verificação de permissão. Normalmente é igual ao
    usuário da sessão, mas muda durante a execução das funções
    com o atributo <literal>SECURITY DEFINER</literal>.
    Na terminologia Unix o usuário da sessão é o <quote>usuário real</quote>,
    enquanto o usuário corrente é o <quote>usuário efetivo</quote>.
   </para>

   <note>
    <para>
     As funções <function>current_user</function>,
     <function>session_user</function> e <function>user</function> possuem
     status sintático especial no <acronym>SQL</acronym>: devem ser chamadas
     sem parênteses no final.
    </para>
   </note>

   <para>
    A função <function>current_schema</function> retorna o nome do esquema que
    está à frente do caminho de procura (ou o valor nulo, se o caminho de
    procura estiver vazio). Este é o esquema utilizado na criação de qualquer
    tabela, ou outro objeto nomeado, sem especificar o esquema a ser utilizado.
    A função <function>current_schemas(boolean)</function> retorna uma matriz
    contendo os nomes de todos os esquemas presentes no caminho de procura. A
    opção booleana determina se os esquemas do sistema incluídos implicitamente,
    tal como <literal>pg_catalog</literal>, serão incluídos no caminho de
    procura retornado.
   </para>

   <note>
    <para>
     O caminho de procura pode ser alterado em tempo de execução. O comando é:
<screen>
<userinput>SET search_path TO <replaceable>esquema</replaceable> <optional>, <replaceable>esquema</replaceable>, ...</optional></userinput>
</screen>
    </para>
   </note>

   <indexterm zone="functions-info">
    <primary>inet_client_addr</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>inet_client_port</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>inet_server_addr</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>inet_server_port</primary>
   </indexterm>

   <para>
     A função <function>inet_client_addr</function> retorna o endereço de IP do
     cliente corrente, e a função <function>inet_client_port</function> retorna
     o número da porta.
     A função <function>inet_server_addr</function> retorna o endereço de IP do
     servidor de destino da conexão corrente, e a função
     <function>inet_server_port</function> retorna o número da porta.
     Todas estas funções retornam NULL se a conexão corrente for através
     de um soquete do domínio Unix.
   </para>

   <indexterm zone="functions-info">
    <primary>versão</primary>
   </indexterm>

   <para>
    A função <function>version()</function> retorna uma cadeia de caracteres
    descrevendo a versão do servidor <productname>PostgreSQL</productname>.
   </para>

  <indexterm>
   <primary>privilégio</primary>
   <secondary>consulta</secondary>
  </indexterm>

  <para>
   A <xref linkend="functions-info-access-table"> mostra as funções que permitem
   o usuário consultar os privilégios de acesso dos objetos através de programa.
   Consulte a <xref linkend="ddl-priv"> para obter informações adicionais sobre
   privilégios.
  </para>

   <table id="functions-info-access-table">
    <title>Funções de consulta a privilégios de acesso</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>has_table_privilege</function> (<parameter>usuário</parameter>,
                                  <parameter>tabela</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário possui o privilégio para a tabela</entry>
      </row>
      <row>
       <entry><literal><function>has_table_privilege</function> (<parameter>tabela</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário corrente possui o privilégio para a tabela</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function> (<parameter>usuário</parameter>,
                                  <parameter>banco_de_dados</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário possui o privilégio para o banco de dados</entry>
      </row>
      <row>
       <entry><literal><function>has_database_privilege</function> (<parameter>banco_de_dados</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário corrente possui o privilégio para o banco de dados</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function> (<parameter>usuário</parameter>,
                                  <parameter>função</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário possui o privilégio para a função</entry>
      </row>
      <row>
       <entry><literal><function>has_function_privilege</function> (<parameter>função</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário corrente possui o privilégio para a função</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function> (<parameter>usuário</parameter>,
                                  <parameter>linguagem</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário possui o privilégio para a linguagem</entry>
      </row>
      <row>
       <entry><literal><function>has_language_privilege</function> (<parameter>linguagem</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário corrente possui o privilégio para a linguagem</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function> (<parameter>usuário</parameter>,
                                  <parameter>esquema</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário possui o privilégio para o esquema</entry>
      </row>
      <row>
       <entry><literal><function>has_schema_privilege</function> (<parameter>esquema</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário corrente possui o privilégio para o esquema</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function> (<parameter>usuário</parameter>,
                                  <parameter>espaço_de_tabelas</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário possui o privilégio para o espaço de tabelas</entry>
      </row>
      <row>
       <entry><literal><function>has_tablespace_privilege</function> (<parameter>espaço_de_tabelas</parameter>,
                                  <parameter>privilégio</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o usuário corrente possui o privilégio para o espaço de tabelas</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm zone="functions-info">
    <primary>has_table_privilege</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>has_database_privilege</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>has_function_privilege</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>has_language_privilege</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>has_schema_privilege</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>has_tablespace_privilege</primary>
   </indexterm>

   <para>
    A função <function>has_table_privilege</function> verifica se o usuário
    pode acessar a tabela de uma determinada maneira. O usuário pode ser
    especificado pelo nome ou pelo ID (<literal>pg_user.usesysid</literal>)
    ou, se o argumento for omitido, é assumido <function>current_user</function>.
    A tabela pode ser especificada pelo nome ou pelo OID. Portanto, na verdade
    existem seis variações de <function>has_table_privilege</function>, que
    podem ser distinguidas pelo número e tipo de seus argumentos.
    Quando se especifica pelo nome, o nome pode ser qualificado pelo esquema
    se for necessário.
    O tipo de privilégio de acesso desejado é especificado através de texto em
    uma cadeia de caracteres, que deve resultar em um dos seguintes valores:
    <literal>SELECT</literal>, <literal>INSERT</literal>,
    <literal>UPDATE</literal>, <literal>DELETE</literal>,
    <literal>RULE</literal>, <literal>REFERENCES</literal> ou
    <literal>TRIGGER</literal> (não faz diferença maiúscula ou minúsculas).
    Exemplo:
<programlisting>
SELECT has_table_privilege('meu_esquema.minha_tabela', 'select');
</programlisting>
   </para>

   <para>
    A função <function>has_database_privilege</function> verifica se o usuário
    pode acessar o banco de dados de uma determinada maneira. As possibilidades
    para os argumentos são análogas às da função
    <function>has_table_privilege</function>.
    O tipo de privilégio de acesso desejado deve resultar em
    <literal>CREATE</literal>,
    <literal>TEMPORARY</literal> ou
    <literal>TEMP</literal> (que equivale a
    <literal>TEMPORARY</literal>).
   </para>

   <para>
    A função <function>has_function_privilege</function> verifica se o usuário
    pode acessar a função de uma determinada maneira. As possibilidades para os
    argumentos são análogas às da função <function>has_table_privilege</function>.
    Ao se especificar a função através de um texto em uma cadeia de caracteres
    em vez de pelo OID, a entrada permitida é a mesma que para o tipo de dado
    <type>regprocedure</> (consulte a <xref linkend="datatype-oid">).
    O tipo de privilégio de acesso desejado deve resultar em
    <literal>EXECUTE</literal>.
    Exemplo:
<programlisting>
SELECT has_function_privilege('joel', 'minha_função(int, text)', 'execute');
</programlisting>
   </para>

   <para>
    A função <function>has_language_privilege</function> verifica se o usuário
    pode acessar a linguagem procedural de uma determinada maneira.
    As possibilidades para os seus argumentos são análogas às da função
    <function>has_table_privilege</function>.
    O tipo de privilégio de acesso desejado deve resultar em
    <literal>USAGE</literal>.
   </para>

   <para>
    A função <function>has_schema_privilege</function> verifica se o usuário
    pode acessar o esquema de uma determinada maneira.
    As possibilidades para os seus argumentos são análogas às da função
    <function>has_table_privilege</function>.
    O tipo de privilégio de acesso desejado deve resultar em
    <literal>CREATE</literal> or
    <literal>USAGE</literal>.
   </para>

   <para>
    A função <function>has_tablespace_privilege</function> verifica se o usuário
    pode acessar o espaço de tabelas de uma determinada maneira.
    As possibilidades para os seus argumentos são análogas às da função
    <function>has_table_privilege</function>.
    O tipo de privilégio de acesso desejado deve resultar em
    <literal>CREATE</literal>.
   </para>

  <para>
   Para verificar se o usuário possui a opção de concessão para um determinado
   privilégio, deve ser anexado <literal> WITH GRANT OPTION</literal> à palavra
   chave do privilégio; por exemplo <literal>'UPDATE WITH GRANT OPTION'</literal>.
  </para>

  <para>
   A <xref linkend="functions-info-schema-table"> mostra as funções que
   determinam se um certo objeto é <firstterm>visível</> através do caminho
   de procura de esquema corrente. Uma tabela é dita visível se o esquema que
   a contém está no caminho de procura e nenhuma tabela com o mesmo nome
   aparece antes no caminho de procura. Equivale a declarar que a tabela
   pode ser referenciada pelo seu nome sem uma qualificação de esquema
   explícita. Por exemplo, para listar o nome de todas as tabelas visíveis:
<programlisting>
SELECT relname FROM pg_class WHERE pg_table_is_visible(oid);
</programlisting>
  </para>

   <table id="functions-info-schema-table">
    <title>Funções de consulta à visibilidade do esquema</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>pg_table_is_visible</function> (<parameter>oid_da_tabela</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>a tabela é visível no caminho de procura</entry>
      </row>
      <row>
       <entry><literal><function>pg_type_is_visible</function> (<parameter>oid_do_tipo</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o tipo (ou domínio) é visível no caminho de procura</entry>
      </row>
      <row>
       <entry><literal><function>pg_function_is_visible</function> (<parameter>oid_da_função</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>a função é visível no caminho de procura</entry>
      </row>
      <row>
       <entry><literal><function>pg_operator_is_visible</function> (<parameter>oid_do_operador</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>o operador é visível no caminho de procura</entry>
      </row>
      <row>
       <entry><literal><function>pg_opclass_is_visible</function> (<parameter>oid_da_classe_de_operadores</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>a classe de operadores é visível no caminho de procura</entry>
      </row>
      <row>
       <entry><literal><function>pg_conversion_is_visible</function> (<parameter>oid_da_conversão</parameter>)</literal>
       </entry>
       <entry><type>boolean</type></entry>
       <entry>a conversão é visível no caminho de procura</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm zone="functions-info">
    <primary>pg_table_is_visible</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>pg_type_is_visible</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>pg_function_is_visible</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>pg_operator_is_visible</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>pg_opclass_is_visible</primary>
   </indexterm>
   <indexterm zone="functions-info">
    <primary>pg_conversion_is_visible</primary>
   </indexterm>

   <para>
   A função <function>pg_table_is_visible</function> realiza a verificação para
   as tabelas (ou visões, ou qualquer outro tipo de entrada em
   <literal>pg_class</literal>).
   As funções <function>pg_type_is_visible</function>,
   <function>pg_function_is_visible</function>,
   <function>pg_operator_is_visible</function>,
   <function>pg_opclass_is_visible</function> e
   <function>pg_conversion_is_visible</function> realizam o mesmo tipo de
   verificação de visibilidade para os tipos (e domínios), funções, operadores,
   classes de operadores e conversões, respectivamente. Para as funções e os
   operadores, um objeto no caminho de procura é visível se não existir nenhum
   objeto com o mesmo nome <emphasis>e mesmos tipos de dado dos
   argumentos</emphasis> aparecendo antes no caminho. Para as classes de
   operadores, são considerados tanto o nome quanto o método de acesso de índice
   associado.
   </para>

   <para>
    Todas estas funções requerem OIDs de objeto para identificar o objeto a ser
    verificado. Se for desejado verificar um objeto pelo seu nome, é conveniente
    utilizar os tipos aliás de OID (<type>regclass</>, <type>regtype</>,
    <type>regprocedure</> ou <type>regoperator</>). Exemplo:
<programlisting>
SELECT pg_type_is_visible('meu_esquema.widget'::regtype);
</programlisting>
    Deve ser observado que não faz muito sentido testar um nome não qualificado
    desta maneira &mdash; se o nome puder ser reconhecido, então tem que ser
    visível.
   </para>

   <indexterm zone="functions-info">
    <primary>format_type</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_viewdef</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_ruledef</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_indexdef</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_triggerdef</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_constraintdef</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_expr</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_userbyid</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_get_serial_sequence</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>pg_tablespace_databases</primary>
   </indexterm>

  <para>
   A <xref linkend="functions-info-catalog-table"> mostra as funções que
   extraem informações dos catálogos do sistema.
  </para>

   <table id="functions-info-catalog-table">
    <title>Funções de informações dos catálogos do sistema</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>format_type</function>(<parameter>oid_do_tipo</parameter>, <parameter>typemod</>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o nome SQL do tipo de dado</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef</function>(<parameter>nome_da_visão</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>
        obtém o comando <command>CREATE VIEW</> para a visão
        (<emphasis>em obsolescência</emphasis>)
        <footnote>
         <para>
          <literal>deprecated</literal> &mdash;
          Dito de um programa ou funcionalidade que é considerada em
          obsolescência e no processo de ter sua utilização gradualmente
          interrompida, geralmente em favor de uma determinada substituição.
          As funcionalidades em obsolescência podem infelizmente, demorar
          muitos anos para desaparecer.
          <ulink url="http://www.catb.org/~esr/jargon/html/D/deprecated.html">
          The Jargon File</ulink> (N. do T.)
         </para>
        </footnote>
       </entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef</function>(<parameter>nome_da_visão</parameter>, <parameter>impressão_alinhada</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE VIEW</> para a visão (<emphasis>em obsolescência</emphasis>)</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef</function>(<parameter>oid_da_visão</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE VIEW</> para a visão</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_viewdef</function>(<parameter>oid_da_visão</parameter>, <parameter>impressão_alinhada</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE VIEW</> para a visão</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef</function>(<parameter>oid_da_regra</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE RULE</> para a regra</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_ruledef</function>(<parameter>oid_da_regra</parameter>, <parameter>impressão_alinhada</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE RULE</> para a regra</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef</function>(<parameter>oid_do_índice</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE INDEX</> para o índice</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_indexdef</function>(<parameter>oid_do_índice</parameter>, <parameter>número_da_coluna</parameter>, <parameter>impressão_alinhada</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE INDEX</> para o índice, ou a
       definição de apenas uma coluna do índice quando o
       <parameter>número_da_coluna</parameter> não for zero</entry>
      </row>
      <row>
       <entry><function>pg_get_triggerdef</function>(<parameter>oid_do_gatilho</parameter>)</entry>
       <entry><type>text</type></entry>
       <entry>obtém o comando <command>CREATE [ CONSTRAINT ] TRIGGER</> para o gatilho</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef</function>(<parameter>oid_da_restrição</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém a definição da restrição</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_constraintdef</function>(<parameter>oid_da_restrição</parameter>, <parameter>impressão_alinhada</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém a definição da restrição</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr</function>(<parameter>texto_da_expressão</parameter>, <parameter>oid_da_relação</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>forma interna descompilada da expressão, assumindo que todas as
       Vars na mesma se referem à relação indicada pelo segundo parâmetro</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_expr</function>(<parameter>texto_da_expressão</parameter>, <parameter>oid_da_relação</parameter>, <parameter>impressão_alinhada</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>forma interna descompilada da expressão, assumindo que todas as
       Vars na mesma se referem à relação indicada pelo segundo parâmetro</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_userbyid</function>(<parameter>id_do_usuário</parameter>)</literal></entry>
       <entry><type>name</type></entry>
       <entry>obtém o nome do usuário com o identificador fornecido</entry>
      </row>
      <row>
       <entry><literal><function>pg_get_serial_sequence</function>(<parameter>nome_da_tabela</parameter>, <parameter>nome_da_coluna</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o nome da seqüência utilizada pela coluna
       <type>serial</type> ou <type>bigserial</type></entry>
      </row>
      <row>
       <entry><literal><function>pg_tablespace_databases</function>(<parameter>oid_do_espaço_de_tabelas</parameter>)</literal></entry>
       <entry><type>setof oid</type></entry>
       <entry>obtém o conjunto de OIDs de banco de dados que possuem objetos no espaço de tabelas</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   A função <function>format_type</function> retorna o nome SQL do tipo de dado
   que é identificado pelo seu OID de tipo e, possivelmente, um modificador de
   tipo. Deve ser passado NULL para o modificador de tipo se não for conhecido
   nenhum modificador específico.
  </para>

  <para>
   As funções <function>pg_get_viewdef</function>,
   <function>pg_get_ruledef</function>,
   <function>pg_get_indexdef</function>,
   <function>pg_get_triggerdef</function> e
   <function>pg_get_constraintdef</function> reconstroem, respectivamente,
   o comando de criação da visão, regra, índice, gatilho e restrição;
   deve ser observado que esta é uma reconstrução por descompilação, e não
   o texto original do comando.
   A função <function>pg_get_expr</function> descompila a forma interna de uma
   expressão individual, tal como o valor padrão para uma coluna. Pode ser
   útil ao examinar o conteúdo dos catálogos do sistema.
   A maioria destas funções estão presentes em duas formas, uma das quais pode,
   opcionalmente, gerar o resultado de forma <quote>alinhada</quote>
   (<literal>pretty-print</literal>).
   O formato alinhado é mais legível, mas o formato padrão tem mais
   probabilidade de ser interpretado da mesma maneira nas versões futuras do
   <productname>PostgreSQL</productname>;
   deve ser evitada a utilização do formato alinhado com a finalidade de
   geração de <literal>dumps</literal>.
   Passar <literal>false</literal> para o parâmetro de impressão alinhada produz
   o mesmo resultado da variante que não possui o parâmetro.
  </para>

  <para>
   A função <function>pg_get_userbyid</function>
   extrai o nome do usuário a partir do número de identificação do usuário.
   A função <function>pg_get_serial_sequence</function>
   busca o nome da seqüência associada à coluna <literal>serial</literal> ou
   <literal>bigserial</literal>. O nome está adequadamente formatado
   para ser passado para as funções de seqüência
   (consulte a <xref linkend="functions-sequence">).
   Retorna NULL se a coluna são possuir uma seqüência associada.
  </para>

  <para>
  A função <function>pg_tablespace_databases</function> permite examinar a
  utilização de um espaço de tabelas.
  Retorna um conjunto de OIDs de bancos de dados que possuem objetos armazenados
  no espaço de tabelas.
  Se esta função retornar alguma linha, então o espaço de tabelas não está vazio
  e, portanto, não pode ser removido.
  Para mostrar os objetos presentes no espaço de tabelas, é necessário se
  conectar ao banco de dados identificado por
  <function>pg_tablespace_databases</function> e consultar seus catálogos
  <structname>pg_class</>.
  </para>

   <indexterm zone="functions-info">
    <primary>obj_description</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>col_description</primary>
   </indexterm>

   <indexterm zone="functions-info">
    <primary>comentário</primary>
    <secondary sortas="objeto do banco de dados">sobre os objetos do banco de dados</secondary>
   </indexterm>

   <para>
    As funções mostradas na <xref linkend="functions-info-comment-table">
    extraem os comentários previamente armazenados pelo comando
    <command>COMMENT</command>. Retorna o valor nulo se não puder ser encontrado
    um comentário corespondendo aos parâmetros especificados.
   </para>

   <table id="functions-info-comment-table">
    <title>Funções de informação de comentário</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
       <entry><literal><function>obj_description</function>(<parameter>oid_do_objeto</parameter>, <parameter>nome_do_catálogo</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comentário para o objeto do banco de dados</entry>
      </row>
      <row>
       <entry><literal><function>obj_description</function>(<parameter>oid_do_objeto</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comentário para o objeto do banco de dados (<emphasis>em obsolescência</emphasis>)</entry>
      </row>
      <row>
       <entry><literal><function>col_description</function>(<parameter>oid_da_tabela</parameter>, <parameter>column_number</parameter>)</literal></entry>
       <entry><type>text</type></entry>
       <entry>obtém o comentário para a coluna da tabela</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    A forma da função <function>obj_description()</function> com dois parâmetros
    retorna o comentário para o objeto do banco de dados especificado pelo seu
    OID e pelo nome do catálogo do sistema que o contém. Por exemplo,
    <literal>obj_description(123456,'pg_class')</literal>
    retorna o comentário para a tabela com OID 123456.
    A forma de <function>obj_description()</function> com um parâmetro requer
    apenas o OID do objeto. Está obsoleta, porque não existe garantia
    dos OIDs serem únicos entre diferentes catálogos do sistema;
    portanto, pode ser retornado um comentário errado.
   </para>

   <para>
    A função <function>col_description()</function> retorna o comentário para a
    coluna da tabela especificada pelo OID da tabela, e pelo número da coluna.
    A função <function>obj_description()</function> não pode ser utilizada para
    colunas de tabela, porque as colunas não possuem OIDs próprios.
   </para>

  <sect2 id="functions-misc-pg-mssql-oracle">

   <sect2info>
    <author>
     <firstname>Halley</firstname>
     <surname>Pacheco de Oliveira</surname>
     <affiliation>
      <orgname>Câmara Municipal do Rio de Janeiro</orgname>
      <orgdiv>Assessoria de Informática</orgdiv>
      <address>
       <city>Rio de Janeiro</city>
       <country>Brasil</country>
      </address>
     </affiliation>
    </author>
    <date>2005-08-10</date>
   </sect2info>

   <title>Diferenças entre o PostgreSQL, o Oracle, o SQL Server e o DB2</title>

  <note>
   <para>
    Seção escrita pelo tradutor, não fazendo parte do manual original.
   </para>
  </note>

   <para>
    Esta seção tem por finalidade mostrar, através de exemplos práticos, as
    diferenças entre as funções de informação do sistema mostradas acima e suas
    equivalentes do <productname>PostgreSQL</productname>, do
    <productname>Oracle</productname>, do <productname>SQL Server</productname>
    e do <productname>DB2</productname>.
   </para>

   <example id="func-session-info">
    <title>Funções de informação do sistema</title>
    <para>
     Abaixo estão mostrados exemplos comparando a utilização das funções de
     informação do sistema no <productname>PostgreSQL</productname>, no
     <productname>SQL Server</productname>, no
     <productname>Oracle</productname> e no <productname>DB2</productname>.
     Consulte também
     <ulink url="http://www.stanford.edu/dept/itss/docs/oracle/9i/server.920/a96540/functions122a.htm">
     SYS_CONTEXT</ulink>.
   </para>

   <para>
    <productname>PostgreSQL &version;</productname>:
   </para>

<screen>
<prompt>=&gt;</prompt> <userinput>SELECT current_database();</userinput>

<computeroutput>
 current_database
------------------
 template1
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT current_schema();</userinput>

<computeroutput>
 current_schema
----------------
 public
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT current_schemas(TRUE);</userinput>

<computeroutput>
   current_schemas
---------------------
 {pg_catalog,public}
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT CURRENT_USER AS usuario;</userinput>

<computeroutput>
 usuario
----------
 postgres
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT inet_client_addr()</userinput>;

<computeroutput>
 inet_client_addr
------------------
 127.0.0.1
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>template1=# SELECT inet_client_port();</userinput>

<computeroutput>
 inet_client_port
------------------
             1151
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT inet_server_addr();</userinput>

<computeroutput>
 inet_server_addr
------------------
 127.0.0.1
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT inet_server_port();</userinput>

<computeroutput>
 inet_server_port
------------------
             5432
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT SESSION_USER as usuario;</userinput>

<computeroutput>
 usuario
----------
 postgres
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT USER as usuario;</userinput>

<computeroutput>
 usuario
----------
 postgres
(1 linha)
</computeroutput>

<prompt>=&gt;</prompt> <userinput>SELECT version() AS versao;</userinput>

<computeroutput>
                                         versao
-----------------------------------------------------------------------------------------
 PostgreSQL 8.0.0 on i686-pc-mingw32, compiled by GCC gcc.exe (GCC) 3.4.2 (mingw-special)
(1 linha)
</computeroutput>
</screen>

   <para>
    <productname>SQL Server 2000</productname>:
   </para>

<screen>
<userinput>SELECT db_name() AS current_database</userinput>

<computeroutput>
current_database
----------------
pubs
(1 row(s) affected)
</computeroutput>

<userinput>SELECT CURRENT_USER AS usuario;</userinput>

<computeroutput>
usuario
-------
dbo
(1 row(s) affected)
</computeroutput>

<userinput>SELECT SESSION_USER as usuario</userinput>

<computeroutput>
usuario
-------
dbo
(1 row(s) affected)
</computeroutput>

<userinput>SELECT SYSTEM_USER as usuario</userinput>

<computeroutput>
usuario
-------
halley
(1 row(s) affected)
</computeroutput>

<userinput>SELECT host_name() AS nome_hospedeiro</userinput> -- cliente

<computeroutput>
nome_hospedeiro
---------------
BD01
(1 row(s) affected)
</computeroutput>

<userinput>SELECT @@VERSION AS versao</userinput>

<computeroutput>
versao
-----------------------------------------------------------
Microsoft SQL Server  2000 - 8.00.760 (Intel X86)
        Dec 17 2002 14:22:05
        Copyright (c) 1988-2003 Microsoft Corporation
        Enterprise Edition on Windows NT 5.2 (Build 3790: )
(1 row(s) affected)
</computeroutput>
</screen>

   <para>
    <productname>Oracle 10g</productname>:
   </para>

<screen>
<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'DB_NAME') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','DB_NAME')
--------------------------------
orcl
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'CURRENT_SCHEMA') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','CURRENT_SCHEMA')
---------------------------------------
SCOTT
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'CURRENT_USER') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','CURRENT_USER')
-------------------------------------
SCOTT
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'HOST') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','HOST')
-----------------------------
CASA\HALLEY
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'IP_ADDRESS') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','IP_ADDRESS')
-----------------------------------
200.165.203.130
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'LANGUAGE') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','LANGUAGE')
---------------------------------
AMERICAN_AMERICA.WE8ISO8859P1
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'NETWORK_PROTOCOL') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','NETWORK_PROTOCOL')
-----------------------------------------
tcp
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'NLS_DATE_FORMAT') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','NLS_DATE_FORMAT')
----------------------------------------
DD-MON-RR
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'OS_USER') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','OS_USER')
--------------------------------
HALLEY\Administrator
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT sys_context ('USERENV', 'SESSION_USER') FROM sys.dual;</userinput>

<computeroutput>
SYS_CONTEXT('USERENV','SESSION_USER')
-------------------------------------
SCOTT
</computeroutput>

<prompt>SQL&gt;</prompt> <userinput>SELECT banner FROM v$version;</userinput>

<computeroutput>
BANNER
----------------------------------------------------------------
Oracle Database 10g Enterprise Edition Release 10.1.0.2.0 - Prod
PL/SQL Release 10.1.0.2.0 - Production
CORE    10.1.0.2.0      Production
TNS for 32-bit Windows: Version 10.1.0.2.0 - Production
NLSRTL Version 10.1.0.2.0 - Production
</computeroutput>
</screen>

     <para>
      <productname>DB2 8.1</productname>:
     </para>

<screen>
<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT_SCHEMA FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
--------
DB2INST1
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT CURRENT_SERVER FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
------
SAMPLE
</computeroutput>

<prompt>DB2SQL92&gt;</prompt> <userinput>SELECT USER FROM sysibm.sysdummy1;</userinput>

<computeroutput>
1
--------
DB2INST1
</computeroutput>

-- Linha de comando

<prompt>$</prompt> <userinput>db2level</userinput>

<computeroutput>
DB21085I  A instância "db2inst1" utiliza "32" bits e o release de código do DB2
"SQL08020" com identificador de nível "03010106".
Os tokens informativos são "DB2 v8.1.0.64", "s040812", "MI00086" e FixPak "7".
O produto está instalado em "/opt/IBM/db2/V8.1".
</computeroutput>
</screen>
   </example>
  </sect2>
 </sect1>

 <sect1 id="functions-admin">
  <title>Funções para administração do sistema</title>

  <para>
   A <xref linkend="functions-admin-set-table"> mostra as funções
   disponíveis para consultar e para alterar os parâmetros de configuração
   em tempo de execução.
  </para>

   <table id="functions-admin-set-table">
    <title>Funções para definição de configuração</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry></row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>current_setting</function>(<parameter>nome_da_definição</parameter>)</literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>valor corrente da definição</entry>
      </row>
      <row>
       <entry>
        <literal><function>set_config(<parameter>nome_da_definição</parameter>,
                             <parameter>novo_valor</parameter>,
                             <parameter>é_local</parameter>)</function></literal>
       </entry>
       <entry><type>text</type></entry>
       <entry>define o parâmetro e retorna o novo valor</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <indexterm zone="functions-admin">
    <primary>SET</primary>
   </indexterm>

   <indexterm zone="functions-admin">
    <primary>SHOW</primary>
   </indexterm>

   <indexterm zone="functions-admin">
    <primary>configuração</primary>
    <secondary sortas="servidor">do servidor</secondary>
    <tertiary>functions</tertiary>
   </indexterm>

   <para>
    A função <function>current_setting</function> retorna o valor corrente
    da definição <parameter>nome_da_definição</parameter>.
    Corresponde ao comando SQL <command>SHOW</command>.
    Por exemplo:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT current_setting('datestyle');</userinput>

<computeroutput>
 current_setting
-----------------
 ISO, DMY
(1 linha)
</computeroutput>
</screen>
   </para>

   <para>
    A função <function>set_config</function> define o parâmetro
    <parameter>nome_da_configuração </parameter> como
    <parameter>novo_valor</parameter>. Se o parâmetro
    <parameter>é_local</parameter> for <literal>true</literal>, então o novo
    valor se aplica somente à transação corrente. Se for desejado que o novo
    valor seja aplicado à sessão corrente, deve ser utilizado
    <literal>false</literal>. Esta função corresponde ao comando SQL
    <command>SET</command>. Por exemplo:
<screen>
<prompt>=&gt;</prompt> <userinput>SELECT set_config('log_statement_stats', 'off', false);</userinput>

<computeroutput>
 set_config
------------
 off
(1 linha)
</computeroutput>
</screen>
   </para>

   <indexterm zone="functions-admin">
    <primary>pg_cancel_backend</primary>
   </indexterm>

   <indexterm zone="functions-admin">
    <primary>sinal</primary>
    <secondary sortas="processo servidor">processos servidor</secondary>
   </indexterm>

   <para>
    A função mostrada na <xref linkend="functions-admin-signal-table">
    envia sinais de controle para outros processos servidor.
    A utilização desta função é restrita aos superusuários.
   </para>

   <table id="functions-admin-signal-table">
    <title>Funções de sinais para o servidor</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_cancel_backend</function>(<parameter>pid</parameter>)</literal>
        </entry>
       <entry><type>int</type></entry>
       <entry>Cancela o comando corrente no servidor</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    Se for bem-sucedida a função retorna 1, caso contrário retorna 0.
    O ID do processo (<literal>pid</literal>) de um servidor ativo pode ser
    encontrado a partir da coluna <structfield>procpid</structfield> da visão
    <structname>pg_stat_activity</structname>, ou listando os processos do
    <command>postgres</command> no servidor através do comando do Unix
    <application>ps</>.
   </para>

   <indexterm zone="functions-admin">
    <primary>pg_start_backup</primary>
   </indexterm>

   <indexterm zone="functions-admin">
    <primary>pg_stop_backup</primary>
   </indexterm>

   <indexterm zone="functions-admin">
    <primary>cópia de segurança</primary>
   </indexterm>

   <para>
    As funções mostradas na <xref linkend="functions-admin-backup-table">
    ajudam a realizar cópias de segurança <literal>on-line</literal>.
    A utilização destas funções é restrita aos superusuários.
   </para>

   <table id="functions-admin-backup-table">
    <title>Funções de controle de cópia de segurança</title>
    <tgroup cols="3">
     <thead>
      <row><entry>Nome</entry> <entry>Tipo retornado</entry> <entry>Descrição</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry>
        <literal><function>pg_start_backup</function>(<parameter>texto_do_rótulo</parameter>)</literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>configura para realizar cópia de segurança on-line</entry>
      </row>
      <row>
       <entry>
        <literal><function>pg_stop_backup</function>()</literal>
        </entry>
       <entry><type>text</type></entry>
       <entry>Termina a realização da cópia de segurança on-line</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

   <para>
    A função <function>pg_start_backup</> recebe um único parâmetro que é um
    rótulo arbitrário definido pelo usuário para a cópia de segurança
    (habitualmente é o nome sob o qual o arquivo da cópia de segurança será
    armazenado). A função escreve o arquivo rótulo da cópia de segurança no
    diretório de dados do agrupamento de bancos de dados e, então, retorna
    o deslocamento no WAL do início da cópia de segurança como texto
    (o usuário não precisa prestar atenção a este valor do resultado, mas é
    fornecido para o caso de ser útil).
   </para>

   <para>
    A função <function>pg_stop_backup</> remove o arquivo rótulo criado pela
    função <function>pg_start_backup</> e, em seu lugar, cria o arquivo de
    histórico de cópia de segurança na área de arquivamento do WAL.
    O arquivo de histórico inclui o rótulo fornecido para a função
    <function>pg_start_backup</>, os deslocamentos inicial e final do WAL para
    a cópia de segurança, e o tempo de início e de fim da cópia de segurança.
    O valor retornado é o deslocamento no WAL do fim da cópia de segurança
    (que, novamente, pode ser pouco interessante).
   </para>

   <para>
    Para obter detalhes sobre a utilização apropriada destas funções consulte a
    <xref linkend="backup-online">.
   </para>
  </sect1>
</chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
