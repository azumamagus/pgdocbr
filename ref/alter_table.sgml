<!--
$PostgreSQL: pgsql/doc/src/sgml/ref/alter_table.sgml,v 1.77 2005/01/14 01:16:52 tgl Exp $
PostgreSQL documentation
-->

<refentry id="SQL-ALTERTABLE">
 <refmeta>
  <refentrytitle id="sql-altertable-title">ALTER TABLE</refentrytitle>
  <refmiscinfo>SQL - Comandos da Linguagem</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>ALTER TABLE</refname>
  <refpurpose>altera a definição de uma tabela</refpurpose>
 </refnamediv>

 <indexterm zone="sql-altertable">
  <primary>ALTER TABLE</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
ALTER TABLE [ ONLY ] <replaceable class="parameter">nome</replaceable> [ * ]
    <replaceable class="parameter">ação</replaceable> [, ... ]
ALTER TABLE [ ONLY ] <replaceable class="parameter">nome</replaceable> [ * ]
    RENAME [ COLUMN ] <replaceable class="parameter">coluna</replaceable> TO <replaceable class="parameter">novo_nome_da_coluna</replaceable>
ALTER TABLE <replaceable class="parameter">nome</replaceable>
    RENAME TO <replaceable class="parameter">novo_nome</replaceable>

onde <replaceable class="parameter">ação</replaceable> é uma entre:

    ADD [ COLUMN ] <replaceable class="parameter">coluna</replaceable> <replaceable class="parameter">tipo</replaceable> [ <replaceable class="parameter">restrição_de_coluna</replaceable> [ ... ] ]
    DROP [ COLUMN ] <replaceable class="parameter">coluna</replaceable> [ RESTRICT | CASCADE ]
    ALTER [ COLUMN ] <replaceable class="parameter">coluna</replaceable> TYPE <replaceable class="parameter">tipo</replaceable> [ USING <replaceable class="parameter">expressão</replaceable> ]
    ALTER [ COLUMN ] <replaceable class="parameter">coluna</replaceable> SET DEFAULT <replaceable class="parameter">expressão</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">coluna</replaceable> DROP DEFAULT
    ALTER [ COLUMN ] <replaceable class="parameter">coluna</replaceable> { SET | DROP } NOT NULL
    ALTER [ COLUMN ] <replaceable class="parameter">coluna</replaceable> SET STATISTICS <replaceable class="parameter">inteiro</replaceable>
    ALTER [ COLUMN ] <replaceable class="parameter">coluna</replaceable> SET STORAGE { PLAIN | EXTERNAL | EXTENDED | MAIN }
    ADD <replaceable class="parameter">restrição_de_tabela</replaceable>
    DROP CONSTRAINT <replaceable class="parameter">nome_da_restrição</replaceable> [ RESTRICT | CASCADE ]
    CLUSTER ON <replaceable class="parameter">nome_do_índice</replaceable>
    SET WITHOUT CLUSTER
    SET WITHOUT OIDS
    OWNER TO <replaceable class="parameter">novo_dono</replaceable>
    SET TABLESPACE <replaceable class="parameter">nome_do_espaço_de_tabelas</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Descrição</title>

  <para>
   O comando <command>ALTER TABLE</command> altera a definição de uma tabela
   existente. Existem várias sub-formas:

  <variablelist>
   <varlistentry>
    <term><literal>ADD COLUMN</literal></term>
    <listitem>
     <para>
      Esta forma adiciona uma nova coluna à tabela utilizando a mesma sintaxe
      do comando <xref linkend="SQL-CREATETABLE" endterm="SQL-CREATETABLE-TITLE">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP COLUMN</literal></term>
    <listitem>
     <para>
      Esta forma remove uma coluna da tabela. Os índices e as
      restrições da tabela que envolvem a coluna também são automaticamente
      removidos. É necessário especificar <literal>CASCADE</literal> se
      algum objeto fora da tabela depender da coluna como, por exemplo,
      referências de chaves estrangeiras ou visões.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ALTER COLUMN TYPE</literal></term>
    <listitem>
     <para>
      Esta forma muda o tipo de uma coluna da tabela. Os índices e as
      restrições de tabela simples que envolvem a coluna são automaticamente
      convertidos para usar o novo tipo da coluna, através da reanálise da
      expressão original fornecida.
      A cláusula opcional <literal>USING</literal> especifica como computar
      o novo valor da coluna a partir do antigo;
      quando omitida, a conversão padrão é a mesma de uma conversão de
      atribuição do tipo antigo para o novo.
      A cláusula <literal>USING</literal> deve ser fornecida quando não há
      nenhuma conversão implícita ou de atribuição do tipo antigo para o novo.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP DEFAULT</literal></term>
    <listitem>
     <para>
      Estas formas definem ou removem o valor padrão para a coluna.
      O valor padrão somente é aplicado aos comandos <command>INSERT</command>
      subseqüentes; não modifica as linhas existentes na tabela.
      Valores padrão também podem ser criados para visões e, neste caso,
      são inseridos dentro do comando <command>INSERT</command> na visão, antes
      da regra <literal>ON INSERT</literal> da visão ser aplicada.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET</literal>/<literal>DROP NOT NULL</literal></term>
    <listitem>
     <para>
      Estas formas alteram se a coluna está marcada para permitir valores nulos
      ou para rejeitar valores nulos. A forma <literal>SET NOT NULL</literal>
      só pode ser utilizada quando não existem valores nulos na coluna.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET STATISTICS</literal></term>
    <listitem>
     <para>
      Esta forma define a quantidade de informações armazenadas na coleta de
      estatísticas por coluna para as operações subseqüentes de
      <xref linkend="sql-analyze" endterm="sql-analyze-title">.
      A quantidade pode ser definida no intervalo de 0 a 1000; como alternativa,
      pode ser definida como -1 para utilizar a quantidade de estatísticas
      padrão do sistema (<xref linkend="guc-default-statistics-target">).
      Para obter informações adicionais sobre a utilização de estatísticas pelo
      planejador de comandos do <productname>PostgreSQL</productname> consulte a
      <xref linkend="planner-stats">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <indexterm>
     <primary>TOAST</primary>
     <secondary>configuração de armazenamento por coluna</secondary>
    </indexterm>

    <term><literal>SET STORAGE</literal></term>
    <listitem>
     <para>
      Esta forma define o modo de armazenamento da coluna. Controla se a
      coluna é mantida na mesma tabela ou em uma tabela suplementar, e se os
      dados devem ser comprimidos ou não. Deve ser utilizado
      <literal>PLAIN</literal> para valores de comprimento fixo, como
      <type>integer</type>, e fica na mesma tabela não comprimido.
      <literal>MAIN</literal> é utilizado para dados que ficam na mesma tabela
      e são compressíveis. <literal>EXTERNAL</literal> é utilizado para dados
      externos não comprimidos, e <literal>EXTENDED</literal> é utilizado para
      dados externos comprimidos. <literal>EXTENDED</literal> é o padrão para a
      maioria dos tipos de dado que suportam armazenamento
      não-<literal>PLAIN</literal>. A utilização de <literal>EXTERNAL</literal>
      torna as operações de <literal>substring</literal> em colunas
      <type>text</type> e <type>bytea</type> mais rápidas, às custas de um
      aumento no espaço para armazenamento.
      Deve ser observado que <literal>SET STORAGE</literal>, por si só, não muda nada
      na tabela, apenas define a estratégia a ser seguida durante as próximas
      atualizações da tabela. Consulte a <xref linkend="storage-toast"> para
      obter informações adicionais.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>ADD <replaceable class="parameter">restrição_de_tabela</replaceable></literal></term>
    <listitem>
     <para>
      Esta forma adiciona uma nova restrição à tabela utilizando a mesma sintaxe
      do comando
      <xref linkend="SQL-CREATETABLE" endterm="SQL-CREATETABLE-TITLE">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>DROP CONSTRAINT</literal></term>
    <listitem>
     <para>
      Esta forma remove restrições de tabela.
      Atualmente as restrições de tabela não necessitam ter nomes únicos e,
      portanto, pode haver mais de uma restrição correspondendo ao nome
      especificado. Todas as restrições correspondentes são removidas.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>CLUSTER</literal></term>
    <listitem>
     <para>
      Esta forma seleciona o índice padrão para as próximas operações de
      <xref linkend="SQL-CLUSTER" endterm="sql-cluster-title">.
      Não efetua realmente o reagrupamento da tabela.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT CLUSTER</literal></term>
    <listitem>
     <para>
      Esta forma remove da tabela a especificação do índice usado mais
      recentemente em <xref linkend="SQL-CLUSTER" endterm="sql-cluster-title">.
      Afeta as próximas operações de agrupamento que não especificarem um
      índice.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET WITHOUT OIDS</literal></term>
    <listitem>
     <para>
      Esta forma remove da tabela a coluna de sistema <literal>oid</literal>.
      É exatamente equivalente a <literal>DROP COLUMN oid RESTRICT</literal>,
      exceto que não reclama se já não houver mais a coluna
      <literal>oid</literal>.
     </para>

     <para>
      Deve ser observado que não existe uma forma alternativa de
      <command>ALTER TABLE</command> que permita restaurar os OIDs para a tabela
      após estes terem sido removidos.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>OWNER</literal></term>
    <listitem>
     <para>
      Esta forma torna o usuário especificado o dono da tabela,
      índice, seqüência ou visão.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SET TABLESPACE</literal></term>
    <listitem>
     <para>
      Esta forma muda o espaço de tabelas da tabela para o espaço de tabelas
      especificado, e move os arquivos de dados associados à tabela para o novo
      espaço de tabelas. Havendo índices na tabela, estes não são movidos;
      porém, podem ser movidos separadamente através de comandos
      <literal>SET TABLESPACE</literal> adicionais. Consulte também
      <xref linkend="SQL-CREATETABLESPACE" endterm="sql-createtablespace-title">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>RENAME</literal></term>
    <listitem>
     <para>
      A forma <literal>RENAME</literal> muda o nome de uma tabela
      (de um índice, de uma seqüência ou de uma visão), ou o nome de uma coluna
      da tabela. Não produz efeito sobre os dados armazenados.
     </para>
    </listitem>
   </varlistentry>

  </variablelist>
  </para>

  <para>
   Todas as ações, exceto <literal>RENAME</literal>, podem ser combinadas
   em uma lista de alterações múltiplas a serem aplicadas em paralelo. Por
   exemplo, é possível adicionar várias colunas e/ou alterar o tipo de várias
   colunas em um único comando. Esta situação é particularmente útil em
   tabelas grandes, uma vez que somente é necessário realizar uma passagem
   pela tabela.
  </para>

  <para>
   É necessário ser o dono da tabela para executar <command>ALTER TABLE</command>;
   exceto para <command>ALTER TABLE OWNER</command>, que somente pode ser executado por
   um superusuário.
  </para>
 </refsect1>

 <refsect1>
  <title>Parâmetros</title>

    <variablelist>

     <varlistentry>
      <term><replaceable class="parameter">nome</replaceable></term>
      <listitem>
       <para>
        O nome (opcionalmente qualificado pelo esquema) da tabela existente a
        ser alterada. Se <literal>ONLY</literal> for especificado, somente esta
        tabela será alterada. Se <literal>ONLY</literal> não for especificado, a
        tabela e todas as suas tabelas descendentes (se existirem) são
        alteradas. O <literal>*</literal> pode ser adicionado ao nome da tabela
        para indicar que as tabelas descendentes devem ser alteradas, mas na
        versão atual este é comportamento padrão (Nas versões anteriores a 7.1
        <literal>ONLY</literal> era o comportamento padrão. O padrão pode ser
        alterado mudando o parâmetro de configuração
        <xref linkend="guc-sql-inheritance">.)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">coluna</replaceable></term>
      <listitem>
       <para>
        O nome de uma coluna nova ou existente.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">novo_nome_da_coluna</replaceable></term>
      <listitem>
       <para>
        O novo nome para uma coluna existente.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">novo_nome</replaceable></term>
      <listitem>
       <para>
        O novo nome da tabela.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">tipo</replaceable></term>
      <listitem>
       <para>
        O tipo de dado da nova coluna, ou o novo tipo de dado de uma
        coluna existente.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">restrição_de_tabela</replaceable></term>
      <listitem>
       <para>
        A nova restrição de tabela para a tabela.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nome_da_restrição</replaceable></term>
      <listitem>
       <para>
        O nome da restrição existente a ser removida.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>CASCADE</literal></term>
      <listitem>
       <para>
        Remove, automaticamente, os objetos que dependem da coluna ou da
        restrição removida (por exemplo, visões fazendo referência à coluna).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><literal>RESTRICT</literal></term>
      <listitem>
       <para>
        Não permite remover a coluna ou a restrição caso existam objetos
        que dependam das mesmas. Este é o comportamento padrão.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nome_do_índice</replaceable></term>
      <listitem>
       <para>
        O nome do índice pelo qual a tabela deve ser marcada para agrupamento.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">novo_dono</replaceable></term>
      <listitem>
       <para>
        O nome de usuário do novo dono da tabela.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><replaceable class="parameter">nome_do_espaço_de_tabelas</replaceable></term>
      <listitem>
       <para>
        O nome do espaço de tabelas para o qual a tabela será movida.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
 </refsect1>

 <refsect1>
  <title>Observações</title>

   <para>
    A palavra chave <literal>COLUMN</literal> é apenas informativa,
    podendo ser omitida.
   </para>

   <para>
    Quando uma coluna é adicionada usando <literal>ADD COLUMN</literal>, todas
    as linhas existentes na tabela são inicializadas com o valor padrão da
    coluna (NULL se a cláusula <literal>DEFAULT</literal> não for especificada).
   </para>

   <para>
    Adicionar uma coluna com um valor padrão não nulo, ou mudar o tipo de uma
    coluna existente, faz com que toda a tabela seja reescrita. Isto pode levar
    uma quantidade de tempo significativa no caso de uma tabela grande;
    temporariamente será necessário o dobro do espaço em disco.
   </para>

   <para>
    A adição das restrições <literal>CHECK</literal> e <literal>NOT NULL</literal> obrigam
    varrer toda a tabela para verificar se as linhas existentes estão em
    conformidade com a restrição.
   </para>

   <para>
    A razão principal para fornecer a opção de especificar várias alterações
    em um único comando <command>ALTER TABLE</command>, é que várias varreduras ou
    reescritas da tabela podem assim ser combinadas em uma única passagem pela
    tabela.
   </para>

   <para>
    A forma <literal>DROP COLUMN</literal> não remove fisicamente a coluna,
    simplesmente torna a coluna invisível para as operações SQL. As operações
    subseqüentes de inclusão e de atualização na tabela armazenam o valor nulo
    na coluna. Portanto, remover uma coluna é rápido mas não reduz imediatamente
    o espaço em disco da tabela, porque o espaço ocupado pela coluna removida
    não é recuperado. O espaço é recuperado ao longo do tempo, à medida que as
    linhas existentes são atualizadas.
   </para>

   <para>
    Algumas vezes é vantajoso o fato de <literal>ALTER TYPE</command> requerer a
    reescrita de toda a tabela, porque o processo de reescrita elimina
    todo espaço morto presente na tabela. Por exemplo, para recuperar o
    espaço ocupado por uma coluna removida, a forma mais rápida é
<programlisting>
ALTER TABLE tabela ALTER COLUMN qualquer_coluna TYPE qualquer_tipo;
</programlisting>
    onde <literal>qualquer_coluna</literal> é uma coluna remanescente na tabela, e
    <literal>qualquer_tipo</literal> é o mesmo tipo que a coluna já possui.
    Resulta em uma modificação da tabela que não é semanticamente visível,
    mas o comando força a reescrita que elimina os dados que não são mais úteis.
   </para>

   <para>
    A opção <literal>USING</literal> de <literal>ALTER TYPE</> pode, na verdade,
    especificar qualquer expressão envolvendo os valores antigos da linha; ou
    seja, pode fazer referência a outras colunas assim como à coluna sendo
    convertida. Isto permite fazer conversões muito gerais através da sintaxe de
    <literal>ALTER TYPE</>. Por causa desta flexibilidade, a expressão do
    <literal>USING</literal> não é aplicada ao valor padrão da coluna (se
    houver); o resultado pode não ser uma expressão constante conforme requerido
    por um valor padrão. Isto significa que quando não existe conversão
    implícita ou de atribuição do tipo antigo para o novo,
    <literal>ALTER TYPE</> pode falhar na conversão do valor padrão, mesmo que
    a cláusula <literal>USING</literal> seja fornecida. Neste caso, deve ser
    removido o valor padrão utilizando <literal>DROP DEFAULT</>, executar
    <literal>ALTER TYPE</> e, então, usar <literal>SET DEFAULT</> para adicionar
    um novo valor padrão adequado. Considerações semelhantes se aplicam a
    índices e restrições envolvendo a coluna.
   </para>

   <para>
    Se a tabela possuir tabelas descendentes não é permitido adicionar,
    mudar o nome ou mudar o tipo de uma coluna na tabela ancestral sem fazer o
    mesmo nas tabelas descendentes. Ou seja, <command>ALTER TABLE ONLY</command>
    será rejeitado. Isto garante que as tabelas descendentes sempre possuem
    colunas correspondendo às tabelas ancestrais.
   </para>

   <para>
    Uma operação <literal>DROP COLUMN</literal> recursiva remove a coluna
    da tabela descendente somente se a tabela descendente não herdar esta coluna
    de outra tabela ancestral, e nunca tiver possuído uma definição independente
    da coluna. O <literal>DROP COLUMN</literal> não recursivo
    (ou seja, <command>ALTER TABLE ONLY ... DROP COLUMN</command>)
    nunca remove qualquer coluna de tabela descendente; em vez disso
    marca a coluna como definida de forma independente em vez de herdada.
   </para>

   <para>
    Não é permitido alterar qualquer parte dos catálogos do sistema.
   </para>

   <para>
    Consulte o comando
    <xref linkend="sql-createtable" endterm="sql-createtable-title">
    para obter informações adicionais sobre os parâmetros válidos.
    O <xref linkend="ddl"> possui informações adicionais sobre herança.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemplos</title>

  <para>
   Para adicionar uma coluna do tipo <type>varchar</type> a uma tabela:
<programlisting>
ALTER TABLE distribuidores ADD COLUMN endereco varchar(30);
</programlisting>
  </para>

  <para>
   Para excluir uma coluna da tabela:
<programlisting>
ALTER TABLE distribuidores DROP COLUMN endereco RESTRICT;
</programlisting>
  </para>

  <para>
   Para mudar o tipo de duas colunas existentes em uma única operação:
<programlisting>
ALTER TABLE distribuidores
    ALTER COLUMN endereco TYPE varchar(80),
    ALTER COLUMN nome TYPE varchar(100);
</programlisting>
  </para>

  <para>
   Para mudar uma coluna inteira do UNIX contendo carimbo do tempo para
   <type>timestamp with time zone</type> através da cláusula
   <literal>USING</literal>:
<programlisting>
ALTER TABLE foo
    ALTER COLUMN foo_timestamp TYPE timestamp with time zone
    USING
        timestamp with time zone 'epoch' + foo_timestamp * interval '1 second';
</programlisting>
  </para>

  <para>
   Para mudar o nome de uma coluna existente:
<programlisting>
ALTER TABLE distribuidores RENAME COLUMN endereco TO cidade;
</programlisting>
  </para>

  <para>
   Para mudar o nome de uma tabela existente:
<programlisting>
ALTER TABLE distribuidores RENAME TO fornecedores;
</programlisting>
  </para>

  <para>
   Para adicionar uma restrição de não nulo a uma coluna:
<programlisting>
ALTER TABLE distribuidores ALTER COLUMN logradouro SET NOT NULL;
</programlisting>
   Para remover a restrição de não nulo da coluna:
<programlisting>
ALTER TABLE distribuidores ALTER COLUMN logradouro DROP NOT NULL;
</programlisting>
  </para>

  <para>
   Para adicionar uma restrição de verificação à tabela:
<programlisting>
ALTER TABLE distribuidores ADD CONSTRAINT chk_cep CHECK (char_length(cod_cep) = 8);
</programlisting>
  </para>

  <para>
   Para remover uma restrição de verificação de uma tabela e de todas as suas
   descendentes:
<programlisting>
ALTER TABLE distribuidores DROP CONSTRAINT chk_cep;
</programlisting>
  </para>

  <para>
   Para adicionar uma restrição de chave estrangeira a uma tabela:
<programlisting>
ALTER TABLE distribuidores ADD CONSTRAINT fk_dist FOREIGN KEY (endereco) REFERENCES enderecos (endereco) MATCH FULL;
</programlisting>
  </para>

  <para>
   Para adicionar uma restrição de unicidade (multicoluna) à tabela:
<programlisting>
ALTER TABLE distribuidores ADD CONSTRAINT unq_id_dist_cod_cep UNIQUE (id_dist, cod_cep);
</programlisting>
  </para>

  <para>
   Para adicionar uma restrição de chave primária a uma tabela com o nome gerado
   automaticamente, levando em conta que a tabela pode possuir somente uma única
   chave primária:
<programlisting>
ALTER TABLE distribuidores ADD PRIMARY KEY (id_dist);
</programlisting>
  </para>

  <para>
   Para mover a tabela para outro espaço de tabelas:
<programlisting>
ALTER TABLE distribuidores SET TABLESPACE espaco_de_tabelas_rapido;
</programlisting>
  </para>

 </refsect1>

 <refsect1>
  <title>Compatibilidade</title>

  <para>
   As formas <literal>ADD</literal>, <literal>DROP</literal> e <literal>SET DEFAULT</literal>
   estão em conformidade com o padrão SQL. As outras formas são extensões do
   <productname>PostgreSQL</productname> ao padrão SQL.
   Também, a capacidade de especificar mais de uma manipulação em um único
   comando <command>ALTER TABLE</command> é uma extensão.
  </para>

  <para>
   O comando <command>ALTER TABLE DROP COLUMN</command> pode ser utilizado para
   remover a única coluna da tabela, produzindo uma tabela com zero coluna. Esta
   é uma extensão ao SQL, que não permite tabelas sem nenhuma coluna.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
