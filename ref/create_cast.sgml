<!-- $PostgreSQL: pgsql/doc/src/sgml/ref/create_cast.sgml,v 1.20 2004/12/13 18:05:10 petere Exp $ -->

<refentry id="SQL-CREATECAST">
 <refmeta>
  <refentrytitle id="SQL-CREATECAST-TITLE">CREATE CAST</refentrytitle>
  <refmiscinfo>SQL - Comandos da Linguagem</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>CREATE CAST</refname>
  <refpurpose>cria uma conversão de tipo de dado</refpurpose>
 </refnamediv>

 <indexterm zone="sql-createcast">
  <primary>CREATE CAST</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
CREATE CAST (<replaceable>tipo_de_origem</replaceable> AS <replaceable>tipo_de_destino</replaceable>)
    WITH FUNCTION <replaceable>nome_da_função</replaceable> (<replaceable>tipos_dos_argumentos</replaceable>)
    [ AS ASSIGNMENT | AS IMPLICIT ]

CREATE CAST (<replaceable>tipo_de_origem</replaceable> AS <replaceable>tipo_de_destino</replaceable>)
    WITHOUT FUNCTION
    [ AS ASSIGNMENT | AS IMPLICIT ]
</synopsis>
 </refsynopsisdiv>

 <refsect1 id="sql-createcast-description">
  <title>Descrição</title>

  <para>
   O comando <command>CREATE CAST</command> cria uma conversão.
   A conversão especifica como realizar a conversão entre
   dois tipos de dado. Por exemplo,
<programlisting>
SELECT CAST(42 AS text);
</programlisting>
   converte a constante inteira 42 para o tipo <type>text</type>
   chamando uma função especificada previamente, neste caso
   <literal>text(int4)</literal>; se nenhuma conversão adequada tiver sido
   definida, a conversão falha.
  </para>

  <para>
   Dois tipos podem ser <firstterm>binariamente compatíveis</firstterm>,
   significando que podem ser convertidos um no outro <quote>livremente</quote>,
   sem chamar nenhuma função. Requer que os valores correspondentes
   utilizem a mesma representação interna. Por exemplo,
   os tipos <type>text</type> e <type>varchar</type> são
   binariamente compatíveis.
  </para>

  <para>
   Por padrão, a conversão somente pode ser feita por uma solicitação de
   conversão explícita, ou seja, uma construção explícita
   <literal>CAST(<replaceable>x</replaceable> AS <replaceable>nome_do_tipo</replaceable>)</literal> ou
   <replaceable>x</replaceable><literal>::</literal><replaceable>nome_do_tipo</replaceable>.
  </para>

  <para>
   Se a conversão for marcada como <literal>AS ASSIGNMENT</literal> então pode
   ser chamada implicitamente quando for atribuído um valor a uma coluna com o
   tipo de dado de destino. Por exemplo, supondo que <literal>foo.f1</literal>
   seja uma coluna do tipo <type>text</type>, então a atribuição
<programlisting>
INSERT INTO foo (f1) VALUES (42);
</programlisting>
   é permitida se a conversão do tipo <type>integer</type> para o tipo
   <type>text</type> estiver marcada como <literal>AS ASSIGNMENT</literal>,
   senão a atribuição não é permitida; geralmente é utilizado o termo
   <firstterm>conversão de atribuição</firstterm>
   (<literal>assignment cast</literal>) para descrever este tipo de conversão.
  </para>

  <para>
   Se a conversão estiver marcada como <literal>AS IMPLICIT</literal> então
   poderá ser chamada implicitamente em qualquer contexto, seja em uma
   atribuição ou internamente em uma expressão. Por exemplo, como
   <literal>||</literal> recebe operandos do tipo <type>text</type>, então a
   expressão
<programlisting>
SELECT 'Data e hora ' || now();
</programlisting>
   somente será permitida se a conversão do tipo <type>timestamp</type> para
   o tipo <type>text</type> estiver marcada como <literal>AS IMPLICIT</literal>,
   senão será necessário escrever a conversão explicitamente como, por exemplo,
<programlisting>
SELECT 'Data e hora ' || CAST(now() AS text);
</programlisting>
   (Geralmente é utilizado o termo <firstterm>conversão implícita</firstterm>
   (<literal>implicit cast</literal>) para descrever este tipo de conversão).
  </para>

  <para>
   É sensato ser conservador com relação a marcar conversões como implícitas.
   Uma superabundância de possibilidades de conversões implícitas pode fazer o
   <productname>PostgreSQL</productname> escolher interpretações surpreendentes
   para os comandos, ou até não ser capaz de resolver o comando devido à
   existência de várias interpretações possíveis. Uma boa regra empírica
   é tornar a conversão chamável implicitamente somente nos casos de
   transformações que preservam as informações entre tipos da mesma
   categoria geral. Por exemplo, a conversão de <type>int2</type> em
   <type>int4</type> pode ser implícita, mas a conversão de
   <type>float8</type> para <type>int4</type> provavelmente deve ser
   somente de atribuição. Conversões entre tipos de categorias diferentes, como
   <type>text</type> para <type>int4</type>, é melhor serem somente explícitas.
  </para>

  <para>
   É necessário ser o dono do tipo de dado de origem ou de destino para poder
   criar uma conversão. Para criar uma conversão binariamente compatível é
   necessário ser um superusuário; esta restrição existe porque uma conversão
   binariamente compatível pode facilmente derrubar o servidor.
  </para>
 </refsect1>

 <refsect1>
  <title>Parâmetros</title>

   <variablelist>
    <varlistentry>
     <term><replaceable>tipo_de_origem</replaceable></term>

     <listitem>
      <para>
       O nome do tipo de dado de origem da conversão.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>tipo_de_destino</replaceable></term>

     <listitem>
      <para>
       O nome do tipo de dado de destino da conversão.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><replaceable>nome_da_função</replaceable>(<replaceable>tipos_dos_argumentos</replaceable>)</term>

     <listitem>
      <para>
       A função utilizada para realizar a conversão. O nome da função pode
       ser qualificado pelo esquema. Se não for, a função será procurada no
       caminho de procura de esquema. O tipo de dado do resultado da função
       deve corresponder ao tipo de dado de destino da conversão.
       Os argumentos são discutidos abaixo.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>WITHOUT FUNCTION</literal></term>

     <listitem>
      <para>
       Indica que o tipo de dado de origem e o tipo de dado de destino são
       binariamente compatíveis e, por isso, não é necessária nenhuma
       função para realizar a conversão.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS ASSIGNMENT</literal></term>

     <listitem>
      <para>
       Indica que a conversão pode ser chamada implicitamente em contextos
       de atribuição.
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><literal>AS IMPLICIT</literal></term>

     <listitem>
      <para>
       Indica que a conversão pode ser chamada implicitamente em qualquer contexto.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>

  <para>
   As funções de implementação de conversão podem ter de um a três argumentos.
   O tipo do primeiro argumento deve ser idêntico ao tipo de origem da conversão.
   O segundo argumento, se houver, deve ser do tipo <type>integer</type>;
   recebe o modificador de tipo associado ao tipo de destino, ou <literal>-1</literal>
   se não houver nenhum. O terceiro argumento, se houver, deve ser do tipo
   <type>boolean</literal>; recebe <literal>true</literal> se a conversão for explícita, ou
   <literal>false</literal> caso contrário
   (Estranhamente, a especificação SQL obriga comportamentos diferentes
   para conversões implícitas e explícitas em alguns casos. Este argumento
   é fornecido para funções que devem implementar estes tipos de conversão.
   Não é recomendado que se projete tipos de dado próprios de uma forma
   que isto tenha importância).
  </para>

  <para>
   Normalmente, a conversão deve ter tipos de dado de origem e de destino
   diferentes. Entretanto, é permitido declarar uma conversão com tipos
   de dados de origem e de destino idênticos, se houver uma função de
   implementação da conversão com mais de um argumento. É utilizado para
   representar nos catálogos do sistema funções de modificação do comprimento
   específicas do tipo.
   A função nomeada é utilizada para modificar um
   valor do tipo para o valor do modificador do tipo indicado por seu segundo
   argumento (uma vez que atualmente a gramática permite que apenas certos
   tipos de dados nativos possuam modificadores de tipo, esta funcionalidade
   não tem utilidade para os tipos de destino definidos pelo usuário, mas de
   qualquer forma é mencionado para ficar completo).
  </para>

  <para>
   Quando uma conversão possui tipos de origem e de destino diferentes,
   e a função recebe mais de um argumento, representa a conversão de um tipo
   para o outro e a aplicação da modificação do comprimento em um único passo.
   Quando não existe disponível uma entrada deste tipo, a modificação
   para um tipo que usa um modificador de tipo
   envolve duas etapas, uma para converter entre os tipos de dado e uma segunda
   para aplicar o modificador.
  </para>

 </refsect1>

 <refsect1 id="sql-createcast-notes">
  <title>Observações</title>

  <para>
   Use o comando <xref linkend="sql-dropcast" endterm="sql-dropcast-title">
   para remover conversões criadas pelo usuário.
  </para>

  <para>
   Lembre-se que para ser possível converter tipos nas duas direções
   é necessário declarar conversões para as duas direções explicitamente.
  </para>

  <para>
   Antes do <productname>PostgreSQL 7.3</productname> toda função que possuía o
   mesmo nome de um tipo de dado, retornava este tipo de dado, e recebia um
   argumento de um tipo diferente era, automaticamente, uma função de conversão.
   Esta convenção foi abandonada devido à introdução dos esquemas e da
   capacidade de representar conversões binariamente compatíveis nos catálogos
   do sistema. As funções de conversão internas ainda seguem este esquema de
   nomes, mas também devem aparecer como conversões no catálogo do sistema
   <structname>pg_cast</structname>.
  </para>

  <para>
   Embora não seja requerido, é recomendado que se continue a seguir esta
   antiga convenção para dar nome às funções de implementação da conversão
   usando o nome do tipo de dado de destino.
   Muitos usuários estão acostumados a poderem converter tipos de dado usando
   a notação no estilo de função, ou seja,
   <replaceable>nome_do_tipo</replaceable>(<replaceable>x</replaceable>).
   Na verdade esta notação não é nada mais, nem menos, que uma chamada à função
   de implementação da conversão;
   não é tratada especialmente como uma conversão.
   Se os nomes de suas funções de conversão não aderirem a esta convenção
   então seus usuários ficarão surpresos.
   Uma vez que o <productname>PostgreSQL</productname> permite a sobrecarga do mesmo nome
   de função com argumentos de tipos diferentes, não há dificuldade em ter-se
   várias funções de conversão de tipos diferentes todas usando o nome do
   tipo de destino.
  </para>

  <note>
   <para>
    Existe uma pequena mentira no parágrafo anterior: existe ainda um caso em
    que <structname>pg_cast</structname> é utilizada para resolver o significado
    de uma aparente chamada de função. Se a chamada de função
    <replaceable>nome</replaceable>(<replaceable>x</replaceable>) não corresponder a
    nenhuma função existente, mas <replaceable>nome</replaceable> for o nome
    de um tipo de dado, e <structname>pg_cast</structname> mostrar uma conversão
    binariamente compatível para o tipo de <replaceable>x</replaceable>, então a chamada
    será construída como uma conversão explícita. Esta exceção é feita
    para que as conversões compatíveis binariamente possam ser chamadas
    utilizando a sintaxe de função, embora não possuam nenhuma função.
   </para>
  </note>
 </refsect1>


 <refsect1 id="sql-createcast-examples">
  <title>Exemplos</title>

  <para>
   Para criar uma conversão do tipo <type>text</type> para o tipo
   <type>int4</type> utilizando a função <literal>int4(text)</literal>:
<programlisting>
CREATE CAST (text AS int4) WITH FUNCTION int4(text);
</programlisting>
   (Esta conversão já está pré-definida no sistema).
  </para>
 </refsect1>


 <refsect1 id="sql-createcast-compat">
  <title>Compatibilidade</title>

  <para>
   O comando <command>CREATE CAST</command> está em conformidade com o SQL:1999,
   exceto que o SQL:1999 não trata de tipos binariamente compatíveis nem de
   argumentos extra nas funções de implementação.
   A cláusula <literal>AS IMPLICIT</literal> também é uma extensão do
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>


 <refsect1 id="sql-createcast-seealso">
  <title>Consulte também</title>

  <para>
   <xref linkend="sql-createfunction" endterm="sql-createfunction-title">,
   <xref linkend="sql-createtype" endterm="sql-createtype-title">,
   <xref linkend="sql-dropcast" endterm="sql-dropcast-title">
  </para>
 </refsect1>

</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
