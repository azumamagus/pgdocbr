<!--
$PostgreSQL: pgsql/doc/src/sgml/ref/declare.sgml,v 1.33 2005/01/04 00:39:53 tgl Exp $
PostgreSQL documentation
-->

<refentry id="SQL-DECLARE">
 <refmeta>
  <refentrytitle id="SQL-DECLARE-TITLE">DECLARE</refentrytitle>
  <refmiscinfo>SQL - Comandos da Linguagem</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>DECLARE</refname>
  <refpurpose>define um cursor</refpurpose>
 </refnamediv>

 <indexterm zone="sql-declare">
  <primary>DECLARE</primary>
 </indexterm>

 <indexterm zone="sql-declare">
  <primary>cursor</primary>
  <secondary>DECLARE</secondary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
DECLARE <replaceable class="parameter">nome</replaceable> [ BINARY ] [ INSENSITIVE ] [ [ NO ] SCROLL ]
    CURSOR [ { WITH | WITHOUT } HOLD ] FOR <replaceable class="parameter">consulta</replaceable>
    [ FOR { READ ONLY | UPDATE [ OF <replaceable class="parameter">coluna</replaceable> [, ...] ] } ]
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Descrição</title>

  <para>
   O comando <command>DECLARE</command> permite o usuário criar cursores,
   que podem ser utilizados para trazer, de cada vez,
   um pequeno número de linhas de uma consulta grande. Os cursores
   podem retornar dados tanto no formato texto quanto binário usando o comando
   <xref linkend="sql-fetch" endterm="sql-fetch-title">.
  </para>

  <para>
   Cursores normais retornam dados no formato texto, o mesmo produzido pelo
   comando <command>SELECT</command>. Como os dados são armazenados nativamente
   no formato binário, o sistema necessita realizar uma conversão para gerar o
   formato texto. Como a informação chega no formato texto, o aplicativo cliente
   pode precisar convertê-la para o formato binário para manipulá-la.
   Além disso, dados no formato texto geralmente possuem um tamanho maior
   que no formato binário. Os cursores binários retornam os dados na
   representação binária, que pode ser manipulada mais facilmente.
   Entretanto, se o objetivo é exibir os dados na forma de texto,
   trazê-los na forma de texto reduz um pouco o esforço no lado cliente.
  </para>

  <para>
   Como exemplo, se uma consulta retornar o valor <quote>um</quote> de uma
   coluna com tipo de dado inteiro, será recebida a cadeia de caracteres
   <literal>1</literal> com o cursor padrão, enquanto que com um cursor binário
   será retornado um campo de 4 bytes contendo a representação interna do valor
   (na ordem de byte <quote>big-endian</quote>).
  </para>

  <para>
   Os cursores binários devem ser usados com cuidado. Muitos aplicativos,
   incluindo o <application>psql</application>, não estão preparados
   para tratar cursores binários e esperam que os dados cheguem
   no formato texto.
  </para>

  <note>
   <para>
    Quando o aplicativo cliente utiliza o protocolo
    <quote>consulta estendida</quote> (<literal>extended query</literal>)
    para executar o comando <command>FETCH</command>, a mensagem
    <literal>Bind</literal> do protocolo especifica se os dados devem
    retornar no formato texto ou binário. Esta escolha substitui a forma como o
    cursor foi definido. Por isso o conceito de cursor binário fica
    obsoleto ao se utilizar o protocolo <quote>consulta estendida</quote>
    &mdash; todo cursor pode ser tratado tanto como texto ou binário.
   </para>
  </note>
 </refsect1>

 <refsect1>
  <title>Parâmetros</title>

  <variablelist>
   <varlistentry>
    <term><replaceable class="parameter">nome</replaceable></term>
    <listitem>
     <para>
      O nome do cursor a ser criado.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>BINARY</literal></term>
    <listitem>
     <para>
      Faz o cursor retornar os dados no formato binário	em vez do formato texto.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>INSENSITIVE</literal></term>
    <listitem>
     <para>
      Indica que os dados trazidos pelo cursor não devem ser afetados pelas
      atualizações feitas nas tabelas subjacentes ao cursor, enquanto
      o cursor existir. No <productname>PostgreSQL</productname>, todos os
      cursores são insensíveis; atualmente esta palavra chave não produz efeito,
      estando presente por motivo de compatibilidade com o padrão SQL.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>SCROLL</literal></term>
    <term><literal>NO SCROLL</literal></term>
    <listitem>
     <para>
      <literal>SCROLL</literal> (rolar) especifica que o cursor pode ser
      utilizado para trazer linhas de uma maneira não seqüencial (por exemplo,
      para trás). Dependendo da complexidade do plano de execução
      da consulta, especificar <literal>SCROLL</literal> pode impor
      uma penalidade de desempenho no tempo de execução da consulta.
      <literal>NO SCROLL</literal> especifica que o cursor não pode
      ser utilizado para trazer linhas de uma maneira não seqüencial.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>WITH HOLD</literal></term>
    <term><literal>WITHOUT HOLD</literal></term>
    <listitem>
     <para>
      <literal>WITH HOLD</literal> especifica que o cursor pode
      continuar sendo utilizado após a transação que o criou
      ter sido efetivada com sucesso. <literal>WITHOUT HOLD</literal> especifica
      que o cursor não pode ser utilizado fora da transação que o criou.
      Se nem <literal>WITHOUT HOLD</literal> nem
      <literal>WITH HOLD</literal> for especificado, <literal>WITHOUT
      HOLD</literal> é o padrão.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">consulta</replaceable></term>
    <listitem>
     <para>
      O comando <command>SELECT</command> que produz as linhas a serem
      retornadas pelo cursor.  Consulte o comando <xref linkend="sql-select"
      endterm="sql-select-title"> para obter informações adicionais sobre
      consultas válidas.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>FOR READ ONLY</literal></term>
    <term><literal>FOR UPDATE</literal></term>
    <listitem>
     <para>
      <literal>FOR READ ONLY</literal> indica que o cursor será utilizado
      no modo somente-leitura. <literal>FOR UPDATE</literal>
      indica que o cursor será utilizado para atualizar tabelas. Uma vez que
      atualizações por cursor não são suportadas pelo
      <productname>PostgreSQL</productname> no momento, especificar <literal>FOR
      UPDATE</literal> causa uma mensagem de erro, e especificar
      <literal>FOR READ ONLY</literal> não produz efeito.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">coluna</replaceable></term>
    <listitem>
     <para>
      Colunas a serem atualizadas pelo cursor.
      Uma vez que atualizações por cursor não são suportadas pelo
      <productname>PostgreSQL</productname> no momento, a cláusula
      <literal>FOR UPDATE</literal> provoca uma mensagem de erro.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   As palavras chave <literal>BINARY</literal>,
   <literal>INSENSITIVE</literal> e <literal>SCROLL</literal>
   podem estar em qualquer ordem.
  </para>
 </refsect1>

 <refsect1>
  <title>Observações</title>

   <para>
    A menos que <literal>WITH HOLD</literal> seja especificado, o cursor
    criado por este comando poderá ser utilizado apenas dentro da transação
    corrente. Portanto, <command>DECLARE</command> sem <literal>WITH
    HOLD</literal> não possui utilidade fora do bloco de transação: o cursor
    existe apenas até o término da instrução. Por esse motivo, o
    <productname>PostgreSQL</productname> relata um erro se
    este comando for utilizado fora de um bloco de transação.
    Devem ser utilizados os comandos
    <xref linkend="sql-begin" endterm="sql-begin-title">,
    <xref linkend="sql-commit" endterm="sql-commit-title">
    e
    <xref linkend="sql-rollback" endterm="sql-rollback-title">
    para definir um bloco de transação.
   </para>

   <para>
    Se <literal>WITH HOLD</literal> for especificado, e a transação
    que criou o cursor for efetivada com sucesso, o cursor pode
    continuar sendo acessado pelas transações seguintes na mesma
    sessão (Mas se a transação que o criou for interrompida, o cursor
    é removido). O cursor criado com <literal>WITH HOLD</literal>
    é fechado quando um comando <command>CLOSE</command> explícito é
    executado para o cursor, ou quando a sessão termina. Na implementação atual,
    as linhas representadas por um cursor mantido são copiadas para um arquivo
    temporário, ou para uma área de memória, para permanecerem disponíveis para
    as transações seguintes.
   </para>

   <para>
    A opção <literal>SCROLL</literal> deve ser especificada ao se definir um
    cursor utilizado para trazer para trás. Isto é requerido pelo padrão SQL.
    Entretanto, para manter a compatibilidade com as versões anteriores,
    o <productname>PostgreSQL</productname> permite trazer para trás sem a opção
    <literal>SCROLL</literal>, se o plano da consulta do cursor for simples o
    suficiente para que nenhum trabalho extra seja necessário para isto.
    Entretanto, aconselha-se aos desenvolvedores de aplicativos a não confiar na
    utilização de trazer para trás a partir de um cursor que não tenha sido
    criado com a opção de <literal>SCROLL</literal>.
    Se <literal>NO SCROLL</literal> for especificado, então trazer para trás não
    é permitido em qualquer caso.
   </para>

   <para>
    O padrão SQL somente trata de cursores na linguagem <acronym>SQL</acronym>
    incorporada. O servidor <productname>PostgreSQL</productname>
    não implementa o comando <command>OPEN</command> para
    cursores; o cursor é considerado aberto ao ser declarado.
    Entretanto o <application>ECPG</application>, o pré-processador
    do <productname>PostgreSQL</productname> para a linguagem SQL incorporada,
    suporta as convenções de cursor do padrão SQL, incluindo as que envolvem
    as instruções <command>DECLARE</command> e <command>OPEN</command>.
   </para>
 </refsect1>

 <refsect1>
  <title>Exemplos</title>

  <para>
   Para declarar um cursor:
<programlisting>
DECLARE liahona CURSOR FOR SELECT * FROM filmes;
</programlisting>
   Veja no comando <xref linkend="sql-fetch" endterm="sql-fetch-title">
   mais exemplos de utilização de cursor.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilidade</title>

  <para>
   O padrão SQL permite cursores somente na linguagem <acronym>SQL</acronym>
   incorporada e nos módulos. O <productname>PostgreSQL</productname>
   permite que o cursor seja utilizado interativamente.
  </para>

  <para>
   O padrão SQL permite que os cursores atualizem os dados das tabelas.
   Todos os cursores do <productname>PostgreSQL</productname>
   são somente para leitura.
  </para>

  <para>
   Os cursores binários são uma extensão do
   <productname>PostgreSQL</productname>.
  </para>
 </refsect1>

 <refsect1>
  <title>Consulte também</title>

  <simplelist type="inline">
   <member><xref linkend="sql-close" endterm="sql-close-title"></member>
   <member><xref linkend="sql-fetch" endterm="sql-fetch-title"></member>
   <member><xref linkend="sql-move" endterm="sql-move-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
