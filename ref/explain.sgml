<!--
$PostgreSQL: pgsql/doc/src/sgml/ref/explain.sgml,v 1.35 2005/01/04 00:39:53 tgl Exp $
PostgreSQL documentation
-->

<refentry id="SQL-EXPLAIN">
 <refmeta>
  <refentrytitle id="SQL-EXPLAIN-TITLE">EXPLAIN</refentrytitle>
  <refmiscinfo>SQL - Comandos da Linguagem</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>EXPLAIN</refname>
  <refpurpose>mostra o plano de execução de um comando</refpurpose>
 </refnamediv>

 <indexterm zone="sql-explain">
  <primary>EXPLAIN</primary>
 </indexterm>

 <indexterm zone="sql-explain">
  <primary>comandos preparados</primary>
  <secondary>mostrar o plano do comando</secondary>
 </indexterm>

 <indexterm zone="sql-explain">
  <primary>cursor</primary>
  <secondary>mostrar o plano do comando</secondary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
EXPLAIN [ ANALYZE ] [ VERBOSE ] <replaceable class="parameter">comando</replaceable>
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Descrição</title>

  <para>
   Este comando mostra o plano de execução que o planejador
   do <application>PostgreSQL</application> gera
   para o comando fornecido. O plano de execução mostra como as
   tabelas referenciadas pelo comando são varridas &mdash; por uma
   varredura seqüencial simples, varredura pelo índice, etc. &mdash; e, se
   várias tabelas forem referenciadas, quais algoritmos de junção são utilizados
   para unir as linhas das tabelas de entrada.
  </para>

  <para>
   Do que é mostrado, a parte mais importante é o custo estimado de execução do
   comando, que é a estimativa feita pelo planejador de quanto tempo demora para
   executar o comando (medido em unidades de acesso às páginas do disco).
   Na verdade, são mostrados dois números: o tempo inicial antes que a primeira
   linha possa ser retornada, e o tempo total para retornar todas as linhas.
   Para a maior parte dos comandos o tempo total é o que importa, mas em
   contextos como uma subseleção no <literal>EXISTS</literal>, o planejador
   escolhe o menor tempo inicial em vez do menor tempo total (porque o executor
   pára após ter obtido uma linha). Além disso, se for limitado o número de
   linhas retornadas usando a cláusula <literal>LIMIT</literal>, o planejador
   efetua uma interpolação apropriada entre estes custos para saber qual é
   realmente o plano de menor custo.
  </para>

  <para>
   A opção <literal>ANALYZE</literal> faz o comando ser realmente executado,
   e não apenas planejado. O tempo total decorrido gasto em cada nó do plano
   (em milissegundos) e o número total de linhas realmente retornadas são
   adicionados ao que é mostrado. Esta opção é útil para ver se as estimativas
   do planejador estão próximas da realidade.
  </para>

  <important>
   <para>
    Deve-se ter em mente que o comando é realmente executado
    quando a opção <literal>ANALYZE</literal> é utilizada.
    Embora o comando <command>EXPLAIN</command>
    despreze qualquer saída produzida pelo <command>SELECT</command>,
    os outros efeitos colaterais do comando ocorrem da forma usual.
    Se for desejado utilizar <command>EXPLAIN ANALYZE</command>
    em um comando <command>INSERT</command>, <command>UPDATE</command>,
    <command>DELETE</command> ou <command>EXECUTE</command> sem afetar
    os dados, utilize o seguinte procedimento:
<programlisting>
BEGIN;
EXPLAIN ANALYZE ...;
ROLLBACK;
</programlisting>
   </para>
  </important>
 </refsect1>

 <refsect1>
  <title>Parâmetros</title>

  <variablelist>
   <varlistentry>
    <term><literal>ANALYZE</literal></term>
    <listitem>
     <para>
      Executar o comando e mostrar os tempos reais de execução.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><literal>VERBOSE</literal></term>
    <listitem>
     <para>
      Mostrar a representação interna completa da árvore do plano, em vez
      de apenas um resumo. Geralmente esta opção é útil apenas para
      finalidades especiais de depuração.
      A saída produzida pela opção <literal>VERBOSE</literal> é formatada para
      ser facilmente lida (<literal>pretty-print</literal>) ou não, dependendo
      de como estiver definido o parâmetro de configuração
      <xref linkend="guc-explain-pretty-print">.
     </para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term><replaceable class="parameter">comando</replaceable></term>
    <listitem>
     <para>
      Qualquer comando <command>SELECT</command>, <command>INSERT</command>,
      <command>UPDATE</command>, <command>DELETE</command>,
      <command>EXECUTE</command> ou <command>DECLARE</command>,
      cujo plano de execução se deseja ver.
     </para>
    </listitem>
   </varlistentry>
  </variablelist>
 </refsect1>

 <refsect1>
  <title>Observações</title>

  <para>
   Existe apenas documentação esparsa sobre o uso da informação do
   custo do otimizador no <productname>PostgreSQL</productname>.
   Consulte a <xref linkend="using-explain"> para obter informações adicionais.
  </para>

  <para>
   Para que o planejador de comandos do <productname>PostgreSQL</productname>
   esteja razoavelmente informado para tomar decisões ao otimizar os comandos,
   o comando <command>ANALYZE</command> deve ser executado para registrar as
   estatísticas sobre a distribuição dos dados dentro da tabela.
   Se isto não tiver sido feito (ou se a distribuição estatística dos dados da
   tabela mudou de forma significativa desde a última vez que o comando
   <command>ANALYZE</command> foi executado), os custos estimados têm pouca
   chance de estarem em conformidade com as verdadeiras propriedades do comando
   e, conseqüentemente, pode ser escolhido um plano de comando inferior.
  </para>

  <para>
   Antes do <application>PostgreSQL</application> 7.3, o plano
   era mostrado na forma de uma mensagem <literal>NOTICE</literal>.
   Agora aparece na forma do resultado de uma consulta
   (formatado como uma tabela de uma única coluna do tipo texto).
  </para>
 </refsect1>

 <refsect1>
  <title>Exemplos</title>

  <para>
   Mostrar o plano para uma consulta simples em uma
   tabela com uma única coluna <type>integer</type> e 10.000 linhas:

<programlisting>
EXPLAIN SELECT * FROM foo;

                       QUERY PLAN
---------------------------------------------------------
 Seq Scan on foo  (cost=0.00..155.00 rows=10000 width=4)
(1 linha)
</programlisting>
  </para>

  <para>
   Havendo um índice, e sendo feita uma consulta com uma condição
   <literal>WHERE</literal> indexável, o comando <command>EXPLAIN</command>
   pode mostrar um plano diferente:

<programlisting>
EXPLAIN SELECT * FROM foo WHERE i = 4;

                         QUERY PLAN
--------------------------------------------------------------
 Index Scan using fi on foo  (cost=0.00..5.98 rows=1 width=4)
   Index Cond: (i = 4)
(2 linhas)
</programlisting>
  </para>

  <para>
   O exemplo abaixo mostra o plano para
   uma consulta contendo uma função de agregação:

<programlisting>
EXPLAIN SELECT sum(i) FROM foo WHERE i &lt; 10;

                             QUERY PLAN
---------------------------------------------------------------------
 Aggregate  (cost=23.93..23.93 rows=1 width=4)
   -&gt;  Index Scan using fi on foo  (cost=0.00..23.92 rows=6 width=4)
         Index Cond: (i &lt; 10)
(3 linhas)
</programlisting>
  </para>

  <para>
   Abaixo está um exemplo da utilização do comando
   <command>EXPLAIN EXECUTE</command>
   para mostrar o plano para uma consulta preparada:

<programlisting>
PREPARE query(int, int) AS SELECT sum(bar) FROM test
    WHERE id &gt; $1 AND id &lt; $2
    GROUP BY foo;

EXPLAIN ANALYZE EXECUTE query(100, 200);

                                                       QUERY PLAN
-------------------------------------------------------------------------------------------------------------------------
 HashAggregate  (cost=39.53..39.53 rows=1 width=8) (actual time=0.661..0.672 rows=7 loops=1)
   -&gt;  Index Scan using test_pkey on test  (cost=0.00..32.97 rows=1311 width=8) (actual time=0.050..0.395 rows=99 loops=1)
         Index Cond: ((id &gt; $1) AND (id &lt; $2))
 Total runtime: 0.851 ms
(4 linhas)
</programlisting>
  </para>

  <para>
   Obviamente, os números específicos mostrados aqui dependem do conteúdo real
   das tabelas envolvidas. Deve ser observado, também, que os números, e mesmo a
   estratégia selecionada para o comando, podem variar entre versões diferentes
   do <productname>PostgreSQL</productname> devido a melhorias no planejador.
   Além disso, o comando <command>ANALYZE</command> utiliza amostragem aleatória
   para estimar as estatísticas dos dados; portanto, é possível que as
   estimativas de custo mudem após a execução do comando
   <command>ANALYZE</command>, mesmo que a distribuição real dos dados
   da tabela não tenha mudado.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilidade</title>

  <para>
   Não existe o comando <command>EXPLAIN</command> no padrão SQL.
  </para>
 </refsect1>

 <refsect1>
  <title>Consulte também</title>

  <simplelist type="inline">
   <member><xref linkend="sql-analyze" endterm="sql-analyze-title"></member>
  </simplelist>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:"/usr/lib/sgml/catalog"
sgml-local-ecat-files:nil
End:
-->
