<!-- $PostgreSQL: pgsql/doc/src/sgml/ref/set_constraints.sgml,v 1.12 2004/09/10 18:39:53 tgl Exp $ -->
<refentry id="SQL-SET-CONSTRAINTS">
 <refmeta>
  <refentrytitle id="SQL-SET-CONSTRAINTS-title">SET CONSTRAINTS</refentrytitle>
  <refmiscinfo>SQL - Comandos da Linguagem</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SET CONSTRAINTS</refname>
  <refpurpose>define os modos de verificação da restrição na transação corrente</refpurpose>
 </refnamediv>

 <indexterm zone="sql-set-constraints">
  <primary>SET CONSTRAINTS</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
SET CONSTRAINTS { ALL | <replaceable class="parameter">nome</replaceable> [, ...] } { DEFERRED | IMMEDIATE }
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Descrição</title>

  <para>
   O comando <command>SET CONSTRAINTS</command> define o comportamento da
   verificação da restrição
   dentro da transação corrente. No modo <literal>IMMEDIATE</literal>
   (imediato), as restrições são verificadas ao final de cada comando. No modo
   <literal>DEFERRED</literal> (postergado), as restrições não são verificadas
   até a transação ser efetivada (<literal>commit</literal>).
   Cada restrição possui seu próprio modo <literal>IMMEDIATE</literal> ou
   <literal>DEFERRED</literal>.
  </para>

  <para>
   Ao ser criada, a restrição sempre recebe uma destas três características:
   <literal>DEFERRABLE INITIALLY DEFERRED</literal> (postergável, inicialmente
   postergada), <literal>DEFERRABLE INITIALLY IMMEDIATE</literal> (postergável,
   inicialmente imediata), ou <literal>NOT DEFERRABLE</literal> (não postergável).
   A terceira classe é sempre <literal>IMMEDIATE</literal> (imediata) e não é
   afetada pelo comando <command>SET CONSTRAINTS</command>.
   As duas primeiras classes começam todas as transações no modo indicado, mas
   seus comportamentos podem ser modificados dentro da transação pelo comando
   <command>SET CONSTRAINTS</command>.
  </para>

  <para>
   O comando <command>SET CONSTRAINTS</command> com uma lista de nomes de
   restrição muda o modo destas restrições apenas (que devem ser todos
   postergáveis).
   Se existirem várias restrições correspondendo a um nome fornecido, todos eles
   são afetados.
   O comando <command>SET CONSTRAINTS ALL</command> muda o modo de todas as
   restrições postergáveis.
  </para>

  <para>
   Quando o comando <command>SET CONSTRAINTS</command> muda o modo da restrição
   de <literal>DEFERRED</literal> para <literal>IMMEDIATE</literal>, o novo
   modo entra em vigor retroativamente: toda modificação de dados pendente,
   que deveria ser verificada no final da transação, é verificada durante
   a execução do comando <command>SET CONSTRAINTS</command>.
   Se alguma destas restrições for violada, o comando
   <command>SET CONSTRAINTS</command> falha (e não muda o modo da restrição).
   Portanto, o comando <command>SET CONSTRAINTS</command> pode ser utilizado
   para obrigar que ocorra a verificação das restrições em um determinado ponto
   da transação.
  </para>

  <para>
   Atualmente, somente as restrições de chave estrangeira são afetadas
   por esta definição. As restrições de verificação (<literal>check</literal>)
   e de unicidade são sempre, efetivamente, não postergáveis.
  </para>
 </refsect1>

 <refsect1>
  <title>Observações</title>

  <para>
   Este comando somente altera o comportamento das restrições dentro da
   transação corrente. Portanto, se este comando for executado fora
   de um bloco de transação
   (par <command>BEGIN</command>/<command>COMMIT</command>), parecerá
   que não produziu nenhum efeito.
  </para>
 </refsect1>

 <refsect1>
  <title>Compatibilidade</title>

  <para>
   Este comando está em conformidade com o comportamento definido no padrão SQL,
   exceto pela limitação que, no <productname>PostgreSQL</productname>, somente
   se aplica às restrições de chave estrangeira.
  </para>

  <para>
   O padrão SQL diz que os nomes das restrições que aparecem no comando
   <command>SET CONSTRAINTS</command> podem ser qualificados pelo esquema.
   Esta funcionalidade ainda não é suportada pelo
   <productname>PostgreSQL</productname>: os nomes não podem ser qualificados,
   e todas as restrições correspondendo ao comando serão afetadas,
   não importando o esquema em que estejam.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
