<!-- $PostgreSQL: pgsql/doc/src/sgml/ref/set_session_auth.sgml,v 1.12 2003/11/29 19:51:39 pgsql Exp $ -->
<refentry id="SQL-SET-SESSION-AUTHORIZATION">
 <refmeta>
  <refentrytitle id="sql-set-session-authorization-title">SET SESSION AUTHORIZATION</refentrytitle>
  <refmiscinfo>SQL - Comandos da Linguagem</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>SET SESSION AUTHORIZATION</refname>
  <refpurpose>define o identificador do usuário da sessão e o identificador do usuário corrente, da sessão corrente</refpurpose>
 </refnamediv>

 <indexterm zone="sql-set-session-authorization">
  <primary>SET SESSION AUTHORIZATION</primary>
 </indexterm>

 <refsynopsisdiv>
<synopsis>
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION <replaceable class="parameter">nome_do_usuário</replaceable>
SET [ SESSION | LOCAL ] SESSION AUTHORIZATION DEFAULT
RESET SESSION AUTHORIZATION
</synopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Descrição</title>

  <para>
   Este comando define o identificador do usuário da sessão,
   e o identificador do usuário corrente, no contexto da sessão SQL corrente,
   como sendo <parameter>nome_do_usuário</parameter>. O nome do usuário pode ser
   escrito tanto como um identificador quanto como um literal cadeia de
   caracteres.
   Usando este comando é possível, por exemplo, se tornar temporariamente um
   usuário sem privilégios e posteriormente voltar a ser um superusuário.
  </para>

  <para>
   O identificador do usuário da sessão é inicialmente definido como sendo o
   (possivelmente autenticado) nome do usuário fornecido pelo cliente.
   O identificador do usuário corrente normalmente é igual ao identificador do
   usuário da sessão, mas pode mudar temporariamente no contexto das funções
   <quote>setuid</quote> e de outros mecanismos semelhantes.
   O identificador do usuário corrente é relevante para verificar as permissões.
  </para>

  <para>
   O identificador do usuário da sessão somente pode ser mudado se o usuário
   inicial da sessão (o <firstterm>usuário autenticado</firstterm>) possuir
   o privilégio de superusuário. Senão, o comando é aceito somente se
   especificar o nome do usuário autenticado.
  </para>

  <para>
   Os modificadores <literal>SESSION</literal> e <literal>LOCAL</literal>
   atuam da mesma forma que atuam no comando
   <xref linkend="SQL-SET" endterm="SQL-SET-title"> comum.
  </para>

  <para>
   As formas <literal>DEFAULT</literal> e <literal>RESET</literal> redefinem os
   identificadores de usuário da sessão e corrente como sendo o nome do usuário
   autenticado originalmente. Estas formas são sempre aceitas.
  </para>
 </refsect1>

 <refsect1>
  <title>Exemplos</title>

<programlisting>
SELECT SESSION_USER, CURRENT_USER;

 session_user | current_user 
--------------+--------------
 pedro        | pedro

SET SESSION AUTHORIZATION 'paulo';

SELECT SESSION_USER, CURRENT_USER;

 session_user | current_user 
--------------+--------------
 paulo        | paulo
</programlisting>
 </refsect1>

 <refsect1>
  <title>Compatibilidade</title>

  <para>
   O padrão SQL permite algumas outras expressões aparecerem no lugar do literal
   <parameter>nome_do_usuário</parameter>, as quais não são importantes
   na prática. O <application>PostgreSQL</application> permite a sintaxe de
   identificador (<literal>"nome_do_usuário"</literal>), que o SQL não permite.
   O padrão SQL não permite este comando durante uma transação;
   O <application>PostgreSQL</application> não faz esta restrição, porque não há
   razão para fazê-la. O padrão deixa os privilégios necessários para executar
   este comando por conta da implementação.
  </para>
 </refsect1>
</refentry>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"../reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
