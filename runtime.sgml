<!--
$PostgreSQL: pgsql/doc/src/sgml/runtime.sgml,v 1.301 2005/01/08 22:13:35 tgl Exp $
-->

<Chapter Id="runtime">
 <Title>Ambiente do servidor em tempo de execução</Title>

 <Para>
  Este capítulo mostra como configurar e executar o servidor de banco de dados,
  e as interações do servidor com o sistema operacional.
 </para>

 <sect1 id="postgres-user">
  <title>A conta de usuário do <productname>PostgreSQL</productname></title>

  <indexterm>
   <primary>usuário postgres</primary>
  </indexterm>

  <para>
   Como todos os outros processos servidor (<literal>daemon</literal>)
   <footnote>
    <para>
     <literal>daemon</literal> &mdash; um programa que em vez de ser chamado
     explicitamente fica adormecido aguardando acontecer alguma condição.
     <ulink url="http://www.catb.org/~esr/jargon/html/D/daemon.html">The Jargon
     File</ulink> (N. do T.)
    </para>
   </footnote>
   que podem ser acessados pelo mundo exterior, é aconselhável executar o
   <productname>PostgreSQL</productname> sob uma conta de usuário em separado.
   Esta conta de usuário somente deve possuir os dados gerenciados pelo
   servidor, não devendo ser compartilhada por outros processos servidor;
   por exemplo, é uma má idéia utilizar o usuário <literal>nobody</literal>.
   Não se aconselha instalar executáveis cujo dono seja este usuário, porque
   sistemas comprometidos poderiam modificar seus próprios binários.
  </para>

  <para>
   Para adicionar uma conta de usuário Unix ao sistema, deve ser procurado o
   comando <command>useradd</command> ou <command>adduser</command>.
   Normalmente é utilizado o nome de usuário <systemitem>postgres</systemitem>,
   que também é o nome assumido nesta documentação, mas se for preferido pode
   ser utilizado outro nome.
  </para>
 </sect1>

 <sect1 id="creating-cluster">
  <title>Criação do agrupamento de bancos de dados</title>

  <indexterm>
   <primary>agrupamento de bancos de dados</primary>
  </indexterm>

  <indexterm>
   <primary>area de dados</primary>
   <see>agrupamento de bancos de dados</see>
  </indexterm>

  <para>
   Antes de ser possível fazer qualquer coisa, deve ser inicializada a área em
   disco para armazenamento dos bancos de dados.
   Isto é chamado de criação do <firstterm>agrupamento de bancos de
   dados</firstterm> (<literal>database cluster</literal>); em vez desse nome,
   o padrão <acronym>SQL</acronym> utiliza o termo agrupamento de catálogos
   (<literal>catalog cluster</literal>).
   Um agrupamento de bancos de dados é uma coleção de bancos de dados gerenciada
   por uma única instância de um servidor de banco de dados em execução.
   Após ser criado, o agrupamento de bancos de dados contém um banco de dados
   chamado <literal>template1</literal>.
   Como o nome sugere (em inglês), este banco de dados é utilizado como modelo
   para os próximos bancos de dados a serem criados; não deve ser utilizado para
   trabalho (Para obter informações sobre a como criar bancos de dados no
   agrupamento deve ser visto o <xref linkend="managing-databases">).
  </para>

  <para>
   Em termos de sistema de arquivos, um agrupamento de bancos de dados é um
   único diretório sob o qual todos os dados são armazenados. Este diretório é
   chamado de <firstterm>diretório de dados</firstterm> ou <firstterm>área de
   dados</firstterm>. A escolha do local onde os dados são armazenados depende
   inteiramente de quem faz a instalação. Não existe nenhum padrão, embora
   sejam usuais locais como <filename>/usr/local/pgsql/data</filename> e
   <filename>/var/lib/pgsql/data</filename>. Para inicializar um agrupamento de
   bancos de dados é utilizado o utilitário <command>initdb</command>,
   <indexterm><primary>initdb</primary></indexterm>
   que é instalado junto com o <productname>PostgreSQL</productname>. O local no
   sistema de arquivos escolhido para o agrupamento de bancos de dados é
   indicado pela opção <option>-D</option> como, por exemplo:
<screen>
<prompt>$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
   Deve ser observado que este comando deve ser executado enquanto conectado
   na conta de usuário do <productname>PostgreSQL</productname>, conforme
   descrito na seção anterior.
  </para>

  <tip>
   <para>
    Pode ser definida a variável de ambiente <envar>PGDATA</envar> como
    alternativa ao uso da opção <option>-D</option>.
    <indexterm><primary><envar>PGDATA</envar></primary></indexterm>
   </para>
  </tip>

  <para>
   O utilitário <command>initdb</command> tenta criar o diretório especificado,
   caso não exista. É provável que não tenha permissão para criar o
   diretório (se for seguido o conselho de criar um usuário sem privilégios).
   Neste caso, o diretório deve ser criado utilizando a conta de usuário
   <literal>root</literal>, e mudado o dono do diretório para o usuário do
   <productname>PostgreSQL</productname>.
   Abaixo está mostrado como deve ser feito:
<screen>
<prompt>root#</prompt> <userinput>mkdir /usr/local/pgsql/data</userinput>
<prompt>root#</prompt> <userinput>chown postgres /usr/local/pgsql/data</userinput>
<prompt>root#</prompt> <userinput>su postgres</userinput>
<prompt>postgres$</prompt> <userinput>initdb -D /usr/local/pgsql/data</userinput>
</screen>
  </para>

  <para>
   O utilitário <command>initdb</command> se recusa a executar quando o
   diretório de dados parece que já foi inicializado.</para>

  <para>
   Como o diretório de dados contém todos os dados armazenados no banco de
   dados, é essencial que esteja seguro contra acessos não autorizados.
   Portanto, o utilitário <command>initdb</command> revoga as permissões de
   acesso de todos, menos do usuário do <productname>PostgreSQL</productname>.
  </para>

  <para>
   Entretanto, embora o conteúdo do diretório esteja seguro, a configuração de
   autenticação de cliente padrão permite qualquer usuário local se conectar ao
   banco de dados, e até mesmo se tornar o superusuário do banco de dados. Caso
   não se confie nos outros usuários locais, recomenda-se utilizar a opção
   <option>-W</option>, <option>--pwprompt</option> ou <option>--pwfile</option>
   do <command>initdb</command>, para atribuir uma senha para o superusuário do
   banco de dados.
   <indexterm><primary>senha</primary><secondary>do superusuário</secondary></indexterm>
   Também pode ser especificado <option>-A md5</> ou <option>-A password</> para
   que não seja utilizado o modo de autenticação padrão <literal>trust</>;
   também pode ser modificado o arquivo <filename>pg_hba.conf</filename>
   gerado após a execução do utilitário <command>initdb</command>,
   <emphasis>antes</> de iniciar o servidor pela primeira vez (Outras abordagens
   razoáveis incluem a utilização da autenticação <literal>ident</literal> e
   permissões do sistema de arquivos para restringir as conexões. Para obter
   informações adicionais deve ser consultado o
   <xref linkend="client-authentication">).
  </para>

  <para>
   O utilitário <command>initdb</command> também inicializa o idioma padrão
   <indexterm><primary>idioma</primary></indexterm> para o agrupamento de
   bancos de dados. Normalmente, simplesmente pega as definições de idioma
   do ambiente e aplica ao banco de dados inicializado. É possível especificar
   um idioma diferente para o banco de dados; informações adicionais sobre
   este assunto podem ser encontradas na <xref linkend="locale">. A ordem de
   classificação utilizada por um determinado agrupamento de bancos de dados é
   definida pelo utilitário <command>initdb</command>, e não pode ser mudada
   posteriormente, a não ser fazendo cópia de segurança de todos os dados,
   executando novamente o <command>initdb</command> e recarregando os dados.
   Também existe impacto no desempenho quando se utiliza um idioma
   diferente de <literal>C</> ou <literal>POSIX</>. Portanto, é importante
   fazer a escolha correta da primeira vez.
  </para>

  <para>
   O utilitário <command>initdb</command> também define a codificação de
   caracteres padrão para o agrupamento de bancos de dados. Normalmente deve
   ser escolhida uma codificação que corresponda à definição do idioma.
   Para obter detalhes deve ser consultada a <xref linkend="multibyte">.
  </para>
 </sect1>

 <sect1 id="postmaster-start">
  <title>Inicialização do servidor de banco de dados</title>

  <para>
   Antes que os usuários possam acessar o banco de dados, o servidor de banco
   de dados deve ser colocado em execução. O programa servidor de banco de
   dados chama-se <command>postmaster</command>.
   <indexterm><primary>postmaster</primary></indexterm>
   O <command>postmaster</command> precisa saber onde se encontram os dados a
   serem utilizados. Isto é feito através da opção <option>-D</option>.
   Portanto, a maneira mais simples de colocar o servidor em execução é usando
<screen>
<prompt>$</prompt> <userinput>postmaster -D /usr/local/pgsql/data</userinput>
</screen>
   que deixa o servidor processando em primeiro plano. Deve ser executado
   conectado à conta de usuário do <productname>PostgreSQL</productname>.
   Sem a opção <option>-D</option> o servidor tenta utilizar o diretório
   de dados especificado na variável de ambiente <envar>PGDATA</envar>.
   Se esta variável também não existir, então a inicialização falha.
  </para>

  <para>
   Normalmente é melhor executar o <command>postmaster</command> em segundo
   plano, e neste caso a sintaxe usual para o interpretador de comandos é:
<screen>
<prompt>$</prompt> <userinput>postmaster -D /usr/local/pgsql/data &gt;arquivo_de_log 2&gt;&amp;1 &amp;</userinput>
</screen>
   É importante armazenar as saídas <systemitem>stdout</systemitem> e
   <systemitem>stderr</systemitem> do servidor em algum lugar, conforme mostrado
   acima. Isto é útil para fins de auditoria e para diagnosticar problemas
   (A <xref linkend="logfile-maintenance"> contém uma explicação mais detalhada
   sobre o manuseio do arquivo de <literal>log</literal>).
  </para>

  <para>
   O <command>postmaster</command> também aceita várias outras opções de linha
   de comando. Para obter informações adicionais deve ser consultada a página de
   referência do <xref linkend="app-postmaster"> e a
   <xref linkend="runtime-config"> abaixo.
  </para>

  <para>
   A sintaxe do interpretador de comandos pode se tornar entediante em pouco
   tempo. Por isso é fornecido o programa <xref linkend="app-pg-ctl">
   <indexterm><primary>pg_ctl</primary></indexterm>
   para simplificar algumas tarefas. Por exemplo,
<programlisting>
pg_ctl start -l arquivo_de_log
</programlisting>
   inicializa o servidor em segundo plano, e envia a saída para o arquivo de
   <literal>log</literal> especificado. A opção <option>-D</option> possui o
   mesmo significado para este programa que no <command>postmaster</command>.
   O programa <command>pg_ctl</command> também pode parar o servidor.
  </para>

  <para>
   Normalmente se quer que o servidor de banco de dados seja inicializado
   quando o computador é ligado.
   <indexterm><primary>boot</primary><secondary>inicializar o servidor durante</secondary></indexterm>
   Os scripts de auto-inicialização são específicos de cada sistema operacional.
   Existem alguns scripts distribuídos junto com o
   <productname>PostgreSQL</productname> no diretório
   <filename class="directory">contrib/start-scripts</filename>.
   Para instalar estes scripts é necessário o privilégio de
   <literal>root</literal>.
  </para>

  <para>
   Sistemas diferentes possuem convenções diferentes para inicializar
   processos durante a inicialização do sistema operacional. Muitos sistemas
   possuem o arquivo <filename>/etc/rc.local</filename> ou
   <filename>/etc/rc.d/rc.local</filename>. Outros utilizam diretórios
   <filename class="directory">rc.d</filename>. Seja da maneira que for,
   o servidor deve executar sob a conta de usuário do
   <productname>PostgreSQL</productname>, <emphasis>e não sob
   <literal>root</literal></emphasis> ou qualquer outro usuário.
   Portanto, os comandos provavelmente devem ser construídos utilizando
   <literal>su -c '...' postgres</literal>. Por exemplo:
<programlisting>
su -c 'pg_ctl start -D /usr/local/pgsql/data -l arquivo_de_log' postgres
</programlisting>
  </para>

  <para>
   Abaixo são mostradas algumas sugestões mais específicas para vários sistemas
   operacionais (Os valores genéricos devem ser sempre substituídos pelo
   diretório de instalação e nome de usuário apropriados para cada caso).

   <itemizedlist>
    <listitem>
     <para>
      No <productname>FreeBSD</productname> deve ser visto o arquivo
      <filename>contrib/start-scripts/freebsd</filename> na
      distribuição do código fonte do <productname>PostgreSQL</productname>.
      <indexterm><primary>FreeBSD</primary><secondary>script de inicialização</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      No <productname>OpenBSD</productname> devem ser adicionadas as seguintes
      linhas ao arquivo <filename>/etc/rc.local</filename>:
      <indexterm><primary>OpenBSD</primary><secondary>script de inicialização</secondary></indexterm>
<programlisting>
if [ -x /usr/local/pgsql/bin/pg_ctl -a -x /usr/local/pgsql/bin/postmaster ]; then
    su - -c '/usr/local/pgsql/bin/pg_ctl start -l /var/postgresql/arquivo_de_log -s' postgres
    echo -n ' postgresql'
fi
</programlisting>
     </para>
    </listitem>

    <listitem>
     <para>
      Nos sistemas <productname>Linux</productname> deve ser adicionado
      <indexterm><primary>Linux</primary><secondary>script de inicialização</secondary></indexterm>
<programlisting>
/usr/local/pgsql/bin/pg_ctl start -l arquivo_de_log -D /usr/local/pgsql/data
</programlisting>
      ao arquivo <filename>/etc/rc.d/rc.local</filename>, ou ser visto o arquivo
      <filename>contrib/start-scripts/linux</filename> na
      distribuição do código fonte do <productname>PostgreSQL</productname>.
     </para>
    </listitem>

    <listitem>
     <para>
      No <productname>NetBSD</productname> deve ser utilizado o script de
      inicialização do <productname>FreeBSD</productname> ou do
      <productname>Linux</productname>, conforme se preferir.
      <indexterm><primary>NetBSD</primary><secondary>script de inicialização</secondary></indexterm>
     </para>
    </listitem>

    <listitem>
     <para>
      No <productname>Solaris</productname> deve ser criado um arquivo chamado
      <filename>/etc/init.d/postgresql</filename> contendo a seguinte linha:
      <indexterm><primary>Solaris</primary><secondary>script de inicialização</secondary></indexterm>
<programlisting>
su - postgres -c "/usr/local/pgsql/bin/pg_ctl start -l arquivo_de_log -D /usr/local/pgsql/data"
</programlisting>
      Depois deve ser criado um vínculo simbólico para este arquivo em
      <filename>/etc/rc3.d</filename> como <filename>S99postgresql</filename>.
     </para>
    </listitem>
   </itemizedlist>

  </para>

   <para>
    Enquanto o <command>postmaster</command> está executando, seu identificador
    de processo (<acronym>PID</acronym>) fica armazenado no arquivo
    <filename>postmaster.pid</filename> no diretório de dados. Este arquivo é
    utilizado para impedir que mais de um processo <command>postmaster</command>
    execute usando o mesmo diretório de dados. Também pode ser utilizado para
    parar o processo <command>postmaster</command>.
   </para>

   <sect2 id="postmaster-start-failures">
    <title>Falhas na inicialização do servidor</title>

    <para>
     Existem vários motivos triviais pelos quais a inicialização do servidor
     pode não ser bem-sucedida. Deve ser visto o arquivo de <literal>log</> do
     servidor, ou deve ser feita a inicialização manual do servidor (sem
     redirecionar a saída padrão ou o erro padrão) para ver as mensagens de erro
     mostradas. Abaixo são explicadas detalhadamente algumas das mensagens de
     erro mais comuns.
    </para>

    <para>
<screen>
<computeroutput>
LOG:   could not bind IPv4 socket: Address already in use
HINT:  Is another postmaster already running on port 5432?
       If not, wait a few seconds and retry.
FATAL: could not create TCP/IP listen socket
</computeroutput>

-- Tradução da mensagem

<computeroutput>
LOG:   não foi possível vincular soquete IPv4: Endereço já sendo usado
DICA:  Há outro postmaster usando a porta 5432?
       Se não houver, aguarde uns poucos segundos e tente novamente.
FATAL: não foi possível criar soquete TCP/IP de atendimento
</computeroutput>
</screen>
     Normalmente esta mensagem significa o que sugere: tentou-se inicializar um
     <command>postmaster</command> na mesma porta que outro já estava usando.
     Entretanto, se o núcleo da mensagem de erro não for <emphasis>Endereço
     já sendo usado</emphasis> (<literal>Address already in use</literal>),
     ou alguma variação desta, pode estar ocorrendo um problema diferente.
     Por exemplo, tentar inicializar o <command>postmaster</command> em um
     número de porta reservado pode levar a algo como:
<screen>
<prompt>$</prompt> <userinput>postmaster -p 666</userinput>
<computeroutput>
LOG:   could not bind IPv4 socket: Permission denied
HINT:  Is another postmaster already running on port 666?
       If not, wait a few seconds and retry.
FATAL: could not create TCP/IP listen socket
</computeroutput>

-- Tradução da mensagem

<computeroutput>
LOG:   não foi possível vincular soquete IPv4: Permissão negada
DICA:  Há outro postmaster usando a porta 666?
       Se não houver, aguarde uns poucos segundos e tente novamente.
FATAL: não foi possível criar soquete TCP/IP de atendimento
</computeroutput>
</screen>
    </para>

    <para>
     Uma mensagem como
<screen>
<computeroutput>
FATAL:  could not create shared memory segment: Invalid argument
DETAIL: Failed system call was shmget(key=5440001, size=4011376640, 03600).
</computeroutput>

-- Tradução da mensagem

<computeroutput>
FATAL:   não foi possível criar o segmento de memória compartilhada: Argumento inválido
DETALHE: A chamada de sistema que falhou foi shmget(chave=5440001, tamanho=4011376640, 03600).
</computeroutput>
</screen>
     provavelmente significa que o limite para o tamanho da memória
     compartilhada do núcleo (<literal>kernel</literal>) é menor que a área
     de trabalho que o <productname>PostgreSQL</productname> está tentando criar
     (4011376640 bytes neste exemplo). Pode significar, também, que o núcleo não
     está configurado para dar suporte a memória compartilhada no estilo
     <literal>System-V</literal>. Como recurso temporário pode-se tentar
     inicializar o servidor com um número de <literal>buffers</literal> menor
     que o número normal (sinalizador <option>-B</option>). Mais tarde
     poderá ser necessário reconfigurar o núcleo para aumentar o tamanho de
     memória compartilhada permitido. Esta mensagem também pode ser vista
     quando se tenta inicializar vários servidores na mesma máquina, quando o
     espaço total requisitado excede o limite do núcleo.
    </para>

    <para>
     Um erro como
<screen>
<computeroutput>
FATAL:  could not create semaphores: No space left on device
DETAIL: Failed system call was semget(5440126, 17, 03600).
</computeroutput>

-- Tradução da mensagem

<computeroutput>
FATAL:   não foi possível criar semáforos: Não há espaço suficiente na unidade
DETALHE: A chamada de sistema que falhou foi semget(5440126, 17, 03600).
</computeroutput>
</screen>
     <emphasis>não</emphasis> significa que o espaço em disco está esgotado.
     Significa que o limite do núcleo para o número de semáforos <systemitem
     class="osname">System V</systemitem> é menor que o número de semáforos que
     o <productname>PostgreSQL</productname> deseja criar. Como acima, este
     problema pode ser evitado inicializando o servidor com um número reduzido
     de conexões permitidas (sinalizador <option>-N</option>), e posteriormente
     aumentado o limite do núcleo.
    </para>

    <para>
     Caso ocorra a mensagem de erro <quote>chamada de sistema ilegal</quote>,
     é provável que o núcleo não tenha suporte para memória compartilhada ou
     semáforos. Neste caso, a única opção é reconfigurar o núcleo para habilitar
     estas funcionalidades.
    </para>

    <para>
     Na <xref linkend="sysvipc"> são mostrados detalhes sobre a configuração
     das facilidades de <acronym>IPC</acronym> do
     <systemitem class="osname">System V</systemitem> .
    </para>
   </sect2>

   <sect2 id="client-connection-problems">
    <title>Problemas na conexão do cliente</title>

    <para>
     Embora as condições de erro possíveis no lado cliente sejam bastante
     variadas e dependentes do aplicativo, algumas delas podem estar diretamente
     relacionadas com a maneira como o servidor é inicializado.
     Outras condições diferentes das mostradas abaixo devem estar documentadas
     no próprio aplicativo cliente.
    </para>

    <para>
<screen>
<computeroutput>
psql: could not connect to server: Connection refused
        Is the server running on host "server.joel.com" and accepting
        TCP/IP connections on port 5432?
</computeroutput>

-- Tradução da mensagem

<computeroutput>
psql: não foi possível conectar com o servidor. Conexão recusada
        O servidor estão executando no hospedeiro "server.joel.com"
        e aceitando conexões TCP/IP na porta 5432?
</computeroutput>
</screen>
     Esta é uma falha genérica dizendo <quote>Eu não pude encontrar o servidor
     para me comunicar</quote>. Parece com a mensagem mostrada acima quando se
     tenta uma comunicação TCP/IP. Um engano comum é esquecer de configurar o
     servidor para aceitar conexões TCP/IP.
    </para>

    <para>
     Outra possibilidade é receber esta mensagem de erro ao se tentar uma
     comunicação através do soquete do domínio Unix com o servidor local:
<screen>
<computeroutput>
psql: could not connect to server: No such file or directory
        Is the server running locally and accepting
        connections on Unix domain socket "/tmp/.s.PGSQL.5432"?
</computeroutput>

-- Tradução da mensagem

<computeroutput>
psql: não foi possível conectar com o servidor. Arquivo ou diretório inexistente
        O servidor está executando localmente e aceitando
        conexões no soquete do domínio Unix "/tmp/.s.PGSQL.5432"?
</computeroutput>
</screen>
    </para>

    <para>
     A última linha é útil para verificar se o cliente está tentando se conectar
     ao local correto. Se exitir realmente um servidor executando neste local,
     o núcleo da mensagem de erro será normalmente
     <emphasis>Conexão recusada</emphasis>
     (<literal>Connection refused</literal>) ou
     <emphasis>Arquivo ou diretório inexistente</emphasis>
     (<literal>No such file or directory</literal>),
     como mostrado (É importante perceber que neste contexto
     <emphasis>Conexão recusada</emphasis> <emphasis>não</emphasis> significa
     que o servidor recebeu o pedido de conexão e o recusou. Este caso produz
     uma mensagem diferente, conforme mostrado na
     <xref linkend="client-authentication-problems">). Outras mensagens de erro,
     como <emphasis>Tempo de conexão esgotado</emphasis>, podem
     indicar problemas mais básicos, como falta de conectividade da rede.
    </para>
   </sect2>
  </sect1>

  <sect1 id="runtime-config">
   <Title>Configuração em tempo de execução</Title>

   <indexterm>
    <primary>configuração</primary>
    <secondary>do servidor</secondary>
   </indexterm>

   <para>
    Existem vários parâmetros de configuração que afetam o comportamento do
    sistema de banco de dados. Nesta seção é descrito como definir os parâmetros
    de configuração; as subseções abaixo discutem cada parâmetro em detalhe.
   </para>

   <para>
    Não há diferença entre letras maiúsculas e minúsculas nos nomes dos
    parâmetros. Todo parâmetro aceita um valor de um destes quatro tipos:
    booleano, inteiro, ponto flutuante ou cadeia de caracteres. Os valores
    booleanos podem ser escritos como <literal>ON</literal>,
    <literal>OFF</literal>, <literal>TRUE</literal>, <literal>FALSE</literal>,
    <literal>YES</literal>, <literal>NO</literal>, <literal>1</literal> ou
    <literal>0</literal> (sem distinção entre letras maiúsculas e minúsculas),
    ou qualquer prefixo não ambíguo destes.
   </para>

   <para>
    Uma forma de definir estes parâmetros é editar o arquivo
    <filename>postgresql.conf</filename>,
    <indexterm><primary>postgresql.conf</primary></indexterm>
    normalmente presente no diretório de dados
    (O utilitário <command>initdb</command> instala uma cópia padrão neste
    diretório). Um exemplo de como este arquivo se parece é:
<programlisting>
# Isto é um comentário
log_connections = yes
log_destination = 'syslog'
search_path = '$user, public'
</programlisting>
    É especificado um parâmetro por linha. O sinal de igual entre o nome e o
    valor é opcional. Espaços em branco não são significativos e as linhas em
    branco são ignoradas. O caractere jogo-da-velha (<literal>#</literal>)
    insere comentário em qualquer posição. Os valores dos parâmetros, que não
    são identificadores simples ou números, devem estar entre apóstrofos
    (<literal>'</literal>).
   </para>

   <para>
    <indexterm>
     <primary>SIGHUP</primary>
    </indexterm>
    <indexterm><primary>SIGHUP</primary></indexterm>
    O arquivo de configuração é lido novamente sempre que o processo
    <command>postmaster</command> recebe do sistema o sinal
    <systemitem>SIGHUP</systemitem> (cuja forma mais fácil de enviar é através
    de <literal>pg_ctl reload</literal>). O <command>postmaster</command>
    também propaga este sinal para todos os processos servidor em execução,
    para que as sessões em andamento também leiam os novos valores.
    Como alternativa, o sinal pode ser enviado diretamente para um único
    processo servidor. Alguns parâmetros somente podem ser definidos durante a
    inicialização do servidor; qualquer modificação de seus valores no arquivo
    de configuração será ignorada até que o servidor seja reiniciado.
   </para>

   <para>
    A segunda forma de definir estes parâmetros de configuração é fornecê-los
    como opção de linha de comando para o <command>postmaster</command>, como em:
<programlisting>
postmaster -c log_connections=yes -c log_destination='syslog'
</programlisting>
    As opções de linha de comando têm precedência sobre qualquer definição
    conflitante presente no arquivo <filename>postgresql.conf</filename>.
    Deve ser observado que isto significa não ser possível alterar em tempo
    de execução um valor fornecido como opção de linha de comando editando o
    arquivo <filename>postgresql.conf</filename>. Portanto, embora o método
    linha de comando possa ser conveniente, pode causar perda de flexibilidade.
   </para>

   <para>
    Ocasionalmente, também é útil fornecer uma opção de linha de comando para
    apenas uma determinada sessão. Para esta finalidade pode ser utilizada a
    variável de ambiente <envar>PGOPTIONS</envar> no lado cliente:
<programlisting>
env PGOPTIONS='-c geqo=off' psql
</programlisting>
    (Funciona para todo aplicativo cliente baseado na biblioteca
    <application>libpq</application>, e não apenas para o
    <application>psql</application>). Deve ser observado que não funciona para
    os parâmetros que são fixados na inicialização do servidor, ou que devem
    ser especificados no arquivo <filename>postgresql.conf</filename>.
   </para>

   <para>
    Além disso, é possível atribuir um conjunto de definições de parâmetro a
    um usuário ou a um banco de dados. Sempre que uma sessão é iniciada,
    as definições padrão para o usuário ou para o banco de dados são carregadas.
    Para configurar estas definições são utilizados os comandos
    <xref linkend="sql-alteruser" endterm="sql-alteruser-title"> e
    <xref linkend="sql-alterdatabase" endterm="sql-alterdatabase-title">,
    respectivamente.
    As definições para o banco de dados têm precedência sobre qualquer definição
    recebida pela linha de comando do <command>postmaster</command> ou através
    do arquivo de configuração. Por sua vez, as definições para o usuário
    têm precedência sobre as definições para o banco de dados;
    as opções para a sessão têm precedência sobre as duas.
   </para>

   <para>
    Alguns parâmetros podem ser alterados nas sessões <acronym>SQL</acronym>
    individuais utilizando o comando
    <xref linkend="SQL-SET" endterm="SQL-SET-title"> como, por exemplo:
<programlisting>
SET ENABLE_SEQSCAN TO OFF;
</programlisting>
    Se o comando <command>SET</command> for permitido, tem precedência sobre
    todas as outras fontes de valor para parâmetros.
    Alguns parâmetros não podem ser alterados através do comando
    <command>SET</command>: por exemplo, parâmetros que controlam um
    comportamento que não pode ser alterado sem reiniciar o
    <productname>PostgreSQL</productname>.
    Além disso, alguns parâmetros podem ser alterados através dos comandos
    <command>SET</command> ou <command>ALTER</command> pelos superusuários,
    mas não pelos usuários comuns.
   </para>

   <para>
    O comando <xref linkend="SQL-SHOW" endterm="SQL-SHOW-title">
    permite ver o valor corrente de todos os parâmetros.
   </para>

   <para>
    A tabela virtual <structname>pg_settings</structname> (descrita na
    <xref linkend="view-pg-settings">) também permite ver e atualizar os
    parâmetros em tempo de execução da sessão. Equivale ao comando
    <command>SHOW</command> e <command>SET</command>, mas seu uso pode ser mais
    conveniente, porque pode ser feita a junção com outras tabelas, ou feita a
    seleção utilizando a condição de seleção desejada.
   </para>

   <sect2 id="runtime-config-file-locations">
    <title>Locais dos arquivos</title>

     <para>
      Além do arquivo <filename>postgresql.conf</filename> já mencionado,
      o <productname>PostgreSQL</productname> utiliza outros dois arquivos de
      configuração, editados manualmente, para controlar a autenticação de
      clientes, (estes arquivos são mostrados no
      <xref linkend="client-authentication">).
      Por padrão todos estes três arquivos de configuração são armazenados no
      diretório de dados do agrupamento de bancos de dados. Os parâmetros
      descritos nesta subseção permitem colocar os arquivos de configuração em
      outro local (Fazer isto pode facilitar a administração. Em particular,
      geralmente é mais fácil fazer a cópia de segurança dos arquivos de
      configuração quando estes são mantidos separados dos arquivos do
      diretório de dados).
     </para>

     <variablelist>
     <varlistentry id="guc-data-directory" xreflabel="data_directory">
      <term><varname>data_directory</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>data_directory</></primary>
      </indexterm>
      <listitem>
       <para>
         Especifica o diretório a ser utilizado para armazenamento dos dados.
         Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-config-file" xreflabel="config_file">
      <term><varname>config_file</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>config_file</></primary>
      </indexterm>
      <listitem>
       <para>
         Especifica o arquivo principal de configuração do servidor
         (geralmente chamado <filename>postgresql.conf</>).
         Somente pode ser definido na linha de comando do postmaster.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-hba-file" xreflabel="hba_file">
      <term><varname>hba_file</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>hba_file</></primary>
      </indexterm>
      <listitem>
       <para>
         Especifica o arquivo de configuração para autenticação baseada no
         hospedeiro (normalmente chamado <filename>pg_hba.conf</>).
         Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ident-file" xreflabel="ident_file">
      <term><varname>ident_file</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>ident_file</></primary>
      </indexterm>
      <listitem>
       <para>
         Especifica o arquivo de configuração para a autenticação
         <application>ident</application>
         (normalmente chamado <filename>pg_ident.conf</>).
         Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-external-pid-file" xreflabel="external_pid_file">
      <term><varname>external_pid_file</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>external_pid_file</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica o nome de um arquivo de identificação de processo adicional,
        que o <application>postmaster</application> deve criar para uso pelos
        programas de administração do servidor.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>
     </variablelist>

     <para>
      Em uma instalação padrão, nenhum dos parâmetros acima é definido
      explicitamente. Em vez disso, o diretório de dados é especificado
      através da opção de linha de comando <option>-D</option>, ou através
      da variável de ambiente <envar>PGDATA</envar>, e os arquivos de
      configuração ficam todos no diretório de dados.
     </para>

     <para>
      Se for desejado manter os arquivos de configuração em um local diferente
      do diretório de dados, então a opção de linha de comando <option>-D</> do
      <command>postmaster</command>, ou a variável de ambiente <envar>PGDATA</>,
      deve apontar para o diretório que contém os arquivos de configuração, e o
      parâmetro <varname>data_directory</varname> deve estar definido no arquivo
      <filename>postgresql.conf</filename> (ou na linha de comando) para indicar
      onde o diretório de dados realmente se encontra. Deve ser observado que o
      parâmetro <varname>data_directory</> tem precedência sobre <option>-D</> e
      sobre <envar>PGDATA</envar> para o local do diretório de dados, mas não
      para o local dos arquivos de configuração.
     </para>

     <para>
      Se for desejado, podem ser especificados individualmente os nomes dos
      arquivos e seus locais utilizando os parâmetros <varname>config_file</>,
      <varname>hba_file</varname> e <varname>ident_file</varname>.
      O parâmetro <varname>config_file</> somente pode ser especificado na linha
      de comando do <command>postmaster</command>, mas os outros dois podem ser
      definidos no arquivo de configuração principal. Se, além de
      <varname>data_directory</>, estes outros três parâmetros forem
      definidos explicitamente, então não é necessário especificar
      <option>-D</option> ou <envar>PGDATA</envar>.
     </para>

     <para>
      Quando uma destas três opções é definida, um caminho relativo é
      interpretado como sendo relativo ao diretório onde o
      <command>postmaster</command> é inicializado.
     </para>
   </sect2>

   <sect2 id="runtime-config-connection">
    <title>Conexões e Autenticação</title>

    <sect3 id="runtime-config-connection-settings">
     <title>Definições de conexão</title>

     <variablelist>

     <varlistentry id="guc-listen-addresses" xreflabel="listen_addresses">
      <term><varname>listen_addresses</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>listen_addresses</></primary>
      </indexterm>
      <listitem>
       <para>
         Especifica o endereço, ou endereços, de TCP/IP onde o servidor
         atende as conexões dos aplicativos cliente.
         O valor tem a forma de uma lista de nomes de hospedeiros, ou de
         endereços numéricos de IP, separados por vírgula.
         A entrada especial <literal>*</literal> corresponde a todas as
         interfaces de IP disponíveis.
         Se a lista estiver vazia, o servidor não atende nenhuma interface IP
         e, neste caso, somente podem ser utilizados soquetes do domínio
         Unix para conectar ao servidor de banco de dados.
         O valor padrão é <systemitem class="systemname">localhost</systemitem>,
         que permite serem feitas apenas conexões locais <quote>retornantes</>
         (<literal>loopback</literal>).
         Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-port" xreflabel="port">
      <term><varname>port</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>port</></primary>
      </indexterm>
      <listitem>
       <para>
        A porta TCP onde o servidor está atendendo; 5432 por padrão. Deve ser
        observado que é utilizada a mesma porta em todos os endereços de IP
        onde o servidor atende.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-connections" xreflabel="max_connections">
      <term><varname>max_connections</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_connections</></primary>
      </indexterm>
      <listitem>
       <para>
        Determina o número máximo de conexões simultâneas ao servidor de
        banco de dados.
        O valor típico é 100, mas pode ser menor se a configuração do núcleo do
        sistema operacional não não tiver capacidade para suportar este valor
        (conforme determinado durante o <application>initdb</application>).
        Somente pode ser definido na inicialização do servidor.
       </para>

       <para>
        O aumento deste parâmetro pode fazer com que o
        <productname>PostgreSQL</productname> requisite mais memória
        compartilhada <systemitem class="osname">System V</systemitem> que o
        permitido pela configuração padrão do sistema operacional.
        Para obter informações sobre como ajustar estes parâmetros
        deve ser consultada a <xref linkend="sysvipc">, se for necessário.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-superuser-reserved-connections"
     xreflabel="superuser_reserved_connections">
      <term><varname>superuser_reserved_connections</varname>
      (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>superuser_reserved_connections</></primary>
      </indexterm>
      <listitem>
       <para>
        Determina o número de <quote>encaixes de conexão</quote>
        (<literal>connection slots</literal>), reservados para
        os superusuários do <productname>PostgreSQL</productname> se conectarem.
        Podem estar ativas até <xref linkend="guc-max-connections"> conexões
        simultâneas. Sempre que o número de conexões ativas simultâneas for
        igual ou maior a <varname>max_connections</varname> menos
        <varname>superuser_reserved_connections</varname>, somente serão
        aceitas novas conexões feitas por superusuários.
       </para>

       <para>
        O valor padrão é 2. O valor deve ser menor que o valor de
        <varname>max_connections</varname>.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-directory" xreflabel="unix_socket_directory">
      <term><varname>unix_socket_directory</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>unix_socket_directory</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica o diretório do soquete do domínio Unix onde o servidor está
        atendendo as conexões dos aplicativos cliente. Normalmente o valor padrão
        é <filename>/tmp</filename>, mas pode ser mudado em tempo de construção.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-group" xreflabel="unix_socket_group">
      <term><varname>unix_socket_group</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>unix_socket_group</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o grupo dono do soquete do domínio Unix (O usuário dono do
        soquete é sempre o usuário que inicializa o servidor). Combinado com o
        parâmetro <varname>unix_socket_permissions</varname> pode ser utilizado
        como um mecanismo de controle de acesso adicional para as conexões do
        domínio Unix. Por padrão é uma cadeia de caracteres vazia, que utiliza
        o grupo padrão do usuário corrente.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-unix-socket-permissions" xreflabel="unix_socket_permissions">
      <term><varname>unix_socket_permissions</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>unix_socket_permissions</></primary>
      </indexterm>
      <listitem>
       <para>
        Define as permissões de acesso do soquete do domínio Unix. Os soquetes
        do domínio Unix utilizam o conjunto usual de permissões do sistema de
        arquivos do Unix. Para o valor deste parâmetro, é esperada uma
        especificação de modo numérica, na forma aceita pelas chamadas de
        sistema <function>chmod</function> e <function>umask</function>
        (Para utilizar o formato octal, como é de costume, o número deve
        começar por <literal>0</literal> (zero)).
       </para>

       <para>
        As permissões padrão são <literal>0777</literal>, significando que
        qualquer um pode se conectar. Alternativas razoáveis são
        <literal>0770</literal> (somente o usuário e o grupo, consulte também
        <varname>unix_socket_group</varname>), e <literal>0700</literal>
        (somente o usuário); deve ser observado que, na verdade, para soquetes
        do domínio Unix somente a permissão de escrita tem importância, não
        fazendo sentido conceder ou revogar permissões de leitura e de execução.
       </para>

       <para>
        Este mecanismo de controle de acesso é independente do descrito
        no <xref linkend="client-authentication">.
       </para>

       <para>
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-rendezvous-name" xreflabel="rendezvous_name">
      <term><varname>rendezvous_name</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>rendezvous_name</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica o nome de difusão (<literal>broadcast</literal>)
        <productname>Rendezvous</productname>.
        Por padrão é utilizado o nome do computador, especificado através de uma
        cadeia de caracteres vazia ('').
        É ignorado quando o servidor não é compilado com suporte
        a <productname>Rendezvous</productname>.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-connection-security">
     <title>Segurança e autenticação</title>

     <variablelist>
     <varlistentry id="guc-authentication-timeout" xreflabel="authentication_timeout">
      <term><varname>authentication_timeout</varname> (<type>integer</type>)</term>
      <indexterm><primary>timeout</><secondary>client authentication</></indexterm>
      <indexterm><primary>autenticação do cliente</primary><secondary>tempo esgotado durante</></indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>authentication_timeout</></primary>
      </indexterm>

      <listitem>
       <para>
        Tempo máximo, em segundos, para completar a autenticação do cliente.
        Se a tentativa de tornar-se cliente não completar o protocolo de
        autenticação nesta quantidade de tempo, o servidor derruba a conexão.
        Isto impede que clientes travados fiquem ocupando a conexão
        indefinidamente.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
        O valor padrão é 60.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-ssl" xreflabel="ssl">
      <term><varname>ssl</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>ssl</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita conexões <acronym>SSL</acronym>. Por favor leia a
        <xref linkend="ssl-tcp"> antes de utilizar este parâmetros.
        O valor padrão é falso.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-password-encryption" xreflabel="password_encryption">
      <term><varname>password_encryption</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>password_encryption</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando é especificada uma senha em
        <xref linkend="sql-createuser" endterm="sql-createuser-title"> ou
        <xref linkend="sql-alteruser" endterm="sql-alteruser-title">,
        sem que seja escrito <literal>ENCRYPTED</literal> ou
        <literal>UNENCRYPTED</literal>, este parâmetro determina se a senha
        deve ser criptografada.
        O valor padrão é verdade (criptografar a senha).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-krb-server-keyfile" xreflabel="krb_server_keyfile">
      <term><varname>krb_server_keyfile</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>krb_server_keyfile</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o local do arquivo de chave do servidor
        <literal>Kerberos</literal>.
        Para obter detalhes deve ser consultada a <xref linkend="kerberos-auth"> .
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-db-user-namespace" xreflabel="db_user_namespace">
      <term><varname>db_user_namespace</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>db_user_namespace</></primary>
      </indexterm>
      <listitem>
       <para>
        Permite nomes de usuário por banco de dados.
        O valor padrão é falso.
       </para>

       <para>
        Se o valor for verdade, os usuários devem ser criados como
        <literal>nome_do_usuário@nome_bd</literal>.
        Quando o <literal>nome_do_usuário</literal> é passado por um cliente se
        conectando, são anexados <literal>@</literal> e o nome do banco de dados
        ao nome do usuário, então o servidor procura por este nome de usuário
        específico do banco de dados.
        Deve ser observado que, no ambiente SQL, para criar nomes de usuário
        contendo <literal>@</literal> é necessário colocar o nome de usuário
        entre aspas.
       </para>

       <para>
        Quando o valor deste parâmetro é verdade, ainda podem ser criados
        usuários globais comuns. Deve apenas ser anexado o caractere
        <literal>@</literal> à especificação do nome de usuário no cliente.
        O caractere <literal>@</literal> será retirado antes do nome de usuário
        ser procurado pelo servidor.
       </para>

       <note>
        <para>
         Esta funcionalidade foi criada como uma medida temporária até que
         seja encontrada uma solução definitiva, quando então será removida.
        </para>
       </note>
      </listitem>
     </varlistentry>

    </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-resource">
    <title>Consumo de recursos</title>

    <sect3 id="runtime-config-resource-memory">
     <title>Memória</title>

     <variablelist>
     <varlistentry id="guc-shared-buffers" xreflabel="shared_buffers">
      <term><varname>shared_buffers</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>shared_buffers</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o número de <literal>buffers</literal> de memória compartilhada,
        utilizados pelo servidor de banco de dados.
        O valor típico é 1000, mas pode ser menor se a configuração do núcleo do
        sistema operacional não não tiver capacidade para suportar este valor
        (conforme determinado durante o <application>initdb</application>).
        Cada <literal>buffer</literal> possui 8192 bytes, a menos que seja
        escolhido um valor diferente para <literal>BLCKSZ</literal> ao
        construir o servidor.
        O valor definido deve ser pelo menos igual a 16, assim como pelo menos
        duas vezes o valor de <xref linkend="guc-max-connections">;
        entretanto, normalmente é necessário definir um valor bem maior que o
        mínimo para obter um bom desempenho.
        São recomendados valores de alguns poucos milhares para instalações de
        produção.
        Somente pode ser definido na inicialização do servidor.
       </para>

       <para>
        O aumento deste parâmetro pode fazer com que o
        <productname>PostgreSQL</productname> requisite mais memória
        compartilhada <systemitem class="osname">System V</systemitem> que o
        permitido pela configuração padrão do sistema operacional.
        Para obter informações sobre como ajustar estes parâmetros
        deve ser consultada a <xref linkend="sysvipc">, se for necessário.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-work-mem" xreflabel="work_mem">
      <term><varname>work_mem</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>work_mem</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica a quantidade de memória utilizada pelas operações internas de
        classificação e tabelas de dispersão (<literal>hash tables</literal>),
        antes de alternar para arquivos temporários em disco.
        O valor é especificado em kilobytes, e o valor padrão é 1024 kilobytes
        (1 MB).
        Deve ser observado que, em uma consulta complexa, podem ser executadas
        várias classificações ou operações de <literal>hash</literal> em
        paralelo; cada uma podendo utilizar tanta memória quanto especificado
        por este parâmetro, antes de colocar os dados em arquivos temporários.
        Além disso, diversas sessões em execução podem estar fazendo operações
        de classificação simultaneamente.
        Portanto, a memória total utilizada pode ser várias vezes o valor de
        <varname>work_mem</varname>;
        é necessário ter este fato em mente ao escolher o valor.
        As operações de classificação são utilizadas por <literal>ORDER BY</>,
        <literal>DISTINCT</> e junções por mesclagem (<literal>merge
        joins</literal>).
        As tabelas de dispersão (<literal>hash tables</literal>) são utilizadas
        em junções de dispersão (<literal>hash joins</literal>), agregações
        baseadas em dispersão (<literal>hash-based aggregation</literal>), e no
        processamento baseado em dispersão (<literal>hash-based
        processing</literal>) de subconsultas <literal>IN</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-maintenance-work-mem" xreflabel="maintenance_work_mem">
      <term><varname>maintenance_work_mem</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>maintenance_work_mem</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica a quantidade máxima de memória que pode ser utilizada pelas
        operações de manutenção, como <command>VACUUM</command>, <command>CREATE
        INDEX</> e <command>ALTER TABLE ADD FOREIGN KEY</command>.
        O valor é especificado em kilobytes, e o valor padrão é 16384 kilobytes
        (16 MB).
        Uma vez que somente pode ser executada uma destas operações por vez em
        uma mesma sessão de banco de dados, e o servidor normalmente não possui
        muitas delas acontecendo ao mesmo tempo, é seguro definir este valor
        significativamente maior que <varname>work_mem</varname>. Definições
        maiores podem melhorar o desempenho do comando <command>VACUUM</command>
        e da restauração de cópias de segurança.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-stack-depth" xreflabel="max_stack_depth">
      <term><varname>max_stack_depth</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_stack_depth</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica a profundidade máxima segura para a pilha de execução do
        servidor. A definição ideal deste parâmetro é o limite do tamanho da
        pilha imposto pelo núcleo do sistema operacional (conforme definido
        pelo comando <literal>ulimit -s</literal>
        <footnote>
         <para>
          <literal>ulimit [-SHacdflmnpstuv [limit]]</literal> &mdash;
          Permite controlar os recursos disponíveis para o interpretador de
          comandos (<literal>shell</literal>), e para os processos iniciados
          pelo mesmo, nos sistemas que permitem este controle; -s especifica o
          tamanho máximo da pilha (<literal>stack</literal>). (N. do T.)
         </para>
        </footnote>
        ou seu equivalente local, menos uma margem de segurança em torno de um
        megabyte. A margem de segurança é necessária porque a profundidade da
        pilha não é verificada em todas as rotinas do servidor, mas somente nas
        rotinas potencialmente recursivas chave, como avaliação de expressão.
        Definir o parâmetro acima do limite do núcleo significa que uma função
        recursiva fora de controle pode derrubar um processo servidor individual.
        A definição padrão é 2048 KB (dois megabytes), que é conservadoramente
        pequena e com pouca chance de risco de queda.
        Entretanto, pode ser muito pequena para permitir a execução de funções
        complexas.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-resource-fsm">
     <title>Mapa do espaço livre</title>

     <variablelist>
     <varlistentry id="guc-max-fsm-pages" xreflabel="max_fsm_pages">
      <term><varname>max_fsm_pages</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_fsm_pages</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o número máximo de páginas de disco para as quais o espaço livre
        será acompanhado no mapa de espaço livre compartilhado. São consumidos
        seis bytes de memória compartilhada para cada encaixe de página. O valor
        definido deve ser maior que 16 * <varname>max_fsm_relations</varname>.
        O valor padrão é 20000.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-fsm-relations" xreflabel="max_fsm_relations">
      <term><varname>max_fsm_relations</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_fsm_relations</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o número máximo de relações (tabelas e índices) para as quais
        o espaço livre será acompanhado no mapa de espaço livre compartilhado.
        São consumidos, aproximadamente, 50 bytes de memória compartilhada por
        cada encaixe.
        O valor padrão é 1000.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-resource-kernel">
     <title>Utilização de recursos do núcleo</title>
     <variablelist>

     <varlistentry id="guc-max-files-per-process" xreflabel="max_files_per_process">
      <term><varname>max_files_per_process</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_files_per_process</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o número máximo permitido de arquivos abertos simultaneamente por
        cada subprocesso servidor. O valor padrão é 1000. Se o núcleo tiver
        um limite de segurança por processo, não é necessário se preocupar
        com esta definição. Entretanto, em algumas plataformas (notadamente a
        maioria dos sistemas BSD), o núcleo permite que processos individuais
        abram muito mais arquivos que o sistema pode suportar, quando um grande
        número de processos tenta abrir esta quantidade de arquivos ao mesmo
        tempo.
        Se for vista a mensagem de erro <quote>Muitos arquivos abertos</quote>
        deve-se tentar reduzir esta definição.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-preload-libraries" xreflabel="preload_libraries">
      <term><varname>preload_libraries</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>preload_libraries</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica uma ou mais bibliotecas compartilhadas a serem
        pré-carregadas durante a inicialização do servidor. Pode ser chamada,
        opcionalmente, uma função de inicialização sem parâmetros para cada
        biblioteca. Para especificá-la deve ser adicionado dois-pontos e o nome
        da função de inicialização após o nome da biblioteca. Por exemplo
        <literal>'$libdir/minha_bib:minha_bib_inic'</literal> faz com que
        <literal>minha_bib</literal> seja pré-carregada e
        <literal>minha_bib_inic</literal> seja executada. Para carregar mais de
        uma biblioteca, os nomes devem ser separados por vírgula.
       </para>

       <para>
        Se <literal>minha_bib</literal> ou <literal>minha_bib_inic</literal>
        não for encontrada, a inicialização do servidor não será bem-sucedida.
       </para>

       <para>
        As bibliotecas de linguagem procedural do
        <productname>PostgreSQL</productname> são pré-carregadas desta maneira,
        usualmente utilizando a sintaxe
        <literal>'$libdir/plXXX:plXXX_init'</literal>, onde
        <literal>XXX</literal> é <literal>pgsql</literal>,
        <literal>perl</literal>, <literal>tcl</literal> ou
        <literal>python</literal>.
       </para>

       <para>
        Fazendo a pré-carga da biblioteca compartilhada (e a inicializando, se
        for aplicável), ganha-se o tempo de inicialização da biblioteca quando
        a biblioteca é utilizada pela primeira vez. Entretanto, pode aumentar
        ligeiramente o tempo para inicializar cada novo processo servidor,
        mesmo que o processo nunca utilize a biblioteca.
        Portanto, este parâmetro só é recomendado para bibliotecas utilizadas
        pela maioria das sessões.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>

    <sect3 id="runtime-config-resource-vacuum-cost">
     <title>Retardo do VACUUM baseado no custo</title>

     <para>
      Durante a execução dos comandos
      <xref linkend="sql-vacuum" endterm="sql-vacuum-title"> e
      <xref linkend="sql-analyze" endterm="sql-analyze-title">,
      o sistema mantém um contador interno que acompanha o custo estimado
      das várias operações de E/S que são realizadas. Quando o custo acumulado
      atinge um limite (especificado por <varname>vacuum_cost_limit</varname>),
      o processo que está realizando a operação adormece por um tempo
      (especificado por <varname>vacuum_cost_delay</varname>).
      Depois o contador é reiniciado e a execução continua.
     </para>

     <para>
      O objetivo desta funcionalidade é permitir que os administradores reduzam
      o impacto na E/S gerado por estes comandos sobre as atividades de banco
      de dados simultâneas. Existem diversas situações onde não é muito
      importante que comandos como <command>VACUUM</command> e
      <command>ANALYZE</command> terminem rapidamente; entretanto, geralmente é
      muito importante que estes comandos não interfiram significativamente com
      a capacidade do sistema de realizar outras operações de banco de dados.
      O retardo do <command>VACUUM</command> baseado no custo fornece uma
      maneira dos administradores atingirem este objetivo.
     </para>

     <para>
      Esta funcionalidade está desabilitada por padrão. Para ser habilitada,
      o parâmetro <varname>vacuum_cost_delay</varname> deve ser definido com
      um valor diferente de zero.
     </para>

     <variablelist>
      <varlistentry id="guc-vacuum-cost-delay" xreflabel="vacuum_cost_delay">
       <term><varname>vacuum_cost_delay</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>vacuum_cost_delay</></primary>
       </indexterm>
       <listitem>
        <para>
         A quantidade de tempo, em milissegundos, que o processo adormece
         quando o custo limite é excedido.
         O valor padrão é 0, que desabilita a funcionalidade de retardo do
         <command>VACUUM</command> baseado no custo.
         Valores positivos habilitam o retardo do <command>VACUUM</command>
         baseado no custo.
         Deve ser observado que em muitos sistemas a resolução efetiva de
         adormecimento é de 10 milissegundos; definir
         <varname>vacuum_cost_delay</varname> com um valor que não é múltiplo
         de 10, pode ter o mesmo resultado que definir com o próximo múltiplo
         de 10 maior que o valor especificado.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-hit" xreflabel="vacuum_cost_page_hit">
       <term><varname>vacuum_cost_page_hit</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>vacuum_cost_page_hit</></primary>
       </indexterm>
       <listitem>
        <para>
         O custo estimado para executar o <command>VACUUM</command> em um
         <literal>buffer</literal> encontrado no <literal>buffer cache</literal>
         compartilhado.
         Representa o custo para bloquear o <literal>buffer pool</literal>,
         examinar a tabela <literal>hash</literal> compartilhada, e varrer o
         conteúdo da página. O valor padrão é  1.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-miss" xreflabel="vacuum_cost_page_miss">
       <term><varname>vacuum_cost_page_miss</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>vacuum_cost_page_miss</></primary>
       </indexterm>
       <listitem>
        <para>
         O custo estimado para executar o <command>VACUUM</command> em um
         <literal>buffer</literal> que precisa ser lido no disco. Representa o
         esforço para bloquear o <literal>buffer pool</literal>, examinar a
         tabela <literal>hash</literal> compartilhada, ler o bloco desejado no
         disco e varrer o seu conteúdo. O valor padrão é 10.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-page-dirty" xreflabel="vacuum_cost_page_dirty">
       <term><varname>vacuum_cost_page_dirty</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>vacuum_cost_page_dirty</></primary>
       </indexterm>
       <listitem>
        <para>
         O custo estimado cobrado quando o <command>VACUUM</command> modifica
         um bloco que foi limpo anteriormente. Representa a E/S adicional
         necessária para descarregar no disco novamente um bloco que foi limpo
         anteriormente. O valor padrão é 20.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-vacuum-cost-limit" xreflabel="vacuum_cost_limit">
       <term><varname>vacuum_cost_limit</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>vacuum_cost_limit</></primary>
       </indexterm>
       <listitem>
        <para>
         O custo acumulado que faz com que o processo executando o
         <command>VACUUM</command> adormeça. O valor padrão é 200.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <note>
      <para>
       Existem determinadas operações que prendem bloqueios críticos e que
       devem, portanto, terminar o mais rápido possível.
       O retardo do <command>VACUUM</command> baseado no custo não ocorre
       durante este tipo de operação. Portanto, é possível que o custo acumule
       bem acima do limite especificado. Nestes casos, para evitar retardos
       longos sem utilidade, o retardo real é calculado como
       <varname>vacuum_cost_delay</varname> *
       <varname>accumulated_balance</varname> /
       <varname>vacuum_cost_limit</varname> sendo no máximo igual a
       <varname>vacuum_cost_delay</varname> * 4.
      </para>
     </note>

    </sect3>

    <sect3 id="runtime-config-resource-background-writer">
     <title>Escrita em segundo plano</title>

     <para>
      A partir do <productname>PostgreSQL</> 8.0 passa a existir um servidor em
      separado, chamado de <firstterm>escritor de segundo plano</firstterm>
      (<literal>background writer</literal>), cuja única função é escrever
      <literal>buffers</literal> de memória compartilhada <quote>sujos</quote>
      (<literal>dirty</literal>) no disco. O objetivo é fazer com que raramente,
      ou nunca, os processos servidor que tratam os comandos dos usuários
      tenham que aguardar uma escrita em disco, porque o escritor de segundo
      plano já terá feito esta escrita. Esta funcionalidade também reduz a
      degradação de desempenho associada aos pontos de controle. O escritor de
      segundo plano escreve continuamente as páginas no disco, de modo que no
      momento do ponto de controle somente é necessário escrever algumas poucas
      páginas, em vez de ser necessário escrever uma grande quantidade de
      <literal>buffers</literal> sujos como acontecia anteriormente.
      Entretanto, existe um aumento global na carga de E/S, porque anteriormente
      uma página sujada várias vezes era escrita apenas uma vez no disco no
      período de um ponto de controle, enquanto agora o escritor de segundo
      plano pode escrever esta página no disco várias vezes no mesmo período.
      Na maioria das situações se prefere uma baixa carga contínua do que um
      pico periódico. Os parâmetros vistos nesta seção podem ser utilizados
      para ajustar o comportamento conforme as necessidades locais.
      <footnote>
       <para>
        <literal>Oracle - Processos em segundo plano - DBWR (Database
        Writer)</literal> &mdash;
        O escritor de banco de dados (DBWR) é responsável pela escrita no disco
        dos blocos de dados sujos dos <literal>buffers</literal> de blocos de
        banco de dados. Quando uma transação altera os dados de um bloco de
        dados, o bloco de dados não precisa ser escrito imediatamente no disco.
        Portanto, o DBWR pode escrever estes dados no disco de uma maneira mais
        eficiente que escrever ao término de cada transação. O DBWR geralmente
        só escreve quando há necessidade de <literal>buffers</literal> de blocos
        de banco de dados para os dados serem lidos. Os dados são escritos
        usando o critério <quote>usados menos recentemente</quote>.
        <ulink url="http://oracle.basisconsultant.com/oracle_architecture.htm">
        Oracle Architecture</ulink> (N. do T.)
       </para>
      </footnote>
     </para>

     <variablelist>
      <varlistentry id="guc-bgwriter-delay" xreflabel="bgwriter_delay">
       <term><varname>bgwriter_delay</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>bgwriter_delay</></primary>
       </indexterm>
       <listitem>
        <para>
         Especifica o retardo entre rodadas de atividade para escritor de
         segundo plano. A cada rodada o escritor escreve uma quantidade de
         <literal>buffers</literal> sujos (controlado pelos parâmetros mostrados
         a seguir). Os <literal>buffers</literal> selecionados são sempre os
         usados menos recentemente entre os <literal>buffers</literal> sujos
         atuais. Em seguida adormece por <varname>bgwriter_delay</varname>
         milissegundos e repete a operação. O valor padrão é 200.
         Deve ser observado que em muitos sistemas a resolução efetiva do
         adormecimento é de 10 milissegundos; definir
         <varname>bgwriter_delay</varname> com um valor que não é múltiplo
         de 10, pode ter o mesmo resultado que definir com o próximo múltiplo
         de 10 maior que o valor especificado.
         Somente pode ser definido na inicialização do servidor,
         ou no arquivo <filename>postgresql.conf</filename> .
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-percent" xreflabel="bgwriter_percent">
       <term><varname>bgwriter_percent</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>bgwriter_percent</></primary>
       </indexterm>
       <listitem>
        <para>
         A cada rodada não será escrito mais que esta percentagem de
         <literal>buffers</literal> sujos no momento (as frações são
         arredondadas para o próximo número inteiro de
         <literal>buffers</literal> acima). O valor padrão é 1.
         Somente pode ser definido na inicialização do servidor,
         ou no arquivo <filename>postgresql.conf</filename>.
        </para>
       </listitem>
      </varlistentry>

      <varlistentry id="guc-bgwriter-maxpages" xreflabel="bgwriter_maxpages">
       <term><varname>bgwriter_maxpages</varname> (<type>integer</type>)</term>
       <indexterm>
        <primary>parâmetro de configuração <varname>bgwriter_maxpages</></primary>
       </indexterm>
       <listitem>
        <para>
         A cada rodada não será escrito mais que esta quantidade de
         <literal>buffers</literal> sujos. O valor padrão é 100.
         Somente pode ser definido na inicialização do servidor,
         ou no arquivo <filename>postgresql.conf</filename>.
        </para>
       </listitem>
      </varlistentry>
     </variablelist>

     <para>
      A utilização de valores menores para <varname>bgwriter_percent</varname>
      e <varname>bgwriter_maxpages</varname> reduz a carga extra de E/S
      causada pelo escritor de segundo plano, mas deixa mais trabalho a ser
      feito no ponto de controle. Para reduzir o pico de carga nos pontos de
      controle estes valores devem ser aumentados. Para desabilitar inteiramente
      o escritor de segundo plano os parâmetros
      <varname>bgwriter_percent</varname> e/ou
      <varname>bgwriter_maxpages</varname> devem ser definidos iguais a zero.
     </para>
    </sect3>

   </sect2>

   <sect2 id="runtime-config-wal">
    <title>Log de escrita prévia (WAL)</title>

   <para>
    Consulte também a <xref linkend="wal-configuration"> para obter detalhes
    sobre o ajuste do WAL.
   </para>

    <sect3 id="runtime-config-wal-settings">
     <title>Definições</title>
     <variablelist>

     <varlistentry id="guc-fsync" xreflabel="fsync">
      <indexterm>
       <primary>parâmetro de configuração <varname>fsync</></primary>
      </indexterm>
      <term><varname>fsync</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Se o valor deste parâmetro for <literal>true</literal>, o servidor
        <productname>PostgreSQL</productname> utilizará a chamada de sistema
        <function>fsync()</function> em vários lugares para ter certeza que as
        atualizações estão fisicamente escritas no disco. Isto garante que o
        agrupamento de bancos de dados vai ser recuperado em um estado
        consistente após um problema de máquina ou do sistema operacional
       </para>

       <para>
        Entretanto, a utilização de <function>fsync()</function> produz uma
        degradação de desempenho: quando a transação é efetivada, o
        <productname>PostgreSQL</productname> tem de aguardar o sistema
        operacional descarregar o <literal>log</literal> de escrita prévia no
        disco. Quando <varname>fsync</varname> está desabilitado, o sistema
        operacional pode desempenhar da sua melhor maneira a
        <quote>buferização</quote>, ordenação e retardo na escrita. Isto
        pode produzir uma melhora significativa no desempenho. Porém, no caso
        de uma queda do sistema, podem ser perdidos, em parte ou por inteiro,
        os resultados das poucas últimas transações efetivadas. No pior caso,
        os dados podem ficar corrompidos de uma forma irrecuperável (Para esta
        situação a queda do servidor de banco de dados <emphasis>não</emphasis>
        é um fator de risco, somente há risco dos dados ficarem corrompidos no
        caso de queda do sistema operacional).
       </para>

       <para>
        Devido aos riscos envolvidos não existe uma definição universalmente
        aceita para <varname>fsync</varname>. Alguns administradores sempre
        desabilitam <varname>fsync</varname>, enquanto outros só desabilitam
        para cargas de dado pesadas, onde claramente existe um ponto de recomeço
        se algo de errado acontecer, enquanto outros administradores sempre
        deixam <varname>fsync</varname> habilitado. O valor padrão para
        <varname>fsync</varname> é habilitado, para obter o máximo de
        confiabilidade. Havendo confiança no sistema operacional, na máquina,
        e nos utilitários que acompanham (ou na bateria de reserva),
        pode-se levar em consideração desabilitar <varname>fsync</varname>.
       </para>

       <para>
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-sync-method" xreflabel="wal_sync_method">
      <term><varname>wal_sync_method</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>wal_sync_method</></primary>
      </indexterm>
      <listitem>
       <para>
        Método utilizado para obrigar a colocar as atualizações do WAL no disco.
        Os valores possíveis são
        <literal>fsync</literal> (chamada à função
        <function>fsync()</function> a cada efetivação),
        <literal>fdatasync</literal> (chamada à função
        <function>fdatasync()</function> a cada efetivação),
        <literal>open_sync</literal> (escreve os arquivos WAL com a opção
        <symbol>O_SYNC</symbol> da função <function>open()</function>), e
        <literal>open_datasync</literal> (escreve arquivos WAL com a opção
        <symbol>O_DSYNC</symbol> do <function>open()</function>).
        Nem todas estas opções estão disponíveis em todas as plataformas.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-buffers" xreflabel="wal_buffers">
      <term><varname>wal_buffers</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>wal_buffers</></primary>
      </indexterm>
      <listitem>
       <para>
        Número de <literal>buffers</literal> de página de disco alocados na
        memória compartilhada para os dados do WAL. O valor padrão é 8.
        Esta definição somente precisa ser grande o suficiente para conter a
        quantidade de dados do WAL gerados por uma transação típica.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-delay" xreflabel="commit_delay">
      <term><varname>commit_delay</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>commit_delay</></primary>
      </indexterm>
      <listitem>
       <para>
        Retardo entre a escrita do registro de efetivação no
        <literal>buffer</literal> do WAL e a descarga do
        <literal>buffer</literal> no disco, em microssegundos. Um retardo maior
        que zero permite que seja feita apenas uma chamada de sistema
        <function>fsync()</function> para várias transações efetivadas, se a
        carga do sistema for alta o suficiente para que outras transações
        fiquem prontas para efetivar dentro do intervalo especificado.
        Entretanto, este retardo é simplesmente desperdício se nenhuma outra
        transação ficar pronta para efetivar. Portanto, o retardo somente é
        realizado se pelo menos outras <varname>commit_siblings</varname>
        transações estiverem ativas no instante que o processo servidor escrever
        seu registro de efetivação. O valor padrão é zero (nenhum retardo).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-commit-siblings" xreflabel="commit_siblings">
      <term><varname>commit_siblings</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>commit_siblings</></primary>
      </indexterm>
      <listitem>
       <para>
        Número mínimo de transações simultâneas abertas requerido para realizar
        o retardo <varname>commit_delay</varname>. Um valor maior torna mais
        provável que pelo menos uma outra transação fique pronta para efetivar
        durante o período do retardo. O valor padrão é 5.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-wal-checkpoints">
     <title>Pontos de controle</title>

    <variablelist>
     <varlistentry id="guc-checkpoint-segments" xreflabel="checkpoint_segments">
      <term><varname>checkpoint_segments</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>checkpoint_segments</></primary>
      </indexterm>
      <listitem>
       <para>
        Distância máxima entre pontos de controle automático do WAL, em
        segmentos de arquivo de <literal>log</literal> (cada segmento possui
        normalmente 16 megabytes). O valor padrão é 3.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-timeout" xreflabel="checkpoint_timeout">
      <term><varname>checkpoint_timeout</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>checkpoint_timeout</></primary>
      </indexterm>
      <listitem>
       <para>
        Tempo máximo, em segundos, entre pontos de controle automáticos do WAL.
        O valor padrão é 300 segundos.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-checkpoint-warning" xreflabel="checkpoint_warning">
      <term><varname>checkpoint_warning</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>checkpoint_warning</></primary>
      </indexterm>
      <listitem>
       <para>
        Escreve uma mensagem no <literal>log</literal> do servidor caso
        ocorra um ponto de controle, causado pelo enchimento dos arquivos de
        segmento de ponto de controle, em um tempo menor que este número de
        segundos. O valor padrão é 30 segundos. Zero desabilita a advertência.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-wal-archiving">
     <title>Cópia de segurança</title>

    <variablelist>
     <varlistentry id="guc-archive-command" xreflabel="archive_command">
      <term><varname>archive_command</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>archive_command</></primary>
      </indexterm>
      <listitem>
       <para>
        O comando a ser passado para o interpretador de comandos para executar
        a cópia de segurança de um segmento da série de arquivos do WAL quando
        este é completado. Se for uma cadeia de caracteres vazia (que é o valor
        padrão), a cópia de segurança do WAL é desabilitada.
        Todo <literal>%p</literal> presente na cadeia de caracteres é
        substituído pelo caminho absoluto do arquivo cuja cópia de segurança
        será feita, e todo <literal>%f</literal> é substituído apenas pelo nome
        do arquivo. Deve ser utilizado <literal>%%</literal> para incluir o
        caractere <literal>%</literal> na linha de comando. Para obter mais
        informações deve ser consultada a <xref linkend="backup-archiving-wal">.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
        file.
       </para>
       <para>
        É importante que o comando retorne um status de saída igual a zero se,
        e somente se, for bem-sucedido. Exemplos:
<programlisting>
archive_command = 'cp "%p" /mnt/server/archivedir/"%f"'
archive_command = 'copy "%p" /mnt/server/archivedir/"%f"'  # Windows
</programlisting>
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-query">
    <title>Planejamento de comando</title>

    <sect3 id="runtime-config-query-enable">
     <title>Configuração do método de planejamento</title>

      <para>
       Estes parâmetros de configuração fornecem um método rudimentar para
       influenciar os planos de comando escolhidos pelo otimizador de comandos.
       Se o plano padrão escolhido pelo otimizador para um determinado comando
       não for o ótimo, uma solução temporária pode ser obtida utilizando um
       destes parâmetros de configuração para forçar o otimizador a escolher um
       plano diferente. Entretanto, desabilitar uma destas definições
       permanentemente dificilmente é uma boa idéia.
       Outras formas de melhorar a qualidade dos planos escolhidos pelo
       otimizador são o ajuste das
       <xref linkend="runtime-config-query-constants"
       endterm="runtime-config-query-constants-title">,
       a execução do comando
       <xref linkend="sql-analyze" endterm="sql-analyze-title">
       com mais freqüência, o aumento do valor do parâmetro de configuração
       <xref linkend="guc-default-statistics-target">,
       e o aumento da quantidade de estatísticas coletadas
       para colunas específicas utilizando o comando
       <command>ALTER TABLE SET STATISTICS</command>.
      </para>

     <variablelist>
     <varlistentry id="guc-enable-hashagg" xreflabel="enable_hashagg">
      <term><varname>enable_hashagg</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_hashagg</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo agregação por <literal>hash</literal>.
        O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-hashjoin" xreflabel="enable_hashjoin">
      <term><varname>enable_hashjoin</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_hashjoin</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo junção por <literal>hash</literal>.
        O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-indexscan" xreflabel="enable_indexscan">
      <term><varname>enable_indexscan</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>varredura de índice</primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_indexscan</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo varredura de índice.
        O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-mergejoin" xreflabel="enable_mergejoin">
      <term><varname>enable_mergejoin</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_mergejoin</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo junção por mesclagem.
        O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-nestloop" xreflabel="enable_nestloop">
      <term><varname>enable_nestloop</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_nestloop</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo junção por laço aninhado.
        Não é possível suprimir junções por laço aninhado inteiramente, mas
        tornar o valor deste parâmetro igual a <literal>false</literal>
        desestimula a utilização deste método pelo planejador, quando há outro
        método disponível. O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-seqscan" xreflabel="enable_seqscan">
      <term><varname>enable_seqscan</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>varredura sequencial</primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_seqscan</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo varredura seqüencial.
        Não é possível suprimir as varreduras seqüenciais inteiramente, mas
        tornar o valor deste parâmetro igual a <literal>false</literal>
        desestimula a utilização deste método pelo planejador, quando há outro
        método disponível. O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-sort" xreflabel="enable_sort">
      <term><varname>enable_sort</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_sort</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos passos de
        classificação explícita pelo planejador de comandos.
        Não é possível suprimir as classificações explícitas inteiramente, mas
        tornar o valor deste parâmetro igual a <literal>false</literal>
        desestimula a utilização deste método pelo planejador, quando há outro
        método disponível. O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-enable-tidscan" xreflabel="enable_tidscan">
      <term><varname>enable_tidscan</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>enable_tidscan</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita ou desabilita o uso pelo planejador de comandos dos planos do
        tipo varredura <acronym>TID</acronym>.
        O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
     </sect3>
     <sect3 id="runtime-config-query-constants">
     <title id="runtime-config-query-constants-title">
      Constantes de custo do planejador
     </title>

   <note>
    <para>
     Infelizmente, não existe nenhum método bem definido para determinar
     os valores ideais para a família de variáveis de <quote>custo</quote>
     mostradas abaixo. Incentivamos que sejam feitas experiências e
     compartilhadas as descobertas.
    </para>
   </note>

     <variablelist>

     <varlistentry id="guc-effective-cache-size" xreflabel="effective_cache_size">
      <term><varname>effective_cache_size</varname> (<type>floating point</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>effective_cache_size</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o tamanho efetivo presumido pelo planejador acerca do
        <literal>cache</literal> de disco disponível para uma única varredura
        de índice. É um dos elementos usados na estimativa do custo de
        utilização de um índice; um valor maior torna mais provável a utilização
        de uma varredura de índice, enquanto um valor menor torna mais provável
        a utilização de uma varredura seqüencial. Ao definir este valor devem
        ser considerados os <literal>buffers</literal> de memória compartilhada
        do <productname>PostgreSQL</productname>, e a parcela do
        <literal>cache</literal> de disco do núcleo que será utilizada pelos
        arquivos de dado do <productname>PostgreSQL</productname>. Também deve
        ser levado em consideração o número esperado de comandos simultâneos
        que utilizam índces diferentes, uma vez que estes têm de compartilhar
        o espaço disponível. Este parâmetro não tem efeito sobre o tamanho da
        memória compartilhada alocada pelo <productname>PostgreSQL</productname>,
        nem reserva <literal>cache</literal> de disco do núcleo;
        é usado apenas para finalidades de estimativa.
        O valor é medido em páginas de disco, normalmente com 8192 bytes cada.
        O valor padrão é 1000.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-random-page-cost" xreflabel="random_page_cost">
      <term><varname>random_page_cost</varname> (<type>floating point</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>random_page_cost</></primary>
      </indexterm>
      <listitem>
       <para>
        Define a estimativa do planejador de comandos do custo da busca não
        seqüencial de uma página de disco. É medido como um múltiplo do custo
        da busca seqüencial de uma página. Um valor maior torna mais provável
        a utilização de uma varredura seqüencial, enquanto um valor menor torna
        mais provável a utilização de uma uma varredura de índice.
        O valor padrão é 4.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-tuple-cost" xreflabel="cpu_tuple_cost">
      <term><varname>cpu_tuple_cost</varname> (<type>floating point</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>cpu_tuple_cost</></primary>
      </indexterm>
      <listitem>
       <para>
        Define a estimativa do planejador de comandos do custo de processamento
        de cada linha durante o comando. É medido como uma fração do custo da
        busca de uma página seqüencial. O valor padrão é 0.01.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-index-tuple-cost" xreflabel="cpu_index_tuple_cost">
      <term><varname>cpu_index_tuple_cost</varname> (<type>floating point</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>cpu_index_tuple_cost</></primary>
      </indexterm>
      <listitem>
       <para>
        Define a estimativa do planejador de comandos do custo de processamento
        de cada linha de índice durante a varredura do índice. Medido como uma
        fração do custo da busca de uma página seqüencial. O valor padrão é 0.001.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-cpu-operator-cost" xreflabel="cpu_operator_cost">
      <term><varname>cpu_operator_cost</varname> (<type>floating point</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>cpu_operator_cost</></primary>
      </indexterm>
      <listitem>
       <para>
        Define a estimativa do planejador de comandos do custo de processamento
        de cada operador na cláusula <literal>WHERE</literal>. É medido como uma
        fração do custo da busca de uma página seqüencial. O valor padrão é 0.0025.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect3>
     <sect3 id="runtime-config-query-geqo">
     <title>Otimização genética de comandos</title>

     <variablelist>

     <varlistentry id="guc-geqo" xreflabel="geqo">
      <indexterm>
       <primary>otimização genética de comandos</primary>
      </indexterm>
      <indexterm>
       <primary>GEQO</primary>
       <see>otimização genética de comandos</see>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>geqo</></primary>
      </indexterm>
      <term><varname>geqo</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Habilita ou desabilita a otimização genética de comandos, que é um
        algoritmo que tenta realizar um planejamento de comandos sem uma busca
        exaustiva. O valor padrão é habilitado.
        A variável <varname>geqo_threshold</varname> permite uma forma mais
        granular para desabilitar GEQO para certas classes de comandos.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-threshold" xreflabel="geqo_threshold">
      <term><varname>geqo_threshold</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>geqo_threshold</></primary>
      </indexterm>
      <listitem>
       <para>
        A otimização genética de comandos é utilizada para planejar comandos com
        pelo menos esta quantidade de itens envolvidos na cláusula
        <literal>FROM</literal> (Deve ser observado que uma construção de
        <literal>JOIN</literal> externa conta como apenas um item da cláusula
        <literal>FROM</literal>). O valor padrão é 12. Para comandos simples
        geralmente é melhor utilizar o planejamento determinístico exaustivo,
        mas para comandos com muitas tabelas o planejamento determinístico leva
        muito tempo.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-effort" xreflabel="geqo_effort">
      <term><varname>geqo_effort</varname>
      (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>geqo_effort</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla o equilíbrio entre o tempo de planejamento e a eficiência do
        planejamento do comando no GEQO. O valor desta variável deve ser um
        número inteiro no intervalo de 1 a 10. O valor padrão é 5. Valores
        maiores aumentam o tempo gasto para fazer o planejamento do comando, mas
        também aumentam a chance de ser escolhido um plano de comando eficiente.
       </para>

       <para>
        Na verdade, a variável <varname>geqo_effort</varname> não faz nada
        diretamente; é utilizada apenas para calcular os valores padrão para as
        outras variáveis que influenciam o comportamento do GEQO (descritas
        abaixo). Caso se prefira, os demais parâmetros podem ser definidos
        manualmente.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-pool-size" xreflabel="geqo_pool_size">
      <term><varname>geqo_pool_size</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>geqo_pool_size</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla o tamanho  da amostra (<literal>pool size</literal>) utilizado
        pelo GEQO. O tamanho da amostra é o número de indivíduos na população
        genética. Deve ser maior ou igual 2, e os valores úteis estão
        tipicamente no intervalo de 100 a 1000. Se for igual a zero (a definição
        padrão), então um valor padrão adequado é escolhido tomando por base
        <varname>geqo_effort</varname> e o número de tabelas no comando.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-generations" xreflabel="geqo_generations">
      <term><varname>geqo_generations</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>geqo_generations</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla o número de gerações utilizado pelo GEQO.
        As gerações especificam o número de interações do algoritmo.
        Deve ser maior ou igual a 1, e os valores úteis estão no mesmo
        intervalo do tamanho da amostra. Se for definido igual a zero
        (a definição padrão), então um valor padrão adequado é escolhido
        tomando por base <varname>geqo_pool_size</varname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-geqo-selection-bias" xreflabel="geqo_selection_bias">
      <term><varname>geqo_selection_bias</varname> (<type>floating point</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>geqo_selection_bias</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla a tendência da seleção (<literal>selection bias</literal>)
        utilizada pelo GEQO. A tendência da seleção é a pressão seletiva dentro
        da população. Os valores podem estar entre 1.50 e 2.00;
        este último é o valor padrão.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
     <sect3 id="runtime-config-query-other">
     <title>Outras opções do planejador</title>

     <variablelist>

     <varlistentry id="guc-default-statistics-target" xreflabel="default_statistics_target">
      <term><varname>default_statistics_target</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>default_statistics_target</></primary>
      </indexterm>
      <listitem>
       <para>
        Define a quantidade padrão de estatísticas para as colunas das tabelas
        que não possuem uma quantidade específica definida através
        do comando <command>ALTER TABLE SET STATISTICS</command>.
        Valores maiores aumentam o tempo necessário para executar o comando
        <command>ANALYZE</command>, mas podem melhorar a qualidade das
        estimativas do planejador. O valor padrão é 10.
        Para obter informações adicionais sobre a utilização das estatísticas
        pelo planejador de comandos do <productname>PostgreSQL</productname>
        deve ser consultada a <xref linkend="planner-stats">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-from-collapse-limit" xreflabel="from_collapse_limit">
      <term><varname>from_collapse_limit</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>from_collapse_limit</></primary>
      </indexterm>
      <listitem>
       <para>
        O planejador incorpora as subconsultas nas consultas superiores se a
        lista <literal>FROM</literal> resultante não tiver mais do que esta
        quantidade de itens. Valores menores reduzem o tempo de planejamento,
        mas podem levar a planos de consulta inferiores. O valor padrão é 8.
        Geralmente é razoável manter este valor abaixo de
        <xref linkend="guc-geqo-threshold">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-join-collapse-limit" xreflabel="join_collapse_limit">
      <term><varname>join_collapse_limit</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>join_collapse_limit</></primary>
      </indexterm>
      <listitem>
       <para>
        O planejador reescreve construções <literal>JOIN</literal> internas
        explícitas em lista de itens da cláusula <literal>FROM</literal>, sempre
        que resultar em uma lista com não mais do que esta quantidade de itens.
        Antes do <productname>PostgreSQL</> 7.4 as junções especificadas através
        da contrução <literal>JOIN</literal> nunca eram reorganizadas pelo
        planejador.
        Depois o planejador foi melhorado para que as junções internas escritas
        desta forma pudessem ser reordenadas; este parâmetro de configuração
        controla até que ponto esta reordenação é realizada.
        <note>
         <para>
          Atualmente a ordem das junções externas, especificadas
          através das construções <literal>JOIN</>, nunca é ajustada pelo
          planejador; portanto <varname>join_collapse_limit</> não
          tem efeito sobre este comportamento. O planejador poderá ser
          melhorado para reordenar algumas classes de junção externa em uma
          versão futura do <productname>PostgreSQL</productname>.
         </para>
        </note>
       </para>

       <para>
        O padrão é definir esta variável com o mesmo valor de
        <varname>from_collapse_limit</varname>, o que é apropriado para a
        maioria dos usos. Definir o valor igual a 1 impede a reordenação
        dos <literal>JOIN</literal>s internos. Portanto, a ordem de junção
        especificada no comando será a ordem real pela qual as relações serão
        juntadas. O otimizador de comandos nem sempre escolhe a ordem de junção
        ótima; os usuários avançados podem decidir definir o valor desta
        variável igual a 1 temporariamente e, então, especificar a ordem de
        junção desejada explicitamente. Uma outra conseqüência de definir o
        valor desta variável igual a 1 é fazer com que o planejador de comandos
        se comporte de forma mais parecida com o planejador de comandos do
        <productname>PostgreSQL</productname> 7.3, o que alguns usuários podem
        achar útil por motivo de compatibilidade com versões anteriores.
       </para>

       <para>
        Definir esta variável com um valor entre 1 e
        <varname>from_collapse_limit</varname> pode ser útil para equilibrar o
        tempo de planejamento versus a qualidade de plano escolhido.
        (os valores maiores produzem planos melhores).
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-logging">
    <title>Relato e registro de erros</title>

    <indexterm zone="runtime-config-logging">
     <primary>log do servidor</primary>
    </indexterm>

    <sect3 id="runtime-config-logging-where">
     <title>Onde registrar</title>

     <indexterm zone="runtime-config-logging-where">
      <primary>onde registrar</primary>
     </indexterm>

     <variablelist>

     <varlistentry id="guc-log-destination" xreflabel="log_destination">
      <term><varname>log_destination</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_destination</></primary>
      </indexterm>
      <listitem>
       <para>
        O <productname>PostgreSQL</productname> dispõe de vários métodos para
        registrar as mensagens do servidor, incluindo
        <systemitem>stderr</systemitem> e <systemitem>syslog</systemitem>.
        No <productname>Windows</productname> também há suporte para
        <systemitem>eventlog</systemitem>. Este parâmetro é definido através de
        uma lista de destinos desejados para registrar as mensagens, separados
        por vírgula. O padrão é registrar apenas em
        <systemitem>stderr</systemitem>.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-redirect-stderr" xreflabel="redirect_stderr">
      <term><varname>redirect_stderr</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>redirect_stderr</></primary>
      </indexterm>
      <listitem>
       <para>
        Permite que as mensagens enviadas para
        <application>stderr</application> sejam capturadas e redirecionadas
        para os arquivos de registro (<literal>log</literal>).
        Combinada com <application>stderr</application> esta opção geralmente
        é mais útil que registrar em <application>syslog</application>, uma
        vez que alguns tipos de mensagem podem não aparecer na saída para
        <application>syslog</application>; um exemplo comum é uma mensagem
        de falha do ligador dinâmico (<literal>dynamic-linker</literal>).
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-directory" xreflabel="log_directory">
      <term><varname>log_directory</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_directory</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando <varname>redirect_stderr</> está habilitado, este parâmetro
        determina o diretório onde os arquivos de registro serão criados.
        Pode ser especificado como um caminho absoluto, ou como um caminho
        relativo ao diretório de dados do agrupamento.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-filename" xreflabel="log_filename">
      <term><varname>log_filename</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_filename</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando <varname>redirect_stderr</varname> está habilitado, este
        parâmetro define os nomes dos arquivos de registro criados. O valor é
        tratado como um padrão para a função <systemitem>strftime</systemitem>,
        <footnote>
         <para>
          Consulte <literal>man strftime</literal> &mdash;
          A função <systemitem>strftime</systemitem> formata data e hora.
          (N. do T.)
         </para>
        </footnote>
        portanto podem ser utilizados os escapes de <literal>%</literal>
        para especificar nomes de arquivos que variam com o tempo.
        Se não houver nenhum escape de <literal>%</literal> presente, o
        <productname>PostgreSQL</productname> anexa a época do momento de
        abertura do arquivo de registro ao nome do arquivo. Por exemplo,
        se <varname>log_filename</varname> for igual a
        <literal>server_log</literal>, então o nome escolhido para o arquivo
        será <literal>server_log.1093827753</literal> para um registro
        começando em <quote>Dom Ago 29 19:02:33 2004 MST</quote>.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-age" xreflabel="log_rotation_age">
      <term><varname>log_rotation_age</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_rotation_age</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando <varname>redirect_stderr</> está habilitado, este parâmetro
        determina o tempo de vida máximo de um determinado arquivo de registro.
        Após ter decorrido esta quantidade de minutos, é criado um novo arquivo
        de registro.
        Definir o valor como zero desabilita a criação de novos arquivos de
        registro baseado no tempo.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-rotation-size" xreflabel="log_rotation_size">
      <term><varname>log_rotation_size</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_rotation_size</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando <varname>redirect_stderr</> está habilitado, este parâmetro
        determina o tamanho máximo de um arquivo de registro indivdual.
        Após esta quantidade de kilobytes ter sido lançada no arquivo de
        registro, é criado um novo arquivo de registro.
        Definir o valor como zero desabilita a criação de novos arquivos de
        registro baseado no tamanho.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-truncate-on-rotation" xreflabel="log_truncate_on_rotation">
      <term><varname>log_truncate_on_rotation</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_truncate_on_rotation</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando <varname>redirect_stderr</> está habilitado, este parâmetro faz
        com que o <productname>PostgreSQL</productname> trunque (sobrescreva),
        em vez de anexar, um arquivo de registro com o mesmo nome.
        Entretanto, o truncamento somente ocorre quando está sendo aberto um
        novo arquivo devido a rotação baseada no tempo, e não durante a
        inicialização ou rotação baseada no tamanho.
        Quando está desabilitado, os arquivos pré-existentes são anexados em
        todos os casos.
        Por exemplo, utilizar este parâmetro em combinação com um valor para
        <varname>log_filename</varname>, como
        <literal>postgresql-%H.log</literal>, resulta na geração de arquivos
        de registro de vinte e quatro horas, reescritos ciclicamente.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
       <para>
        Exemplo: Para manter registro dos últimos 7 dias, com um arquivo de
        registro por dia, chamados <literal>server_log.Mon</literal>,
        <literal>server_log.Tue</literal>, etc., e reescrever automaticamente
        o registro da semana anterior com o registro da semana corrente,
        <varname>log_filename</varname> deve ser definido como
        <literal>server_log.%a</literal>,
        <footnote>
         <para>
          <literal>%a</literal> &mdash; O nome abreviado do dia da semana
          de acordo com o idioma corrente. (N. do T.)
         </para>
        </footnote>
        <varname>log_truncate_on_rotation</varname> como
        <literal>true</literal>, e
        <varname>log_rotation_age</varname> como <literal>1440</literal>.
       </para>
       <para>
        Exemplo: Para manter registros de 24 horas, um arquivo de registro por
        hora, mas também rotacionando mais cedo se o tamanho do arquivo de
        registro exceder 1GB, <varname>log_filename</varname>
        deve ser definido como <literal>server_log.%H%M</literal>,
        <footnote>
         <para>
          <literal>%H</literal> &mdash; A hora como número decimal utilizando o
          relógio de 24 horas (faixa de 00 a 23). (N. do T.)
         </para>
        </footnote>
        <footnote>
         <para>
          <literal>%M</literal> &mdash; O minuto como número decimal
          (faixa de 00 a 59). (N. do T.)
         </para>
        </footnote>
        <varname>log_truncate_on_rotation</varname> como
        <literal>true</literal>,
        <varname>log_rotation_age</varname> como <literal>60</literal>, e
        <varname>log_rotation_size</varname> como <literal>1000000</literal>.
        A inclusão de <literal>%M</> em <varname>log_filename</varname>
        faz com que toda rotação causada pelo tamanho do arquivo use
        um nome de arquivo diferente do nome de arquivo inicial da hora.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-facility" xreflabel="syslog_facility">
      <term><varname>syslog_facility</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>syslog_facility</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando o registro através de <application>syslog</>
         <footnote>
          <para>
            O <application>syslog</application>, originalmente escrito por
            Eric Allman, é um sistema de <literal>log</literal> abrangente.
            Possui duas funções importantes: liberar os programadores da
            mecânica entediante de escrever arquivos de <literal>log</literal>,
            e colocar os administradores controlando o <literal>log</literal>.
            O formato do arquivo de configuração é <quote>seletor &lt;Tab&gt;
            ação</quote>, onde o seletor identifica o programa (facilidade)
            que envia a mensagem de <literal>log</literal> e o nível de
            severidade da mensagem. Linux Administration Handbook -
            Evi Nemeth e outros - Prentice Hall PTR. (N. do T.)
          </para>
         </footnote>
        está habilitado, este parâmetro determina a <quote>facilidade</quote> do
        <application>syslog</application> a ser utilizada.
        Pode ser escolhido <literal>LOCAL0</>, <literal>LOCAL1</>,
        <literal>LOCAL2</>, <literal>LOCAL3</>, <literal>LOCAL4</>,
        <literal>LOCAL5</>, <literal>LOCAL6</>, <literal>LOCAL7</>;
        o padrão é <literal>LOCAL0</literal>. Também deve ser consultada a
        documentação do processo <application>syslog</application> do sistema.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-syslog-ident" xreflabel="syslog_ident">
      <term><varname>syslog_ident</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>syslog_identity</></primary>
      </indexterm>
       <listitem>
        <para>
         Quando o registro via <application>syslog</application> está habilitado,
         este parâmetro determina o nome de programa utilizado para identificar
         as mensagens do <productname>PostgreSQL</productname> nos registros do
         <application>syslog</application>.
         O valor padrão é <literal>postgres</literal>.
         Somente pode ser definido na inicialização do servidor.
        </para>
       </listitem>
      </varlistentry>

      </variablelist>
    </sect3>
     <sect3 id="runtime-config-logging-when">
     <title>Quando registrar</title>

     <variablelist>

     <varlistentry id="guc-client-min-messages" xreflabel="client_min_messages">
      <term><varname>client_min_messages</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>client_min_messages</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla que níveis de mensagem são enviadas para o cliente.
        Os valores válidos são <literal>DEBUG5</literal>,
        <literal>DEBUG4</literal>, <literal>DEBUG3</literal>,
        <literal>DEBUG2</literal>, <literal>DEBUG1</literal>,
        <literal>LOG</literal>, <literal>NOTICE</literal>,
        <literal>WARNING</literal> e <literal>ERROR</literal>. Cada nível
        inclui todos os níveis que o seguem. Quanto mais para o final estiver
        o nível, menos mensagens são enviadas. O valor padrão é
        <literal>NOTICE</literal>. Deve ser observado que aqui
        <literal>LOG</literal> possui uma situação relativa diferente da que
        tem em <varname>log_min_messages</varname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-messages" xreflabel="log_min_messages">
      <term><varname>log_min_messages</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_min_messages</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla que níveis de mensagem são escritas no <literal>log</literal>
        do servidor. Os valores válidos são <literal>DEBUG5</literal>,
        <literal>DEBUG4</literal>, <literal>DEBUG3</literal>,
        <literal>DEBUG2</literal>, <literal>DEBUG1</literal>,
        <literal>INFO</literal>, <literal>NOTICE</literal>,
        <literal>WARNING</literal>, <literal>ERROR</literal>,
        <literal>LOG</literal>, <literal>FATAL</literal> e
        <literal>PANIC</literal>. Cada nível inclui todos os níveis que o
        seguem. Quanto mais para o final estiver o nível, menos mensagens são
        enviadas. O valor padrão é <literal>NOTICE</literal>. Deve ser observado
        que aqui <literal>LOG</literal> possui uma situação relativa diferente
        da que tem em <varname>client_min_messages</varname>.
        Somente os superusuários podem aumentar esta opção.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-error-verbosity" xreflabel="log_error_verbosity">
      <term><varname>log_error_verbosity</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_error_verbosity</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla a quantidade de detalhes escritos no <literal>log</literal> do
        servidor para cada mensagem que é registrada. Os valores válidos são
        <literal>TERSE</literal> (sucinto), <literal>DEFAULT</literal> e
        <literal>VERBOSE</literal>, cada um adicionando mais campos às
        mensagens escritas.
        Somente os superusuários podem alterar esta definição.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-error-statement" xreflabel="log_min_error_statement">
      <term><varname>log_min_error_statement</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_min_error_statement</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla se o comando SQL causador da condição de erro também será
        registrado no <literal>log</literal> do servidor. Todas as declarações
        SQL causadoras de um erro do nível especificado, ou de nível mais alto,
        são registradas. O valor padrão é <literal>PANIC</literal> (tornando de
        fato esta funcionalidade desabilitada para o uso normal). Os valores
        válidos são <literal>DEBUG5</literal>, <literal>DEBUG4</literal>,
        <literal>DEBUG3</literal>, <literal>DEBUG2</literal>,
        <literal>DEBUG1</literal>, <literal>INFO</literal>,
        <literal>NOTICE</literal>, <literal>WARNING</literal>,
        <literal>ERROR</literal>, <literal>FATAL</literal> e
        <literal>PANIC</literal>. Por exemplo, se for definido como
        <literal>ERROR</literal> então todas as declarações SQL causadoras de
        erro, erros fatais ou pânicos serão registradas. Habilitar esta opção
        pode ser útil para encontrar a origem de qualquer erro que apareça no
        <literal>log</literal> do servidor.
        Somente os superusuários podem alterar esta definição.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-min-duration-statement" xreflabel="log_min_duration_statement">
      <term><varname>log_min_duration_statement</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_min_duration_statement</></primary>
      </indexterm>
       <listitem>
        <para>
         Define o tempo de execução mínimo da declaração (em milissegundos)
         para que a declaração seja registrada. Todas as declarações SQL
         cujo tempo de execução for igual ou superior ao tempo especificado
         serão registradas juntamente com sua duração. Definir como zero
         registra todos os comandos e sua duração. O valor -1 (o padrão)
         desabilita esta funcionalidade. Por exemplo, se for definido como
         <literal>250</literal> então todas as declarações SQL com tempo de
         execução de 250ms ou superior serão registradas. Habilitar esta opção
         pode ser útil para encontrar comandos não otimizados nos aplicativos.
         Somente os superusuários podem alterar esta definição.
        </para>
       </listitem>
      </varlistentry>

     <varlistentry id="guc-silent-mode" xreflabel="silent_mode">
      <term><varname>silent_mode</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>silent_mode</></primary>
      </indexterm>
      <listitem>
       <para>
        Executa o servidor em silêncio. Quando o valor deste parâmetro é
        definido como <literal>true</literal>, o servidor executa
        automaticamente em segundo plano, e se desvincula do terminal
        controlador (o mesmo efeito da opção <option>-S</option> do
        <command>postmaster</command>). A saída padrão e o erro padrão do
        servidor são redirecionadas para <literal>/dev/null</> e, portanto,
        todas as mensagens enviadas para as mesmas são perdidas.
        A menos que seja habilitado registrar em <application>syslog</>, ou que
        <varname>redirect_stderr</> esteja habilitado, a utilização desta opção
        é desencorajada, porque torna impossível ver as mensagens de erro.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

       <para>
        Abaixo segue a relação dos vários níveis de severidade de mensagem
        utilizados nestas definições:
        <variablelist>
         <varlistentry>
          <term><literal>DEBUG[1-5]</literal></term>
          <listitem>
           <para>
            Fornece informações para uso pelos desenvolvedores.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>INFO</literal></term>
          <listitem>
           <para>
            Fornece informações requisitadas implicitamente pelo usuário como,
            por exemplo, durante <command>VACUUM VERBOSE</command>.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>NOTICE</literal></term>
          <listitem>
           <para>
            Fornece informações que podem ser úteis para os usuários como, por
            exemplo, o truncamento de identificadores longos e a criação de
            índices como parte das chaves primárias.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>WARNING</literal></term>
          <listitem>
           <para>
            Fornece advertências para o usuário como, por exemplo,
            <command>COMMIT</command> fora do bloco de transação.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>ERROR</literal></term>
          <listitem>
           <para>
            Relata o erro que fez com que o comando corrente fosse interrompido.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>LOG</literal></term>
          <listitem>
           <para>
            Relata informações de interesse dos administradores como,
            por exemplo, atividade de ponto de controle.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>FATAL</literal></term>
          <listitem>
           <para>
            Relata o erro que fez com que a sessão corrente fosse interrompida.
           </para>
          </listitem>
         </varlistentry>

         <varlistentry>
          <term><literal>PANIC</literal></term>
          <listitem>
           <para>
            Relata o erro que fez com que todas as sessões fossem interrompidas.
           </para>
          </listitem>
         </varlistentry>
        </variablelist>
       </para>

    </sect3>
     <sect3 id="runtime-config-logging-what">
     <title>O que registrar</title>

     <variablelist>

     <varlistentry>
      <term><varname>debug_print_parse</varname> (<type>boolean</type>)</term>
      <term><varname>debug_print_rewritten</varname> (<type>boolean</type>)</term>
      <term><varname>debug_print_plan</varname> (<type>boolean</type>)</term>
      <term><varname>debug_pretty_print</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>debug_print_parse</></primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>debug_print_rewritten</></primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>debug_print_plan</></primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>debug_pretty_print</></primary>
      </indexterm>
      <listitem>
       <para>
        Estes parâmetros habilitam a emissão de várias saídas de depuração.
        Para cada comando executado, imprimem a árvore de análise resultante,
        a saída do reescritor de comando, ou o plano de execução.
        <varname>debug_pretty_print</varname> introduz recuos na mensagem
        mostrada, produzindo um formato de saída mais legível, mas muito mais
        longo. <varname>client_min_messages</varname> e
        <varname>log_min_messages</varname> devem estar em
        <literal>DEBUG1</literal> ou abaixo, para ser enviada a saída para o
        <literal>log</literal> do cliente ou do servidor, respectivamente.
        Estes parâmetros estão desabilitados por padrão.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-connections" xreflabel="log_connections">
      <term><varname>log_connections</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_connections</></primary>
      </indexterm>
      <listitem>
       <para>
        Gera uma linha para o <literal>log</literal> do servidor
        detalhando cada conexão bem-sucedida.
        O valor padrão é desabilitado embora, provavelmente, seja muito útil.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-disconnections" xreflabel="log_disconnections">
      <term><varname>log_disconnections</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_disconnections</></primary>
      </indexterm>
      <listitem>
       <para>
        Gera uma linha para o <literal>log</literal> do servidor
        semelhante à gerada por <varname>log_connections</varname>, mas no
        término da sessão, incluindo a duração da sessão.
        Está desabilitado por padrão.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-duration" xreflabel="log_duration">
      <term><varname>log_duration</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_duration</></primary>
      </indexterm>
      <listitem>
       <para>
        Faz com que seja registrada a duração de toda declaração
        completada que satisfaz <varname>log_statement</varname>. Quando esta
        opção é utilizada, se <application>syslog</application> não estiver
        sendo utilizado, recomenda-se que o PID ou o ID da sessão seja
        registrado utilizando <varname>log_line_prefix</>, para que seja
        vinculada a declaração à duração utilizando o ID do processo ou o ID da
        sessão. O valor padrão é desabilitado.
        Somente os superusuários podem alterar esta definição.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-line-prefix" xreflabel="log_line_prefix">
      <term><varname>log_line_prefix</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_line_prefix</></primary>
      </indexterm>
      <listitem>
       <para>
        O valor deste parâmetro é uma cadeia de caracteres no estilo da função
        <function>printf</function>, mostrada no começo de cada linha de
        registro. O valor padrão é uma cadeia de caracteres vazia. Cada escape
        reconhecido é substituído conforme mostrado abaixo &mdash; qualquer
        outra coisa que se pareça com um escape é ignorada. Os demais caracteres
        são copiados literalmente para a linha de registro. Alguns escapes são
        reconhecidos apenas pelos processos de sessão, não se aplicando a
        processos em segundo plano como o postmaster. <application>Syslog</>
        produz seu próprio carimbo do tempo e informação do ID do processo e,
        portanto, provavelmente não será desejado utilizar estes escapes quando
        <application>syslog</application> é utilizado.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.

         <informaltable>
          <tgroup cols="3">
           <thead>
            <row>
             <entry>Escape</entry>
             <entry>Efeito</entry>
             <entry>Apenas de sessão</entry>
             </row>
            </thead>
           <tbody>
            <row>
             <entry><literal>%u</literal></entry>
             <entry>Nome do usuário.</entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%d</literal></entry>
             <entry>Nome do banco de dados.</entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%r</literal></entry>
             <entry>
              Nome do hospedeiro remoto ou endereço de IP, e porta remota.
             </entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%p</literal></entry>
             <entry>ID do processo.</entry>
             <entry>não</entry>
            </row>
            <row>
             <entry><literal>%t</literal></entry>
             <entry>Carimbo do tempo.</entry>
             <entry>não</entry>
            </row>
            <row>
             <entry><literal>%i</literal></entry>
             <entry>
              Marca do comando: O comando que gerou a linha de registro.
             </entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%c</literal></entry>
             <entry>
              ID da sessão: O identificador único de cada sessão.
              Números hexadecimais de 2 a 4 bytes (sem zeros à frente),
              separados por ponto. Os números são o momento de início da sessão
              e o ID do processo, portanto também pode ser utilizado como uma
              maneira de registrar estes itens com economia de espaço.
             </entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%l</literal></entry>
             <entry>
              O número da linha de registro para cada processo, começando por 1.
             </entry>
             <entry>não</entry>
            </row>
            <row>
             <entry><literal>%s</literal></entry>
             <entry>Carimbo do tempo do início da sessão.</entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%x</literal></entry>
             <entry>ID da transação.</entry>
             <entry>sim</entry>
            </row>
            <row>
             <entry><literal>%q</literal></entry>
             <entry>
              Não produz nenhuma saída, mas informa aos processos que não são
              de sessão para pararem neste ponto da cadeia de caracteres.
              Ignorado pelos processos de sessão.
             </entry>
             <entry>não</entry>
            </row>
            <row>
             <entry><literal>%%</literal></entry>
             <entry>O literal <literal>%</literal></entry>
             <entry>não</entry>
            </row>
           </tbody>
          </tgroup>
         </informaltable>
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-statement" xreflabel="log_statement">
      <term><varname>log_statement</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_statement</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla quais declarações SQL são registradas. Os valores válidos são
        <literal>none</>, <literal>ddl</>, <literal>mod</> e
        <literal>all</>.
        <literal>ddl</> registra todos os comandos de definição de dados, como
        <literal>CREATE</>, <literal>ALTER</> e <literal>DROP</>.
        <literal>mod</> registra todos as instruções de <literal>ddl</>, mais
        <literal>INSERT</>, <literal>UPDATE</>, <literal>DELETE</>,
        <literal>TRUNCATE</> e <literal>COPY FROM</>.
        Também são registradas as instruções <literal>PREPARE</> e
        <literal>EXPLAIN ANALYZE</>, se os comandos contidos nestas
        instruções forem do tipo apropriado.
       </para>
       <para>
        O valor padrão é <literal>none</>.
        Somente os superusuários podem alterar esta definição.
       </para>

       <note>
        <para>
         A declaração <command>EXECUTE</command> não é considerada como sendo
         uma declaração de <literal>ddl</> ou <literal>mod</>. Quando é
         registrada somente é relatado o nome da declaração preparada, e não
         a declaração preparada inteira.
        </para>

        <para>
         Quando uma função é definida utilizando a linguagem do lado servidor
         <application>PL/pgSQL</application>, todos os comandos executados pela
         função são registrados somente na primeira vez que a função é
         chamada por uma determinada sessão. Isto se deve ao fato da linguagem
         <application>PL/pgSQL</application> manter um <literal>cache</literal>
         dos planos de comando produzidos pelas declarações SQL na função.
        </para>
       </note>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-log-hostname" xreflabel="log_hostname">
      <term><varname>log_hostname</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_hostname</></primary>
      </indexterm>
      <listitem>
       <para>
        Por padrão as mensagens de registro de conexão mostram somente o
        endereço de IP do hospedeiro se conectando. Habilitar esta opção faz
        com que seja registrado o nome do hospedeiro também. Deve ser observado
        que, dependendo da configuração da resolução de nome de hospedeiro, pode
        ser imposta uma penalidade de desempenho não desprezível.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-statistics">
    <title>Estatísticas de tempo de execução</title>

    <sect3 id="runtime-config-statistics-monitor">
     <title>Monitoramento das estatísticas</title>
     <variablelist>

     <varlistentry>
      <term><varname>log_statement_stats</varname> (<type>boolean</type>)</term>
      <term><varname>log_parser_stats</varname> (<type>boolean</type>)</term>
      <term><varname>log_planner_stats</varname> (<type>boolean</type>)</term>
      <term><varname>log_executor_stats</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_statement_stats</></primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_parser_stats</></primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_planner_stats</></primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>log_executor_stats</></primary>
      </indexterm>
      <listitem>
       <para>
        Para cada comando, são registradas estatísticas de desempenho do
        respectivo módulo no <literal>log</literal> do servidor.
        É um instrumento rudimentar para traçar um perfil.
        <varname>log_statement_stats</varname> relata estatísticas totais da
        declaração, enquanto os demais relatam estatísticas por módulo.
        <varname>log_statement_stats</varname> não pode ser habilitado junto
        com qualquer outro parâmetro por-módulo.
        Todos estes parâmetros estão desabilitados por padrão.
        Somente os superusuários podem alterar estas definições.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect3>
    <sect3 id="runtime-config-statistics-collector">
     <title>Coletor de estatísticas de comando e índice</title>
     <variablelist>

     <varlistentry id="guc-stats-start-collector" xreflabel="stats_start_collector">
      <term><varname>stats_start_collector</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>stats_start_collector</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla se o servidor deve inicializar o subprocesso coletor de
        estatísticas. Está habilitado por padrão, mas pode ser desabilitado
        quando se sabe que não há interesse em coletar estatísticas.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-command-string" xreflabel="stats_command_string">
      <term><varname>stats_command_string</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>stats_command_string</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita a coleta de estatísticas para o comando executando no momento
        em cada sessão, junto com o momento em que o comando começou a executar.
        O valor padrão é desabilitado.
        Deve ser observado que, mesmo quando está habilitado, esta informação
        não é visível por todos os usuários, mas somente pelos superusuários e
        o usuário dono da sessão sendo relatada; portanto, não deve representar
        um risco à segurança. Este dado pode ser acessado através da visão do
        sistema <structname>pg_stat_activity</structname>; para obter mais
        informações deve ser consultado o <xref linkend="monitoring">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-block-level" xreflabel="stats_block_level">
      <term><varname>stats_block_level</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>stats_block_level</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita a coleta de estatísticas no nível de bloco da atividade do
        banco de dados. O valor padrão é desabilitado. Se estiver
        habilitado, os dados produzidos podem ser acessados através da família
        de visões do sistema <structname>pg_stat</structname> e
        <structname>pg_statio</structname>; para obter informações adicionais
        deve ser consultado o <xref linkend="monitoring"> .

       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-row-level" xreflabel="stats_row_level">
      <term><varname>stats_row_level</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>stats_row_level</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita a coleta de estatísticas no nível de linha da atividade do
        banco de dados. O valor padrão é desabilitado. Se estiver
        habilitado, os dados produzidos podem ser acessados através da família
        de visões do sistema <structname>pg_stat</structname> e
        <structname>pg_statio</structname>; para obter informações adicionais
        deve ser consultado o <xref linkend="monitoring"> .
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-stats-reset-on-server-start" xreflabel="stats_reset_on_server_start">
      <term><varname>stats_reset_on_server_start</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>stats_reset_on_server_start</></primary>
      </indexterm>
      <listitem>
       <para>
        Se estiver habilitado, as estatísticas coletadas são zeradas sempre que
        o servidor é reinicializado. Se estiver desabilitado, as estatísticas
        são acumuladas entre as reinicializações do servidor.
        O valor padrão é habilitado.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-client">
    <title>Padrões de conexão do cliente</title>

    <sect3 id="runtime-config-client-statement">
     <title>Comportamento da declaração</title>
     <variablelist>

     <varlistentry id="guc-search-path" xreflabel="search_path">
      <term><varname>search_path</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>search_path</></primary>
      </indexterm>
      <indexterm><primary>caminho</primary><secondary>para esquemas</></>
      <listitem>
       <para>
        Esta variável especifica a ordem de procura nos esquemas quando um
        objeto (tabela, tipo de dado, função, etc.) é referenciado simplesmente
        por um nome, sem o componente do esquema. Quando existem objetos com
        nomes idênticos em esquemas diferentes, é utilizado o que for encontrado
        primeiro no caminho de procura. Um objeto que não está em nenhum dos
        esquemas do caminho de procura, somente pode ser referenciado
        especificando o esquema que o contém usando um nome qualificado (com
        ponto).
       </para>

       <para>
        O valor de <varname>search_path</varname> deve ser uma lista de nomes
        de esquemas separados por vírgula. Se um dos itens da lista for o valor
        especial <literal>$user</literal>, então este valor é substituído pelo
        esquema que tem o nome retornado por <function>SESSION_USER</function>,
        caso este esquema exista (caso contrário, <literal>$user</literal> é
        ignorado).
       </para>

       <para>
        É sempre feita a procura no esquema do catálogo do sistema,
        <literal>pg_catalog</literal>, esteja presente no caminho de procura
        ou não. Se estiver mencionado no caminho de procura, então a procura
        será feita na ordem especificada. Se <literal>pg_catalog</literal> não
        estiver presente no caminho de procura, então será feita a procura neste
        esquema <emphasis>antes</emphasis> de ser feita a procura em qualquer um
        dos esquemas do caminho de procura. Também deve ser observado que é
        feita a procura no esquema de tabela temporária,
        <literal>pg_temp_<replaceable>nnn</replaceable></literal>,
        antes de ser feita em qualquer um dos outros esquemas.
       </para>

       <para>
        Quando os objetos são criados sem especificar o esquema de destino,
        são colocados no primeiro esquema da lista do caminho de procura.
        Quando o caminho de procura está vazio é gerado um erro.
       </para>

       <para>
        O valor padrão para este parâmetro é <literal>'$user, public'</literal>
        (onde a segunda parte é ignorada quando não há um esquema chamado
        <literal>public</literal>).
        Dá suporte ao uso compartilhado de um banco de dados (onde nenhum
        usuário possui um esquema privativo, e todos compartilham o esquema
        <literal>public</literal>), esquemas privativos por usuário, e a
        combinação destes. Podem ser obtidos outros resultados mudando a
        definição do caminho de procura padrão, tanto globalmente quanto por
        usuário.
       </para>

       <para>
        O valor efetivo corrente do caminho de procura pode ser examinado
        através da função <acronym>SQL</acronym>
        <function>current_schemas()</function>. Não é exatamente o mesmo que
        examinar o valor de <varname>search_path</varname>, uma vez que
        <function>current_schemas()</function> mostra como as solicitações
        que aparecem em <varname>search_path</varname> foram resolvidas.
        Para obter informações adicionais sobre a função
        <function>current_schemas()</function> deve ser consultada a
        <xref linkend="functions-info-session-table">.
       </para>

       <para>
        Para obter informações adicionais sobre manuseio de esquemas deve ser
        consultada a <xref linkend="ddl-schemas">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-tablespace" xreflabel="default_tablespace">
      <term><varname>default_tablespace</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>default_tablespace</></primary>
      </indexterm>
      <indexterm><primary>espaço de tabelas</primary><secondary>default</></>
      <listitem>
       <para>
        Esta variável especifica o espaço de tabelas onde serão criados os
        objetos (tabelas e índices), quando o comando <command>CREATE</command>
        não especificar explicitamente o espaço de tabelas.
       </para>

       <para>
        O valor pode ser o nome de um espaço de tabelas, ou uma cadeia de
        caracteres vazia para especificar o espaço de tabelas padrão do banco
        de dados corrente. Se o valor não corresponder a um espaço de tabelas
        existente, o <productname>PostgreSQL</productname> utiliza
        automaticamente o espaço de tabelas padrão do banco de dados corrente.
       </para>

       <para>
        Para obter informações adicionais sobre espaços de tabelas deve ser
        consultada a <xref linkend="manage-ag-tablespaces">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-check-function-bodies" xreflabel="check_function_bodies">
      <term><varname>check_function_bodies</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>check_function_bodies</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando é definido como <literal>false</literal>, desabilita a validação
        da cadeia de caracteres do corpo da função durante a execução do comando
        <xref linkend="sql-createfunction" endterm="sql-createfunction-title">.
        Normalmente definido como <literal>true</literal>.
        Ocasionalmente é útil desabilitar a validação para evitar problemas
        como referências à frente ao restaurar as definições das funções a
        partir de cópia de segurança.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-isolation" xreflabel="default_transaction_isolation">
      <indexterm>
       <primary>nível de isolamento da transação</primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>default_transaction_isolation</></primary>
      </indexterm>
      <term><varname>default_transaction_isolation</varname> (<type>string</type>)</term>
      <listitem>
       <para>
        Cada transação SQL possui um nível de isolamento, que pode ser
        <quote>READ UNCOMMITTED</quote>, <quote>READ COMMITTED</quote>,
        <quote>REPEATABLE READ</quote> ou <quote>SERIALIZABLE</quote>.
        Este parâmetro controla o nível de isolamento padrão de cada nova
        transação. O valor padrão é <quote>READ COMMITTED</quote>.
       </para>

       <para>
        Para obter informações adicionais devem ser consultados o
        <xref linkend="mvcc"> e <xref linkend="sql-set-transaction">
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-transaction-read-only" xreflabel="default_transaction_read_only">
      <indexterm>
       <primary>transação apenas de leitura</primary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>default_transaction_read_only</></primary>
      </indexterm>

      <term><varname>default_transaction_read_only</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Uma transação SQL apenas de leitura não pode alterar tabelas que não
        sejam temporárias. Este parâmetro controla o status de apenas para
        leitura padrão para cada nova transação.
        O valor padrão é <literal>false</literal> (leitura/escrita).
       </para>

       <para>
        Para obter informações adicionais deve ser consultado
        <xref linkend="sql-set-transaction">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-statement-timeout" xreflabel="statement_timeout">
      <term><varname>statement_timeout</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>statement_timeout</></primary>
      </indexterm>
      <listitem>
       <para>
        Interrompe qualquer declaração que exceda o número de milissegundos
        especificado. O valor zero, que é o valor padrão, desabilita esta
        limitação.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
     <sect3 id="runtime-config-client-format">
     <title>Idioma e formatação</title>

     <variablelist>

     <varlistentry id="guc-datestyle" xreflabel="DateStyle">
      <term><varname>DateStyle</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>DateStyle</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o formato de exibição para os valores de data e hora, assim como
        as regras para interpretar valores de entrada de data ambíguos. Por
        motivos históricos esta variável contém dois componentes independentes:
        a especificação do formato de saída (<literal>ISO</literal>,
        <literal>Postgres</literal>, <literal>SQL</literal> ou
        <literal>German</literal>), e a especificação para entrada/saída da
        ordem de dia, mês e ano na data (<literal>DMY</literal>,
        <literal>MDY</literal>, ou <literal>YMD</literal>). Podem ser definidos
        separadamente ou juntos. As palavras chave <literal>Euro</literal> e
        <literal>European</literal> são sinônimos para <literal>DMY</literal>;
        as palavras chave <literal>US</literal>, <literal>NonEuro</literal>,
        e <literal>NonEuropean</literal> são sinônimos para
        <literal>MDY</literal>. Para obter informações adicionais deve ser
        consultada a <xref linkend="datatype-datetime">.
        O valor padrão é <literal>ISO, MDY</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-timezone" xreflabel="timezone">
      <term><varname>timezone</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>timezone</></primary>
      </indexterm>
      <indexterm><primary>zona horária</primary></>
      <listitem>
       <para>
        Define a zona horária para exibir e interpretar os carimbos do tempo.
        O valor padrão é 'unknown', o que significa utilizar o que estiver
        especificado no ambiente do sistema operacional para zona horária.
        Para obter informações adicionais deve ser consultada a
        <xref linkend="datatype-datetime">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-australian-timezones" xreflabel="australian_timezones">
      <term><varname>australian_timezones</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>australian_timezones</></primary>
      </indexterm>
      <indexterm><primary>zona horária</primary><secondary>Australiana</></>
      <listitem>
       <para>
        Se estiver definido como verdade, <literal>ACST</literal>,
        <literal>CST</literal>, <literal>EST</literal> e <literal>SAT</literal>
        são interpretados como zonas horárias da Austrália, em vez de zonas
        horárias das Américas e Sábado. O valor padrão é falso.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-extra-float-digits" xreflabel="extra_float_digits">
      <indexterm>
       <primary>dígitos significativos</primary>
      </indexterm>
      <indexterm>
       <primary>ponto flutuante</primary>
       <secondary>exibição</secondary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>extra_float_digits</></primary>
      </indexterm>

      <term><varname>extra_float_digits</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Ajusta o número de dígitos mostrados em valores de ponto flutuante,
        incluindo <type>float4</type>, <type>float8</type> e tipos de dado
        geométricos. O valor do parâmetro é adicionado ao número de dígitos
        padrão (<literal>FLT_DIG</literal> e <literal>DBL_DIG</literal>,
        conforme seja apropriado). O valor pode ser definido tão alto quanto 2,
        para incluir dígitos parcialmente significativos; é especialmente útil
        para dados de ponto flutuante em cópias de segurança, que precisem ser
        restaurados com exatidão. Também pode ser definido com um valor negativo
        para suprimir dígitos não desejados.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-client-encoding" xreflabel="client_encoding">
      <term><varname>client_encoding</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>client_encoding</></primary>
      </indexterm>
      <indexterm><primary>conjunto de caracteres</primary></>
      <listitem>
       <para>
        Define a codificação (conjunto de caracteres) do lado cliente.
        O padrão é utilizar a codificação do banco de dados.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-messages" xreflabel="lc_messages">
      <term><varname>lc_messages</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>lc_messages</></primary>
      </indexterm>
      <listitem>
       <para>
        Define a linguagem em que as mensagens são mostradas. Os valores aceitos
        são dependentes do sistema; para obter informações adicionais deve ser
        consultada a <xref linkend="locale">. Se esta variável for definida como
        uma cadeia de caracteres vazia (que é o padrão), então o valor é herdado
        do ambiente de execução do servidor de uma maneira dependente do sistema.
       </para>

       <para>
        Em alguns sistemas esta categoria de idioma não existe; definir
        esta variável funciona, mas não produz nenhum efeito.
        Existe, também, a chance de não haver mensagens traduzidas para o idioma
        desejado; neste caso, vão continuar sendo vistas mensagens em Inglês.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-monetary" xreflabel="lc_monetary">
      <term><varname>lc_monetary</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>lc_monetary</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o idioma a ser utilizado para formatar quantias monetárias
        como, por exemplo, na família de funções <function>to_char</function>.
        Os valores aceitos são dependentes do sistema; para obter mais
        informações deve ser consultada a <xref linkend="locale">. Se esta variável
        for definida como uma cadeia de caracteres vazia (que é o padrão), então
        o valor é herdado do ambiente de execução do servidor de uma maneira
        dependente do sistema.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-numeric" xreflabel="lc_numeric">
      <term><varname>lc_numeric</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>lc_numeric</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o idioma a ser utilizado para formatar números como, por
        exemplo, na família de funções <function>to_char()</function>.
        Os valores aceitos são dependentes do sistema;  para obter mais
        informações deve ser consultada a <xref linkend="locale">. Se esta variável
        for definida como uma cadeia de caracteres vazia (que é o padrão), então
        o valor é herdado do ambiente de execução do servidor de uma maneira
        dependente do sistema.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-time" xreflabel="lc_time">
      <term><varname>lc_time</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>lc_time</></primary>
      </indexterm>
      <listitem>
       <para>
        Define o idioma a ser utilizado para formatar valores de data e
        hora (Atualmente esta definição não faz nada, mas poderá fazer no
        futuro). Os valores aceitos são dependentes do sistema; para obter mais
        informações deve ser consultada a <xref linkend="locale">. Se esta variável
        for definida como uma cadeia de caracteres vazia (que é o padrão), então
        o valor é herdado do ambiente de execução do servidor de uma maneira
        dependente do sistema.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>

    </sect3>
     <sect3 id="runtime-config-client-other">
     <title>Outros padrões</title>

     <variablelist>

     <varlistentry id="guc-explain-pretty-print" xreflabel="explain_pretty_print">
      <term><varname>explain_pretty_print</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>explain_pretty_print</></primary>
      </indexterm>
      <listitem>
       <para>
        Determina se <command>EXPLAIN VERBOSE</command> utiliza a formatação
        com recuos ou sem recuos para mostrar o conteúdo detalhado das árvores
        de comando. O valor padrão é habilitado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-dynamic-library-path" xreflabel="dynamic_library_path">
      <term><varname>dynamic_library_path</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>dynamic_library_path</></primary>
      </indexterm>
      <indexterm><primary>carregamento dinâmico</primary></>
      <listitem>
       <para>
        Se for necessário abrir um módulo carregável dinamicamente, sem
        que o nome de arquivo especificado no comando
        <command>CREATE FUNCTION</command> ou no comando
        <command>LOAD</command> possua componente de diretório (ou seja, o
        nome não contém o caractere barra), o sistema procura pelo arquivo
        requisitado usando este caminho.
       </para>

       <para>
        O valor de <varname>dynamic_library_path</varname> deve ser uma lista
        de caminhos absolutos de diretório separados por dois-pontos.
        Se o elemento da lista começar pela cadeia de caracteres especial
        <literal>$libdir</literal>, este valor é substituído pelo diretório de
        biblioteca do pacote <productname>PostgreSQL</productname> compilado.
        Este é o local onde os módulos fornecidos na distribuição do
        <productname>PostgreSQL</productname> são instalados (deve ser utilizado
        o comando <literal>pg_config --pkglibdir</literal> para descobrir o nome
        deste diretório
        <footnote>
         <para>
          Também pode ser utilizado o comando
          <literal>locate plpgsql.so</literal> para ver o nome deste diretório,
          se <literal>pg_config</literal> não estiver disponível. (N. do T.)
         </para>
        </footnote>
        ). Por exemplo:
<programlisting>
dynamic_library_path = '/usr/local/lib/postgresql:/home/my_project/lib:$libdir'
</programlisting>
        ou, no ambiente <productname>Windows</productname>:
<programlisting>
dynamic_library_path = 'C:\tools\postgresql;H:\my_project\lib;$libdir'
</programlisting>
       </para>

       <para>
        O valor padrão deste parâmetro é <literal>'$libdir'</literal>.
        Se o valor for definido como uma cadeia de caracteres
        vazia, é desabilitada a procura automática no caminho.
       </para>

       <para>
        Este parâmetro pode ser modificado em tempo de execução pelos
        superusuários, mas a definição feita desta maneira somente é preservada
        até o final da conexão do cliente, portanto este método deve ser
        reservado para fins de desenvolvimento. A maneira recomendada para
        definir este parâmetro é através do arquivo de configuração
        <filename>postgresql.conf</filename>.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-locks">
    <title>Gerenciamento de bloqueio</title>

     <variablelist>

     <varlistentry id="guc-deadlock-timeout" xreflabel="deadlock_timeout">
      <indexterm>
       <primary>impasse</primary>
       <secondary>tempo esgotado durante</secondary>
      </indexterm>
      <indexterm>
       <primary>tempo esgotado</primary>
       <secondary>impasse</secondary>
      </indexterm>
      <indexterm>
       <primary>parâmetro de configuração <varname>deadlock_timeout</></primary>
      </indexterm>

      <term><varname>deadlock_timeout</varname> (<type>integer</type>)</term>
      <listitem>
       <para>
        Quantidade de tempo, em milissegundos, para aguardar pelo
        término do bloqueio antes de verificar a existência de uma condição de
        impasse (<literal>deadlock</literal>). A verificação de impasse é
        relativamente lenta e, portanto, o servidor não faz esta verificação
        toda vez que aguarda pelo término do bloqueio. Nós (otimistas?)
        assumimos que os bloqueios não são comuns em aplicativos em produção e,
        simplesmente, aguardamos pelo término do bloqueio por algum tempo antes
        de começar a verificar a situação de impasse. O aumento deste valor
        reduz a quantidade de tempo desperdiçada em verificações de impasse
        desnecessárias, mas atrasa o relato de erros de impasse verdadeiros.
        O valor padrão é 1000 (ou seja, um segundo), que provavelmente é o menor
        valor desejado na prática. Em servidores muito carregados pode ser
        desejado aumentar este valor. A definição ideal deve ser um valor
        superior ao tempo típico de uma transação, para melhorar a chance do
        bloqueio ser liberado antes de decidir verificar o impasse.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-locks-per-transaction" xreflabel="max_locks_per_transaction">
      <term><varname>max_locks_per_transaction</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_locks_per_transaction</></primary>
      </indexterm>
      <listitem>
       <para>
        A tabela de bloqueio compartilhada é dimensionada pela hipótese de que
        é necessário bloquear, no máximo,
        <varname>max_locks_per_transaction</varname> *
        <varname>max_connections</varname> objetos distintos de uma vez
        (Desta forma, o nome deste parâmetro pode confundir: não é um limite
        rígido do número de bloqueios de alguma transação, mas sim o valor
        médio máximo).
        O valor padrão, 64, tem se mostrado historicamente suficiente, mas pode
        ser necessário aumentar este valor quando há clientes que acessam muitas
        tabelas diferentes em uma única transação.
        Somente pode ser definido na inicialização do servidor.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
   </sect2>

   <sect2 id="runtime-config-compatible">
    <title>Compatibilidade de versão e de plataforma</title>

    <sect3 id="runtime-config-compatible-version">
     <title>Versões anteriores do PostgreSQL</title>
     <variablelist>

     <varlistentry id="guc-add-missing-from" xreflabel="add_missing_from">
      <term><varname>add_missing_from</varname> (<type>boolean</type>)</term>
      <indexterm><primary>FROM</><secondary>faltando</></>
      <indexterm>
       <primary>parâmetro de configuração <varname>add_missing_from</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando o valor for igual a <literal>true</literal>, as tabelas
        referenciadas por uma consulta serão automaticamente adicionadas à
        cláusula <literal>FROM</literal>, caso não estejam presentes. O valor
        padrão é <literal>true</literal> para manter a compatibilidade com
        as versões anteriores do <productname>PostgreSQL</productname>.
        Entretanto, este comportamento não é SQL-padrão, e muitas pessoas não
        gostam porque pode esconder enganos. Deve ser definido como
        <literal>false</literal> para obter o comportamento SQL-padrão de
        rejeitar referências a tabelas que não estão presentes na cláusula
        <literal>FROM</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-regex-flavor" xreflabel="regex_flavor">
      <term><varname>regex_flavor</varname> (<type>string</type>)</term>
      <indexterm><primary>expressões regulares</primary></>
      <indexterm>
       <primary>parâmetro de configuração <varname>regex_flavor</></primary>
      </indexterm>
      <listitem>
       <para>
        A <quote>variedade</quote> (<literal>flavor</literal>>) de expressão
        regular pode ser definida como <literal>advanced</literal>,
        <literal>extended</literal> ou <literal>basic</literal>.
        O valor padrão é <literal>advanced</literal>.
        Definir como <literal>extended</literal> pode ser útil para manter a
        compatibilidade exata com as versões do
        <productname>PostgreSQL</productname> anteriores a 7.4.
        Para obter detalhes deve ser consultada a
        <xref linkend="posix-syntax-details">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-sql-inheritance" xreflabel="sql_inheritance">
      <term><varname>sql_inheritance</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>sql_inheritance</></primary>
      </indexterm>
      <indexterm><primary>herança</primary></>
      <listitem>
       <para>
        Controla a semântica da herança, em particular se as subtabelas são
        incluídas por padrão em vários comandos. Não eram incluídas nas versões
        anteriores a 7.1. Se for necessário usar o comportamento antigo esta
        variável pode ser definida como desabilitada, mas a longo prazo
        incentiva-se mudar os aplicativos para que passem a utilizar a palavra
        chave <literal>ONLY</literal> para excluir as subtabelas. Para obter
        informações adicionais sobre herança deve ser consultada a
        <xref linkend="ddl-inherit">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-default-with-oids" xreflabel="default_with_oids">
      <term><varname>default_with_oids</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>default_with_oids</></primary>
      </indexterm>
      <listitem>
       <para>
        Controla se os comandos <command>CREATE TABLE</command> e
        <command>CREATE TABLE AS</command> incluem a coluna OID nas tabelas
        criadas, caso não seja especificado <literal>WITH OIDS</literal>
        nem <literal>WITHOUT OIDS</literal>. Também determina se os OIDs serão
        incluídos nas tabelas criadas através do comando
        <command>SELECT INTO</command>. No
        <productname>PostgreSQL &version;</productname> o valor padrão para
        <varname>default_with_oids</varname> é habilitado. Este é também o
        comportamento das versões anteriores do
        <productname>PostgreSQL</productname>. Entretanto, não se encoraja
        que seja assumido que as tabelas irão conter OIDs por padrão.
        Provavelmente o valor padrão desta opção será igual a desabilitado nas
        versões futuras do <productname>PostgreSQL</productname>.
       </para>

       <para>
        Para facilitar a compatibilidade com os aplicativos que utilizam OIDs,
        esta opção deve ser deixada habilitada. Para facilitar a compatibilidade
        com as versões futuras do <productname>PostgreSQL</productname>, esta
        opção deve ser desabilitada, e os aplicativos que necessitarem de OIDs
        para determinadas tabelas devem especificar, explicitamente,
        <literal>WITH OIDS</literal> no momento de criação das tabelas.
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
    <sect3 id="runtime-config-compatible-clients">
     <title>Compatibilidade de plataforma e cliente</title>
     <variablelist>

     <varlistentry id="guc-transform-null-equals" xreflabel="transform_null_equals">
      <term><varname>transform_null_equals</varname> (<type>boolean</type>)</term>
      <indexterm><primary>IS NULL</></>
      <indexterm>
       <primary>parâmetro de configuração <varname>transform_null_equals</></primary>
      </indexterm>
      <listitem>
       <para>
        Quando habilitado, as expressões da forma
        <literal><replaceable>expr</replaceable> = NULL</literal> (ou
        <literal>NULL = <replaceable>expr</replaceable></literal>) são tratadas
        como <literal><replaceable>expr</replaceable> IS NULL</literal>,
        ou seja, retornam verdade se <replaceable>expr</replaceable> resultar
        em um valor nulo, e falso caso contrário. O comportamento correto de
        <literal><replaceable>expr</replaceable> = NULL</literal> é sempre
        retornar nulo (desconhecido). Portanto, o valor padrão desta opção é
        desabilitado.
       </para>

       <para>
        Entretanto, no <productname>Microsoft Access</productname> formulários
        filtrados produzem consultas que parecem utilizar
        <literal><replaceable>expr</replaceable> = NULL</literal> para testar
        valores nulos e, portanto, se for utilizada esta interface para acessar
        o banco de dados pode ser necessário habilitar esta opção.
        Uma vez que as expressões da forma
        <literal><replaceable>expr</replaceable> = NULL</literal> sempre
        retornam o valor nulo (utilizando a interpretação correta), não são
        muito úteis e, por isso, não aparecem com freqüência nos aplicativos
        normais, portanto esta opção produz pouco dano na prática. Porém, os
        novos usuários ficam freqüentemente confusos sobre a semântica das
        expressões que envolvem valores nulos e, portanto, esta opção não é
        habilitada por padrão.
       </para>

       <para>
        Deve ser observado que esta opção afeta apenas a forma exata
        <literal>= NULL</literal>, e não os outros operadores de comparação ou
        outras expressões computacionalmente equivalentes a alguma expressão
        envolvendo o operador de igual (como o <literal>IN</literal>).
        Portanto, esta opção não é uma solução geral para má programação.
       </para>

       <para>
        Para ver informações relacionadas deve ser consultada a
        <xref linkend="functions-comparison"> .
       </para>
      </listitem>
     </varlistentry>

     </variablelist>
    </sect3>
   </sect2>

   <sect2 id="runtime-config-preset">
    <title>Opções pré-definidas</title>

    <para>
     Os <quote>parâmetros</> que se seguem são apenas para leitura, sendo
     determinados quando o <productname>PostgreSQL</productname> é compilado,
     ou quando é instalado. Desta forma, foram excluídos do arquivo
     <filename>postgresql.conf</> modelo. Estes parâmetros dão informações sobre
     vários aspectos do comportamento do <productname>PostgreSQL</productname>
     que podem ser de interesse de determinados aplicativos, em particular de
     aplicativos cliente administrativos.
    </para>

    <variablelist>

     <varlistentry id="guc-block-size" xreflabel="block_size">
      <term><varname>block_size</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>block_size</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o tamanho de um bloco de disco. É determinado pelo valor de
        <literal>BLCKSZ</> quando o servidor é construído. O valor padrão é
        8192 bytes. O significado de algumas variáveis de configuração
        (como <xref linkend="guc-shared-buffers">) é influenciado por
        <varname>block_size</varname>. Para obter informações adicionais deve
        ser consultada a <xref linkend="runtime-config-resource">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-integer-datetimes" xreflabel="integer_datetimes">
      <term><varname>integer_datetimes</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>integer_datetimes</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra se o <productname>PostgreSQL</productname> foi construído com
        suporte para data e hora com inteiros de 64 bits.  É definido
        configurando com <literal>--enable-integer-datetimes</literal>
        quando o <productname>PostgreSQL</productname> é construído.
        O valor padrão é <literal>off</literal>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-collate" xreflabel="lc_collate">
      <term><varname>lc_collate</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>lc_collate</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o idioma usado para fazer a classificação de dados textuais.
        Para obter informações adicionais deve ser consultada a
        <xref linkend="locale">. O valor é determinado quando o agrupamento de
        bancos de dados é inicializado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-lc-ctype" xreflabel="lc_ctype">
      <term><varname>lc_ctype</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>lc_ctype</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o idioma que determina a classificação dos caracteres.
        Para obter informações adicionais deve ser consultada a
        <xref linkend="locale">.
        O valor é determinado quando o agrupamento de bancos de dados é
        inicializado. Normalmente é a mesma utilizada em
        <varname>lc_collate</varname>, mas pode ser definido um valor diferente
        para aplicações especiais.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-function-args" xreflabel="max_function_args">
      <term><varname>max_function_args</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_function_args</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o número máximo de argumentos de uma função. É determinado pelo
        valor de <literal>FUNC_MAX_ARGS</> quando o servidor é construído.
        O valor padrão é 32.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-identifier-length" xreflabel="max_identifier_length">
      <term><varname>max_identifier_length</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_identifier_length</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o comprimento máximo do identificador. É determinado como sendo
        o valor de <literal>NAMEDATALEN</> menos 1 quando o servidor é
        construído. O valor padrão de <literal>NAMEDATALEN</> é 64; portanto o
        valor padrão de <varname>max_identifier_length</varname> é 63.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-max-index-keys" xreflabel="max_index_keys">
      <term><varname>max_index_keys</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>max_index_keys</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o número máximo de chaves de índice. É determinado pelo valor de
        <literal>INDEX_MAX_KEYS</> quando o servidor é construído.
        O valor padrão é 32.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-encoding" xreflabel="server_encoding">
      <term><varname>server_encoding</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>server_encoding</></primary>
      </indexterm>
      <indexterm><primary>conjunto de caracteres</primary></>
      <listitem>
       <para>
        Mostra a codificação do banco de dados (conjunto de caracteres).
        É determinado quando o banco de dados é criado.
        Normalmente os clientes precisam se preocupar apenas com o valor de
        <xref linkend="guc-client-encoding">.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-server-version" xreflabel="server_version">
      <term><varname>server_version</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>server_version</></primary>
      </indexterm>
      <listitem>
       <para>
        Mostra o número da versão do servidor. É determinado pelo valor de
        <literal>PG_VERSION</> quando o servidor é construído.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </sect2>

   <sect2 id="runtime-config-custom">
    <title>Opções personalizadas</title>

    <para>
     Esta funcionalidade foi projetada para permitir que os módulos
     complementares (como as linguagens procedurais) adicionem opções que
     normalmente não são conhecidas pelo <productname>PostgreSQL</productname>.
     Isto permite que os módulos complementares sejam configurados da maneira
     padrão.
    </para>

    <variablelist>

     <varlistentry id="guc-custom-variable-classes" xreflabel="custom_variable_classes">
      <term><varname>custom_variable_classes</varname> (<type>string</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>custom_variable_classes</></primary>
      </indexterm>
      <listitem>
       <para>
        Especifica um ou vários nomes de classe a serem utilizados pelas
        variáveis personalizadas, na forma de uma lista separada por vírgulas.
        Uma variável personalizada é uma variável que normalmente não é
        conhecida pelo próprio <productname>PostgreSQL</productname>, mas que
        é utilizada por algum módulo complementar.
        Estas variáveis devem possuir nomes formados pelo nome da classe,
        um ponto, e o nome da variável.
        O parâmetro <varname>custom_variable_classes</> especifica todos os
        nomes de classe utilizados por uma determinada instalação.
        Somente pode ser definido na inicialização do servidor,
        ou no arquivo <filename>postgresql.conf</filename>.
       </para>

      </listitem>
     </varlistentry>
    </variablelist>

    <para>
     A dificuldade em definir variáveis personalizadas no arquivo
     <filename>postgresql.conf</>, é que este arquivo deve ser lido antes dos
     módulos complementares serem carregados e, portanto, normalmente as
     variáveis personalizadas são rejeitadas por serem desconhecidas.
     Quando é definido o parâmetro <varname>custom_variable_classes</>, o
     servidor aceita definições de variáveis arbitrárias para as classes
     especificadas. Estas variáveis são tratadas como posicionadores
     (<literal>placeholders</literal>), não tendo nenhuma função até que o
     o módulo que as define seja carregado. Quando o módulo de uma determinada
     classe é carregado, este adiciona as definições apropriadas de variáveis
     para seu nome de classe, converte os valores dos posicionadores de acordo
     com estas definições, e emite advertências para todos os posicionadores
     de sua classe remanescentes (que se presume como sendo variáveis de
     configuração escritas de forma errada).
    </para>

    <para>
     Abaixo está mostrado um exemplo do que o arquivo
     <filename>postgresql.conf</filename> deve conter quando são usadas
     variáveis personalizadas:

<programlisting>
custom_variable_classes = 'plr,pljava'
plr.path = '/usr/lib/R'
pljava.foo = 1
plruby.bar = true        # gera erro, nome de classe desconhecido
</programlisting>
    </para>
   </sect2>

   <sect2 id="runtime-config-developer">
    <title>Opções do desenvolvedor</title>

    <para>
     As opções a seguir foram feitas para funcionar no código fonte do
     <productname>PostgreSQL</productname> e, em alguns casos, ajudar na
     recuperação de bancos de dados seriamente danificados. Não deve haver
     razão para usá-las na configuração de um banco de dados de produção.
     Por isso, foram excluídas do arquivo <filename>postgresql.conf</filename>
     modelo. Deve ser observado que muitas destas opções requerem sinalizadores
     especiais na compilação do código fonte para que funcionem.
    </para>

    <variablelist>
     <varlistentry id="guc-debug-assertions" xreflabel="debug_assertions">
      <term><varname>debug_assertions</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>debug_assertions</></primary>
      </indexterm>
      <listitem>
       <para>
        Habilita várias verificações de asserção. É uma ajuda de depuração. Se
        estiverem acontecendo problemas estranhos, ou quedas, pode se querer
        habilitá-la, porque podem ser mostrados erros de programação. Para
        utilizar esta opção a macro <literal>USE_ASSERT_CHECKING</literal>
        deverá estar definida quando o <productname>PostgreSQL</productname>
        for construído (realizado pela opção <option>--enable-cassert</option>
        do <command>configure</command>). Deve ser observado que
        <literal>debug_assertions</literal> é habilitado por padrão quando o
        <productname>PostgreSQL</productname> é construído com as asserções
        habilitadas.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-debug-shared-buffers" xreflabel="debug_shared_buffers">
      <term><varname>debug_shared_buffers</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>debug_shared_buffers</></primary>
      </indexterm>
      <listitem>
       <para>
        Número de segundos entre os relatos de lista de
        <literal>buffers</literal> livres. Se for maior que zero emite
        estatísticas <literal>buffers</literal> livres para o registro ao
        intervalo desta quantidade de segundos. O valor padrão igual a zero
        desabilita o relato.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-pre-auth-delay" xreflabel="pre_auth_delay">
      <term><varname>pre_auth_delay</varname> (<type>integer</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>pre_auth_delay</></primary>
      </indexterm>
      <listitem>
       <para>
        Se for diferente de zero, logo após um novo processo servidor ser
        lançado (<literal>forked</literal>) ocorre um retardo desta quantidade
        de segundos, antes de realizar o processo de autenticação. Tem por
        finalidade dar oportunidade de anexar o processo servidor a um
        depurador para acompanhar um mal comportamento na autenticação.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-trace-notify" xreflabel="trace_notify">
      <term><varname>trace_notify</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>trace_notify</></primary>
      </indexterm>
      <listitem>
       <para>
        Gera uma grande quantidade de saída de depuração para os comandos
        <command>LISTEN</command> e <command>NOTIFY</command>.
        O valor do parâmetro <xref linkend="guc-client-min-messages"> ou
        <xref linkend="guc-log-min-messages"> deve ser
        <literal>DEBUG1</literal>, ou inferior, para que esta saída seja
        enviada para o <literal>log</literal> do cliente ou do servidor,
        respectivamente.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><varname>trace_locks</varname> (<type>boolean</type>)</term>
      <term><varname>trace_lwlocks</varname> (<type>boolean</type>)</term>
      <term><varname>trace_userlocks</varname> (<type>boolean</type>)</term>
      <term><varname>trace_lock_oidmin</varname> (<type>boolean</type>)</term>
      <term><varname>trace_lock_table</varname> (<type>boolean</type>)</term>
      <term><varname>debug_deadlocks</varname> (<type>boolean</type>)</term>
      <term><varname>log_btree_build_stats</varname> (<type>boolean</type>)</term>
      <listitem>
       <para>
        Várias outras opções de rastreamento e depuração de código.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry id="guc-wal-debug" xreflabel="wal_debug">
      <term><varname>wal_debug</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>wal_debug</></primary>
      </indexterm>
      <listitem>
       <para>
        Se o valor for verdade, emite saída de depuração relacionada com o WAL.
        Esta opção somente estará disponível se a macro
        <symbol>WAL_DEBUG</symbol> for definida quando o
        <productname>PostgreSQL</productname> for compilado.
       </para>
      </listitem>
     </varlistentry>

    <varlistentry id="guc-zero-damaged-pages" xreflabel="zero_damaged_pages">
      <term><varname>zero_damaged_pages</varname> (<type>boolean</type>)</term>
      <indexterm>
       <primary>parâmetro de configuração <varname>zero_damaged_pages</></primary>
      </indexterm>
      <listitem>
       <para>
        A detecção de um cabeçalho de página danificado normalmente faz com que
        o <productname>PostgreSQL</productname> relate um erro e interrompa o
        comando corrente. Definir <varname>zero_damaged_pages</varname> como
        verdade faz com que em vez disto o sistema relate uma advertência, limpe
        a página danificada, e continue o processamento. Este comportamento
        <emphasis>destrói os dados</emphasis>, especificamente todas as linhas
        na página danificada, mas permite prosseguir após o erro e ler as linhas
        da tabela porventura presentes em páginas não danificadas. Portanto, é
        útil para recuperar dados se a corrupção tiver ocorrido devido à erro de
        máquina ou de software. Geralmente esta opção não deve ser definida como
        verdade, até que se tenha perdido a esperança de recuperar os dados das
        páginas danificadas da tabela. A definição padrão é desabilitado, e
        somente pode ser modificado por um superusuário.
       </para>
      </listitem>
     </varlistentry>
   </variablelist>
  </sect2>
  <sect2 id="runtime-config-short">
   <title>Opções curtas</title>

   <para>
    Para facilitar também estão disponíveis, para alguns parâmetros, chaves de
    opção de linha de comando de uma única letra, conforme descrito na
    <xref linkend="runtime-config-short-table">.
   </para>

    <table id="runtime-config-short-table">
     <title>Chave de opção curta</title>
     <tgroup cols="2">
      <thead>
       <row>
        <entry>Opção curta</entry>
        <entry>Equivalente</entry>
       </row>
      </thead>

      <tbody>
       <row>
        <entry><option>-B <replaceable>x</replaceable></option></entry>
        <entry><literal>shared_buffers = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-d <replaceable>x</replaceable></option></entry>
        <entry><literal>log_min_messages = DEBUG<replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-F</option></entry>
        <entry><literal>fsync = off</></entry>
       </row>
       <row>
        <entry><option>-h <replaceable>x</replaceable></option></entry>
        <entry><literal>listen_addresses = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-i</option></entry>
        <entry><literal>listen_addresses = '*'</></entry>
       </row>
       <row>
        <entry><option>-k <replaceable>x</replaceable></option></entry>
        <entry><literal>unix_socket_directory = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-l</option></entry>
        <entry><literal>ssl = on</></entry>
       </row>
       <row>
        <entry><option>-N <replaceable>x</replaceable></option></entry>
        <entry><literal>max_connections = <replaceable>x</replaceable></></entry>
       </row>
       <row>
        <entry><option>-p <replaceable>x</replaceable></option></entry>
        <entry><literal>port = <replaceable>x</replaceable></></entry>
       </row>

       <row>
        <entry>
          <option>-fi</option>, <option>-fh</option>,
          <option>-fm</option>, <option>-fn</option>,
          <option>-fs</option>, <option>-ft</option><footnote
          id="fn.runtime-config-short">
           <para>
            Por motivos históricos estas opções devem ser passadas para os
            processos servidor individuais através da opção <option>-o</option>
            do <command>postmaster</command> como, por exemplo,
<screen>
$ <userinput>postmaster -o '-S 1024 -s'</userinput>
</screen>
            ou através da variável de ambiente <envar>PGOPTIONS</envar>
            no lado cliente, conforme explicado acima.
           </para>
          </footnote>
         </entry>
         <entry>
          <literal>enable_indexscan = off</>,
          <literal>enable_hashjoin = off</>,
          <literal>enable_mergejoin = off</>,
          <literal>enable_nestloop = off</>,
          <literal>enable_seqscan = off</>,
          <literal>enable_tidscan = off</>
         </entry>
       </row>

       <row>
        <entry><option>-s</option><footnoteref linkend="fn.runtime-config-short"></entry>
        <entry><literal>log_statement_stats = on</></entry>
       </row>

       <row>
        <entry><option>-S <replaceable>x</replaceable></option><footnoteref linkend="fn.runtime-config-short">
        </entry>
        <entry><literal>work_mem = <replaceable>x</replaceable></></entry>
       </row>

       <row>
        <entry><option>-tpa</option>, <option>-tpl</option>, <option>-te</option><footnoteref linkend="fn.runtime-config-short"></entry>
        <entry><literal>log_parser_stats = on</>,
        <literal>log_planner_stats = on</>,
        <literal>log_executor_stats = on</></entry>
       </row>
      </tbody>
     </tgroup>
    </table>

  </sect2>
 </sect1>


 <sect1 id="kernel-resources">
  <title>Gerência dos recursos do núcleo</title>

  <para>
   Uma instalação grande do <productname>PostgreSQL</productname> pode exaurir,
   rapidamente, vários limites de recurso do sistema operacional (Em alguns
   sistemas, o padrão de distribuição é tão baixo que, na verdade, nem é
   necessária uma instalação <quote>grande</quote> para exaurir os recursos).
   Caso tenha deparado com este tipo de problema, prossiga a leitura.
  </para>

  <sect2 id="sysvipc">
   <title>Memória compartilhada e semáforos</title>

   <indexterm zone="sysvipc">
    <primary>memória compartilhada</primary>
   </indexterm>

   <indexterm zone="sysvipc">
    <primary>semáforo</primary>
   </indexterm>

   <para>
    A memória compartilhada e os semáforos são referenciados coletivamente como
    <quote><systemitem class="osname">System V</systemitem>
    <acronym>IPC</acronym></quote>
    <footnote>
     <para>
      Com o <systemitem class="osname">System V</systemitem> a AT&amp;T
      introduziu três novas formas de facilidade de comunicação entre processos
      (<acronym>IPC</acronym>) (filas de mensagens, semáforos e memória
      compartilhada). Embora o comitê POSIX ainda não tenha completado a
      padronização destas facilidades, a maioria das implementações dão suporte
      as mesmas. Além disso, Berkeley (<acronym>BSD</acronym>) utiliza
      soquetes como sua forma primária de <acronym>IPC</acronym>, em vez dos
      elementos do <systemitem class="osname">System V</systemitem>.
      O <systemitem class=osname>Linux</systemitem> tem capacidade para
      utilizar as duas formas de <acronym>IPC</acronym>, tanto
      <acronym>BSD</acronym> quanto
      <systemitem class="osname">System V</systemitem>.
      <ulink url="http://www.tldp.org/LDP/lpg/node21.html">System V IPC</ulink>
      (N. do T.)
     </para>
    </footnote>
    (junto com as filas de mensagens, que não são relevantes para o
    <productname>PostgreSQL</productname>). Quase todo sistema
    operacional moderno fornece estas funcionalidades, mas nem todos as têm
    ativas ou com tamanho suficiente por padrão, especialmente os sistemas
    herdados do BSD (Para os <literal>ports</literal> para o
    <systemitem class="osname">QNX</systemitem> e para o
    <systemitem class="osname">BeOS</systemitem>, o
    <productname>PostgreSQL</productname> fornece sua própria implementação de
    substituição destas funcionalidades).
   </para>

   <para>
    A completa falta destas funcionalidades é geralmente manifestada por um erro
    de <quote><errorname>Chamada de sistema ilegal</errorname></quote> na
    inicialização do servidor. Neste caso, não existe nada a ser feito além de
    reconfigurar o núcleo. O <productname>PostgreSQL</productname> não funciona
    sem estas funcionalidades.
   </para>

   <para>
    Quando o <productname>PostgreSQL</productname> excede um dos vários limites
    rígidos do <acronym>IPC</acronym>, o servidor se recusa a inicializar,
    e deve deixar uma mensagem de erro instrutiva descrevendo o problema
    encontrado e o que fazer sobre o mesmo (Também deve ser consultada a <xref
    linkend="postmaster-start-failures">.) Os parâmetros relevantes do núcleo
    possuem nomes consistentes entre sistemas diferentes; A <xref
    linkend="sysvipc-parameters"> mostra uma visão geral. Entretanto, os métodos
    para defini-los variam. Abaixo são fornecidas sugestões para algumas
    plataformas. Não se deve esquecer que geralmente é necessário reinicializar
    o computador e até, possivelmente, recompilar o núcleo para alterar estas
    definições.
   </para>


   <table id="sysvipc-parameters">
    <title>Parâmetros do <acronym>IPC</acronym> do <systemitem class="osname">System V</systemitem></title>

    <tgroup cols="3">
     <thead>
      <row>
       <entry>Nome</entry>
       <entry>Descrição</entry>
       <entry>Valores razoáveis</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><varname>SHMMAX</></>
       <entry>
        Tamanho máximo de um segmento de memória compartilhada (bytes)
        <footnote>
         <para>
          A função shmget() é utilizada para obter acesso a um segmento de
          memória compartilhada. Esta função falha se o valor do tamanho for
          menor que SHMMIN ou maior do que SHMMAX.
          <ulink url="http://docs.sun.com/db/doc/801-6736/6i13fom0j?a=view">
          Sun Product Documentation</ulink> (N. do T.)
         </para>
        </footnote>
       </entry>
       <entry>250 kB + 8.2 kB * <xref linkend="guc-shared-buffers"> +
       14.2 kB * <xref linkend="guc-max-connections"> até o infinito</entry>
      </row>

      <row>
       <entry><varname>SHMMIN</></>
       <entry>Tamanho mínimo de um segmento de memória compartilhada (bytes)</>
       <entry>1</>
      </row>

      <row>
       <entry><varname>SHMALL</></>
       <entry>
        Quantidade total de memória compartilhada disponível (bytes ou páginas)
       </entry>
       <entry>
        se em bytes, o mesmo que <varname>SHMMAX</varname>; se em páginas,
        <literal>ceil(SHMMAX/PAGE_SIZE)</literal>
       </entry>
      </row>

      <row>
       <entry><varname>SHMSEG</></>
       <entry>Número máximo de segmentos de memória compartilhada por processo</entry>
       <entry>somente 1 segmento é necessário, mas o padrão é muito maior</entry>
      </row>

       <row>
        <entry><varname>SHMMNI</></>
        <entry>Número máximo de segmentos de memória compartilhada para todo o sistema</entry>
        <entry>como <varname>SHMSEG</varname> mais espaço para outras aplicações</entry>
       </row>

       <row>
        <entry><varname>SEMMNI</></>
        <entry>Número máximo de identificadores de semáforos (ou seja, conjuntos)</entry>
        <entry>pelo menos <literal>ceil(max_connections / 16)</literal></entry>
       </row>

       <row>
        <entry><varname>SEMMNS</varname></entry>
        <entry>Número máximo de semáforos para todo o sistema</entry>
        <entry>
         <literal>ceil(max_connections / 16) * 17</literal> mais espaço para
         outras aplicações
        </entry>
       </row>

       <row>
        <entry><varname>SEMMSL</></>
        <entry>Número máximo de semáforos por conjunto</entry>
        <entry>pelo menos 17</entry>
       </row>

       <row>
        <entry><varname>SEMMAP</></>
        <entry>
         Número de entradas no mapa de semáforos
         <footnote>
          <para>
           SEMMAP deve ser definido como o produto de SEMMNI e SEMMSL:
           (SEMMAP = SEMMNI * SEMMSL).
           <ulink url="http://www.carumba.com/talk/random/swol-10-insidesolaris-2.html">
           Setting our sights on semaphores</ulink> (N. do T.)
          </para>
         </footnote>
        </entry>
        <entry>consulte o texto</entry>
       </row>

       <row>
        <entry><varname>SEMVMX</></>
        <entry>Valor máximo de um semáforo</entry>
        <entry>
         pelo menos 1000 (O padrão é geralmente 32767; não mude a não ser
         quando for obrigado a fazê-lo)
        </entry>
       </row>

     </tbody>
    </tgroup>
   </table>


   <para>
    <indexterm><primary>SHMMAX</primary></indexterm>
    O parâmetro de memória compartilhada mais importante é
    <varname>SHMMAX</varname>, o tamanho máximo, em bytes, de um segmento de
    memória compartilhada. Se for recebida uma mensagem de erro da função
    <function>shmget</function> como
    <quote><errorname>Argumento inválido</errorname></quote>,
    é provável que este limite tenha sido excedido. O tamanho do segmento de
    memória compartilhada requerido varia tanto com o número de
    <literal>buffers</literal> requisitados (opção <option>-B</option>) quanto
    com o número de conexões permitidas (opção <option>-N</option>), embora esta
    última seja mais significativa (É possível, como uma solução temporária,
    diminuir estas definições para eliminar o problema). Como uma aproximação
    grosseira, o tamanho de segmento requerido pode ser estimado conforme
    sugerido em <xref linkend="sysvipc-parameters">.
    Toda mensagem de erro que vier a ser recebida conterá o tamanho da alocação
    requerida que falhou.
   </para>

   <para>
    Alguns sistemas também possuem um limite para a quantidade total de memória
    compartilhada do sistema (<varname>SHMALL</>). Deve-se ter certeza que é
    grande o suficiente para o <productname>PostgreSQL</> mais as outras
    aplicações que utilizam segmentos de memória compartilhada. (Cuidado:
    em muitos sistemas <varname>SHMALL</> é medido em páginas, e não em bytes).
   </para>

   <para>
    Menos provável de causar problema é o tamanho mínimo para os segmentos de
    memória compartilhada (<varname>SHMMIN</varname>), que deve ser no máximo
    aproximadamente 256 kB para o <productname>PostgreSQL</productname>
    (geralmente é apenas 1). O número máximo de segmentos para todo o sistema
    (<varname>SHMMNI</varname>) ou por processo (<varname>SHMSEG</varname>) não
    devem causar problema a menos que o sistema os tenha definido como zero.
   </para>

   <para>
    O <productname>PostgreSQL</productname> utiliza um semáforo por conexão
    permitida (opção <option>-N</option>), em conjuntos de 16. Cada um destes
    conjuntos também contém um 17º semáforo contendo um <quote>número
    mágico</quote>, para detectar colisões com conjuntos de semáforos utilizados
    por outras aplicações. O número máximo de semáforos no sistema é definido
    por <varname>SEMMNS</varname> que, conseqüentemente, deve ser pelo menos
    tão alto quanto <literal>max_connections</literal> mais um adicional para
    cada 16 conexões permitidas (veja a fórmula na <xref
    linkend="sysvipc-parameters">). O parâmetro <varname>SEMMNI</varname>
    determina o limite do número de conjuntos de semáforos que podem existir
    no sistema de uma vez. Portanto, este parâmetro deve ser pelo menos igual a
    <literal>ceil(max_connections / 16)</literal>. Diminuir o número de conexões
    permitidas é um recurso temporário para evitar falhas, geralmente informadas
    pela mensagem <quote><errorname>Nenhum espaço disponível na unidade</></>
    emitida pela função <function>semget</function>, que confunde.
   </para>

   <para>
    Em alguns casos também pode ser necessário aumentar
    <varname>SEMMAP</varname>, para que fique pelo menos na ordem de grandeza de
    <varname>SEMMNS</varname>. Este parâmetro define o tamanho do mapa de
    recursos de semáforos, no qual cada bloco contíguo de semáforos disponíveis
    precisa de uma entrada. Quando um conjunto de semáforos é liberado, este
    conjunto é adicionado a uma entrada existente adjacente ao bloco liberado,
    ou é registrado sob uma nova entrada no mapa. Se o mapa estiver cheio, os
    semáforos liberados serão perdidos (até a reinicialização do servidor).
    A fragmentação do espaço de semáforos pode, ao longo do tempo, fazer com
    que haja menos semáforos disponíveis do que deveria haver.
   </para>

   <para>
    O parâmetro <varname>SEMMSL</varname>, que determina quantos
    semáforos podem existir em um conjunto, deve ser pelo menos igual a 17
    para o <productname>PostgreSQL</productname>.
   </para>

   <para>
    Várias outras definições relacionadas com <quote>desfazer semáforo</quote>,
    como <varname>SEMMNU</varname> e <varname>SEMUME</varname>, não são de
    interesse do <productname>PostgreSQL</productname>.
   </para>

    <variablelist>

     <varlistentry>
      <term><systemitem class="osname">BSD/OS</></term>
      <indexterm><primary>BSD/OS</><secondary>configuração do IPC</></>
      <listitem>
       <formalpara>
        <title>Memória compartilhada</title>
        <para>
         Por padrão, são suportados somente 4 MB de memória compartilhada.
         Deve-se ter em mente que a memória compartilhada não é paginável;
         fica bloqueada na RAM. Para aumentar a quantidade de memória
         compartilhada suportada pelo sistema, deve ser adicionado algo parecido
         com as linhas mostradas abaixo ao arquivo de configuração do núcleo.
<programlisting>
options "SHMALL=8192"
options "SHMMAX=\(SHMALL*PAGE_SIZE\)"
</programlisting>
         <varname>SHMALL</> é medido em páginas de 4KB, portanto um valor igual
         a 1024 representa 4 MB de memória compartilhada. Desta forma, as linhas
         acima aumentam para 32 MB o máximo de área de memória compartilhada.
         Para os usuários da versão 4.3 ou posterior, provavelmente será
         necessário aumentar <varname>KERNEL_VIRTUAL_MB</varname> para um valor
         acima do valor padrão de <literal>248</literal>. Uma vez que as
         alterações tenham sido efetuadas, o núcleo deve ser recompilado e o
         sistema reinicializado.
        </para>
       </formalpara>

       <para>
        Os usuários da versão 4.0, ou anterior, devem utilizar
        <command>bpatch</command> para descobrir o valor de
        <varname>sysptsize</varname> do núcleo corrente. Este valor é computado
        dinamicamente durante a inicialização do sistema operacional.
<screen>
<prompt>$</prompt> <userinput>bpatch -r sysptsize</userinput>
<computeroutput>0x9 = 9</computeroutput>
</screen>
        Em seguida, deve ser adicionado <varname>SYSPTSIZE</varname> com um
        valor fixo no arquivo de configuração do núcleo. O valor encontrado
        utilizando <command>bpatch</command> deve ser aumentado; deve ser
        adicionado 1 para cada 4 MB adicionais de memória compartilhada desejada.
<programlisting>
options "SYSPTSIZE=16"
</programlisting>
        <varname>sysptsize</> não pode ser mudado por <command>sysctl</>.
       </para>

       <formalpara>
        <title>Semáforos</title>
        <para>
         Provavelmente vai ser necessário aumentar o número de semáforos também;
         o valor total padrão do sistema, igual a 60, permite apenas em torno de
         50 conexões do <productname>PostgreSQL</productname>
         Os valores desejados devem ser definidos no arquivo de configuração
         do núcleo como, por exemplo:
<programlisting>
options "SEMMNI=40"
options "SEMMNS=240"
</programlisting>
        </para>
       </formalpara>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">FreeBSD</></term>
      <term><systemitem class="osname">NetBSD</></term>
      <term><systemitem class="osname">OpenBSD</></term>
      <indexterm><primary>FreeBSD</><secondary>configuração do IPC</></>
      <indexterm><primary>NetBSD</><secondary>configuração do IPC</></>
      <indexterm><primary>OpenBSD</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        As opções <varname>SYSVSHM</varname> e <varname>SYSVSEM</varname>
        precisam estar habilitadas quando o núcleo é compilado (Estão por
        padrão). O tamanho máximo da memória compartilhada é determinado pela
        opção <varname>SHMMAXPGS</varname> (em páginas). A seguir está
        mostrado um exemplo de como definir os vários parâmetros:
<programlisting>
options         SYSVSHM
options         SHMMAXPGS=4096
options         SHMSEG=256

options         SYSVSEM
options         SEMMNI=256
options         SEMMNS=512
options         SEMMNU=256
options         SEMMAP=256
</programlisting>
        (No <systemitem class="osname">NetBSD</systemitem> e no <systemitem
        class="osname">OpenBSD</systemitem> a palavra chave é, na verdade,
        <literal>option</literal>, no singular).
       </para>
       <para>
        Também pode-se querer configurar o núcleo para que bloqueie a memória
        compartilhada na RAM, impedindo que seja paginada para a área de troca
        (<literal>swap</literal>). Deve ser utilizada a definição
        <literal>kern.ipc.shm_use_phys</literal> do <command>sysctl</command>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">HP-UX</></term>
      <indexterm><primary>HP-UX</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        A definição padrão costuma ser suficiente para as instalações normais.
        No <productname>HP-UX</productname> 10, o padrão de fábrica para
        <varname>SEMMNS</varname> é 128, que pode ser muito baixo para
        servidores de banco de dados grandes.
       </para>
       <para>
        Os parâmetros do <acronym>IPC</acronym> podem ser definidos no
        <application>System Administration Manager</application>
        (<acronym>SAM</acronym>), sob <menuchoice><guimenu>Kernel
        Configuration</guimenu><guimenuitem>Configurable Parameters</></>.
        Quando tiver acabado clique em
        <guibutton>Create A New Kernel</guibutton>.
       </para>
      </listitem>
     </varlistentry>


     <varlistentry>
      <term><systemitem class="osname">Linux</></term>
      <indexterm><primary>Linux</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        O limite padrão de memória compartilhada (tanto
        <varname>SHMMAX</varname> quanto <varname>SHMALL</varname>) é de 32
        MB nos núcleos 2.2, mas pode ser modificado no arquivo de sistema
        <filename>proc</filename> (sem reinicializar o Linux). Por exemplo,
        para permitir 128 MB:
<screen>
<prompt>$</prompt> <userinput>echo 134217728 >/proc/sys/kernel/shmall</userinput>
<prompt>$</prompt> <userinput>echo 134217728 >/proc/sys/kernel/shmmax</userinput>
</screen>
        Estes comandos podem ser colocados em um script executado durante a
        inicialização.
       </para>

       <para>
        Como alternativa, pode ser utilizado <command>sysctl</command>, se
        estiver disponível, para controlar estes parâmetros. Deve-se procurar
        pelo arquivo chamado <filename>/etc/sysctl.conf</filename> e adicionar
        linhas como as mostradas abaixo ao arquivo:
<programlisting>
kernel.shmall = 134217728
kernel.shmmax = 134217728
</programlisting>
        Este arquivo geralmente é processado durante a inicialização, mas
        <command>sysctl</command> também pode ser chamada explicitamente
        posteriormente.
       </para>

       <para>
        Os outros parâmetros possuem tamanho suficiente para qualquer aplicação.
        Se quiser ver por si próprio, olhe em
        <filename>/usr/src/linux/include/asm-<replaceable>xxx</>/shmparam.h</>
        e <filename>/usr/src/linux/include/linux/sem.h</filename>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">MacOS X</></term>
      <indexterm><primary>MacOS X</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        No OS X 10.2, e anteriores, deve ser editado o arquivo
        <filename>/System/Library/StartupItems/SystemTuning/SystemTuning</>
        e modificados os valores nos seguintes comandos:
<programlisting>
sysctl -w kern.sysv.shmmax
sysctl -w kern.sysv.shmmin
sysctl -w kern.sysv.shmmni
sysctl -w kern.sysv.shmseg
sysctl -w kern.sysv.shmall
</programlisting>
        No OS X 10.3 estes comandos foram movidos para <filename>/etc/rc</>
        devendo ser editados neste local. É necessário reinicializar o
        computador para que as alterações tenham efeito. Deve ser observado que
        <filename>/etc/rc</> geralmente é sobrescrito pelas atualizações do
        <productname>OS X</productname> (como 10.3.6 para 10.3.7), portanto é
        esperado que seja necessário refazer a edição a cada atualização.
       </para>
       <para>
        Nesta plataforma <varname>SHMALL</> é medido em páginas de 4KB.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">SCO OpenServer</></term>
      <indexterm><primary>SCO OpenServer</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        Na configuração padrão, somente são permitidos 512 kB de memória
        compartilhada por segmento, suficiente para cerca de <option>-B 24 -N
        12</option>. Para aumentar esta definição, primeiro deve-se tornar o
        diretório <filename class="directory">/etc/conf/cf.d</filename>
        o diretório corrente. Para exibir o valor corrente de
        <varname>SHMMAX</varname> deve ser executado:
<programlisting>
./configure -y SHMMAX
</programlisting>
        Para definir um novo valor para <varname>SHMMAX</varname> deve ser
        executado
<programlisting>
./configure SHMMAX=<replaceable>valor</replaceable>
</programlisting>
        onde <replaceable>valor</replaceable> é o novo valor que se deseja
        utilizar (em bytes). Após definir <varname>SHMMAX</varname> o núcleo
        deve ser reconstruído
<programlisting>
./link_unix
</programlisting>
        e o sistema reinicializado.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">AIX</></term>
      <indexterm><primary>AIX</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        A partir da versão 5.1, no mínimo, não deve ser necessário fazer
        qualquer configuração especial para parâmetros como <varname>SHMMAX</>,
        uma vez que parece estar configurado para permitir que toda a memória
        seja utilizada como memória compartilhada. Este é o tipo de configuração
        utilizado normalmente para outros bancos de dados como o
        <application>DB2</application>.
       </para>

       <para>
        Pode, entretanto, ser necessário modificar a informação global
        <command>ulimit</command> em <filename>/etc/security/limits</filename>,
        uma vez que os limites rígidos padrão para o tamanho dos arquivos
        (<varname>fsize</varname>) e número de arquivos
        (<varname>nofiles</varname>) podem ser muito baixos.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">Solaris</></term>
      <indexterm><primary>Solaris</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        Ao menos na versão 2.6, o tamanho máximo padrão dos segmentos de
        memória compartilhada é muito baixo para o <productname>PostgreSQL</>.
        As definições relevantes podem ser mudadas em <filename>/etc/system</>
        como, por exemplo:
<programlisting>
set shmsys:shminfo_shmmax=0x2000000
set shmsys:shminfo_shmmin=1
set shmsys:shminfo_shmmni=256
set shmsys:shminfo_shmseg=256

set semsys:seminfo_semmap=256
set semsys:seminfo_semmni=512
set semsys:seminfo_semmns=512
set semsys:seminfo_semmsl=32
</programlisting>
        O computador deve ser reinicializado para as modificações terem efeito.
       </para>

       <para>
        Também deve ser consultada a página
        <ulink url="http://sunsite.uakom.sk/sunworldonline/swol-09-1997/swol-09-insidesolaris.html">
        Shared memory uncovered</ulink> para obter informações sobre memória
        compartilhada sob o <productname>Solaris</productname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><systemitem class="osname">UnixWare</></term>
      <indexterm><primary>UnixWare</><secondary>configuração do IPC</></>
      <listitem>
       <para>
        No <productname>UnixWare</productname> 7 o tamanho máximo para os
        segmentos de memória compartilhada é de 512 kB na configuração padrão.
        É suficiente para cerca de <option>-B 24 -N 12</option>. Para obter o
        valor corrente de <varname>SHMMAX</varname>, deve ser executado
<programlisting>
/etc/conf/bin/idtune -g SHMMAX
</programlisting>
        que mostra os valores corrente, padrão, mínimo e máximo.
        Para definir um novo valor para <varname>SHMMAX</varname>,
        deve ser executado
<programlisting>
/etc/conf/bin/idtune SHMMAX <replaceable>valor</replaceable>
</programlisting>
        onde <replaceable>valor</replaceable> é o novo valor que se deseja
        utilizar (em bytes). Após definir <varname>SHMMAX</varname>, o núcleo
        deve ser reconstruído:
<programlisting>
/etc/conf/bin/idbuild -B
</programlisting>
        e o sistema reinicializado.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>

  </sect2>

  <sect2>
   <title>Limites de recursos</title>

   <para>
    Os sistemas operacionais da família Unix obrigam respeitar vários tipos de
    limite de recursos que podem interferir com a operação do
    servidor <productname>PostgreSQL</productname>. São de particular
    importância os limites do número de processos por usuário, de número de
    arquivos abertos por processo, e a quantidade de memória disponível para
    cada processo. Cada um destes possui um limite <quote>rígido</quote> e um
    <quote>flexível</quote>. O limite flexível é o que realmente conta, mas
    pode ser alterado pelo usuário até o limite rígido. O limite rígido
    somente pode ser alterado pelo usuário <literal>root</literal>. A chamada de
    sistema <function>setrlimit</function> é responsável pela definição destes
    parâmetros. São utilizados o comando interno do interpretador de comandos
    <command>ulimit</command> (interpretadores de comandos Bourne) ou
    <command>limit</command> (<application>csh</application>) para controlar os
    limites de recursos a partir da linha de comandos. Nos sistemas derivados do
    BSD o arquivo <filename>/etc/login.conf</filename> controla os limites dos
    vários recursos definidos durante a autenticação. Para obter detalhes deve
    ser vista a documentação do sistema operacional. Os parâmetros relevantes
    são <varname>maxproc</varname>, <varname>openfiles</varname> e
    <varname>datasize</varname>. Por exemplo:
<programlisting>
default:\
...
        :datasize-cur=256M:\
        :maxproc-cur=256:\
        :openfiles-cur=256:\
...
</programlisting>
    (<literal>-cur</literal> é o limite flexível. Deve ser anexado
    <literal>-max</literal> para definir o limite rígido).
   </para>

   <para>
    Os núcleos também podem ter limites para alguns recursos para todo o sistema.
    <itemizedlist>
     <listitem>
      <para>
      No <productname>Linux</productname>
      <filename>/proc/sys/fs/file-max</filename> determina o
      número máximo de arquivos abertos que o núcleo pode suportar. Pode
      ser mudado escrevendo um número diferente no arquivo, ou
      adicionando uma atribuição em <filename>/etc/sysctl.conf</filename>.
      O limite máximo de arquivos por processo é fixado quando o núcleo é
      compilado; para obter informações adicionais deve ser consultado o arquivo
      <filename>/usr/src/linux/Documentation/proc.txt</filename>.
      </para>
     </listitem>
    </itemizedlist>
   </para>

   <para>
    O servidor <productname>PostgreSQL</productname> utiliza um processo por
    conexão e, portanto, deve ser especificado pelo menos tantos processos
    quantas forem as conexões permitidas, em adição ao que for necessário
    para o restante do sistema. Normalmente não é um problema, mas se forem
    executados vários servidores na mesma máquina pode ficar apertado.
   </para>

   <para>
    O limite padrão original para o número de arquivos abertos geralmente é
    definido como um valor <quote>socialmente amigável</quote>, para permitir a
    coexistência de muitos usuários em uma mesma máquina sem utilizar uma fração
    não apropriada dos recursos do sistema. Se forem executados vários
    servidores na mesma máquina provavelmente é o que se deseja, mas para
    servidores dedicados pode ser necessário aumentar este limite.
   </para>

   <para>
    Por outro lado, alguns sistemas podem permitir que cada processo abra
    um grande número de arquivos; se mais que uns poucos processos o fizerem,
    então o limite global para todo o sistema pode ser facilmente excedido.
    Se isto estiver acontecendo, e não for desejado alterar o limite para todo o
    sistema, pode ser definido o parâmetro de configuração
    <xref linkend="guc-max-files-per-process"> do <productname>PostgreSQL</>
    para limitar a quantidade de arquivos abertos.
   </para>
  </sect2>

  <sect2>
   <title>Sobre-alocação de memória no Linux</title>

   <para>
    No Linux 2.4 e posteriores, o comportamento padrão de memória virtual não é
    o ótimo para o <productname>PostgreSQL</productname>. Devido à maneira como
    o núcleo implementa a sobre-alocação (<literal>overcommit</literal>) de
    memória, o núcleo pode fechar o servidor <productname>PostgreSQL</> (o
    processo <filename>postmaster</filename>), se a demanda por memória de um
    outro processo fizer com que o sistema fique sem memória virtual.
    <footnote>
     <para>
      <literal>memory overcommit</literal> &mdash;
      a sobre-alocação de memória é uma funcionalidade do núcleo do Linux que
      permite as aplicações alocarem mais memória do que realmente existe.
      A idéia por trás desta funcionalidade é que algumas aplicações alocam
      grandes quantidades de memória <quote>apenas para o caso de
      precisarem</quote>, mas na verdade nunca utilizam esta memória. Portanto,
      a sobre-alocação de memória permite a execução de mais aplicações do
      que na verdade cabe na memória, desde de que as aplicações realmente não
      utilizem a memória alocada. Se o fizerem, o núcleo fecha o aplicativo.
      <ulink url="http://www.gnu.org/software/gnusound/Documentation/ar01s05.html">
      GNUsound - FAQ</ulink> (N. do T.)
     </para>
    </footnote>
   </para>

   <para>
    Caso aconteça, será vista uma mensagem do núcleo parecida com esta
    (deve ser consultada a documentação e configuração do sistema para achar
    onde este tipo de mensagem pode ser vista):
<programlisting>
Out of Memory: Killed process 12345 (postmaster).
</programlisting>
    Esta mensagem indica que o processo <filename>postmaster</filename>
    foi fechado devido à falta de memória.
    Embora as conexões com os bancos de dados existentes continuem funcionando
    normalmente, não é aceita nenhuma nova conexão. Para recuperar
    é necessário reinicializar o <productname>PostgreSQL</productname>.
   </para>

   <para>
    Uma forma de evitar este problema é executar o
    <productname>PostgreSQL</productname>
    em uma máquina onde se tenha certeza que outros processos não
    vão deixar a máquina sem memória.
   </para>

   <para>
    No Linux 2.6 e posteriores, uma solução melhor é modificar o comportamento
    do núcleo para que não haja <quote>sobre-alocação</quote> de memória. Isto é
    feito selecionando o modo estrito de sobre-alocação através do comando
    <command>sysctl</command>:
<programlisting>
sysctl -w vm.overcommit_memory=2
</programlisting>
    ou colocando uma entrada equivalente em <filename>/etc/sysctl.conf</>.
    Também pode ser necessário modificar a percentagem de sobre-alocação
    (<literal>vm.overcommit_ratio</literal>).
    Para obter detalhes deve ser visto o arquivo de documentação do núcleo
    <filename>Documentation/vm/overcommit-accounting</filename>.
    <footnote>
     <para>
      <productname>Fedora Core 3</productname> &mdash; arquivo
      <filename>/usr/share/doc/kernel-doc-2.6.11/Documentation/vm/overcommit-accounting</filename>
      &mdash; o núcleo do <systemitem class=osname>Linux</systemitem> suporta
      os seguintes modos de tratamento de sobre-alocação:
      0 - tratamento heurístico de sobre-alocação;
      1 - sempre faz sobre-alocação;
      2 - sem sobre-alocação. (N. do T.)
     </para>
    </footnote>
   </para>

   <para>
    Existe relato que algumas distribuições do núcleo 2.4 do Linux possuem uma
    versão inicial do parâmetro <literal>overcommit</literal> do comando
    <command>sysctl</command> da versão 2.6. Entretanto, definir
    <literal>vm.overcommit_memory</literal> como 2 em um núcleo que não possui
    o código relevante torna as coisas piores, e não melhores. Recomenda-se a
    inspeção do código fonte do núcleo utilizado (deve ser consultada a função
    <function>vm_enough_memory</function> no arquivo
    <filename>mm/mmap.c</filename>), para verificar o que é suportado na versão
    utilizada antes de tentar utilizar numa instalação 2.4. A presença do
    arquivo de documentação <filename>overcommit-accounting</filename>
    <emphasis>não</emphasis> deve ser assumida como um evidência que a
    funcionalidade está presente. Em caso de dúvida, deve ser consultado um
    especialista no núcleo ou o distribuidor do núcleo utilizado.
   </para>
  </sect2>
 </sect1>


 <sect1 id="postmaster-shutdown">
  <title>Parada do servidor</title>

  <indexterm zone="postmaster-shutdown">
   <primary>shutdown</>
  </indexterm>

  <para>
   Existem várias formas de parar o servidor de banco de dados. O tipo de
   parada pode ser controlado através do envio de sinais diferentes para o
   processo <command>postmaster</command>.

   <variablelist>
    <varlistentry>
     <term><systemitem>SIGTERM</systemitem><indexterm><primary>SIGTERM</></></term>
     <listitem>
      <para>
       Após receber o sinal <systemitem>SIGTERM</systemitem> o servidor
       não aceita novas conexões, mas deixa as sessões existentes trabalharem
       normalmente. A parada é realizada apenas depois de todas as sessões
       terminarem normalmente. Esta é a <firstterm>Parada Esperta</firstterm>
       (<literal>Smart Shutdown</literal>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGINT</systemitem><indexterm><primary>SIGINT</></></term>
     <listitem>
      <para>
       O servidor não aceita novas conexões e envia para todos os processos
       servidores existentes o sinal <systemitem>SIGTERM</systemitem>, fazendo
       com que estes interrompam suas transações correntes e terminem
       imediatamente. Depois aguarda os processos servidor sairem e, finalmente,
       pára. Esta é a <firstterm>Parada Rápida</firstterm>
       (<literal>Fast Shutdown</literal>).
      </para>
     </listitem>
    </varlistentry>

    <varlistentry>
     <term><systemitem>SIGQUIT</systemitem><indexterm><primary>SIGQUIT</></></term>
     <listitem>
      <para>
      Esta é a <firstterm>Parada Imediata</firstterm> (<literal>Immediate
      Shutdown</literal>), que faz o processo <command>postmaster</command>
      enviar um sinal <systemitem>SIGQUIT</systemitem> para todos os processos
      descendentes e sair imediatamente, sem parar de forma apropriada.
      Da mesma maneira, os processos descendentes saem imediatamente após
      receber o sinal <systemitem>SIGQUIT</systemitem>. Provoca uma recuperação
      (refaz o <literal>log</literal> do WAL) na próxima inicialização.
      Somente é recomendado em caso de emergência.
      </para>
     </listitem>
    </varlistentry>
   </variablelist>
  </para>

  <para>
   O programa <xref linkend="app-pg-ctl"> fornece uma interface conveniente
   para enviar estes sinais para parar o servidor.
  </para>

  <para>
   Como alternativa o sinal pode ser enviado diretamente através do comando
   <command>kill</command>.
   O <acronym>PID</acronym> do processo <command>postmaster</command> pode ser
   encontrado utilizando o programa <command>ps</command>, ou no arquivo
   <filename>postmaster.pid</filename> no diretório de dados. Portanto, para
   efetuar uma parada rápida pode ser utilizado, por exemplo:
<screen>
<prompt>$</prompt> <userinput>kill -INT `head -1 /usr/local/pgsql/data/postmaster.pid`</userinput>
</screen>
  </para>

   <important>
    <para>
     É melhor não utilizar <systemitem>SIGKILL</systemitem> para parar o
     servidor. Usá-lo impede que o servidor libere a memória compartilhada e os
     semáforos, o que poderá então ter de ser feito à mão antes de poder
     inicializar novamente o servidor.
     Além disso, o sinal <systemitem>SIGKILL</systemitem> mata o processo
     <command>postmaster</command> sem deixar que este repasse o sinal para
     seus subprocessos e, portanto, será necessário matar os subprocessos
     à mão também.
    </para>
   </important>
 </sect1>

 <sect1 id="ssl-tcp">
  <title>Conexões TCP/IP seguras com SSL</title>

  <indexterm zone="ssl-tcp">
   <primary>SSL</primary>
  </indexterm>

  <para>
   Para aumentar a segurança criptografando as comunicações cliente/servidor, o
   <productname>PostgreSQL</productname> possui suporte nativo para conexões
   <acronym>SSL</acronym>. É necessário que o <productname>OpenSSL</productname>
   esteja instalado tanto no cliente quanto no servidor, e que o suporte no
   <productname>PostgreSQL</productname> tenha sido habilitado em tempo de
   construção (consulte o <xref linkend="installation">).
  </para>

  <para>
   Uma vez compilado com suporte a <acronym>SSL</acronym>, o servidor
   <productname>PostgreSQL</productname> pode ser inicializado com
   <acronym>SSL</acronym> habilitado, definindo no arquivo
   <filename>postgresql.conf</filename> o parâmetro
   <xref linkend="guc-ssl"> com o valor <literal>on</literal>.
   Quando inicializado no modo <acronym>SSL</acronym>, o servidor procura pelos
   arquivos <filename>server.key</filename> e <filename>server.crt</filename>
   no diretório de dados, que devem conter a chave privada do servidor e o
   certificado, respectivamente. Estes arquivos devem ser configurados de forma
   correta para que o servidor possa ser inicializado com
   <acronym>SSL</acronym> habilitado. Se a chave privada estiver protegida por
   uma frase-senha (<literal>passphrase</literal>), o servidor solicitará esta
   frase-senha, não inicializando até que seja fornecida.
  </para>

  <para>
   O servidor atende tanto as conexões comuns quanto as conexões
   <acronym>SSL</acronym> na mesma porta TCP, e negocia com o cliente
   conectando se vai usar ou não o <acronym>SSL</acronym>.
   Por padrão esta é uma opção do cliente; deve ser visto na
   <xref linkend="auth-pg-hba-conf"> como configurar o servidor para que seja
   requerido o uso do <acronym>SSL</> para algumas ou para todas as conexões.
  </para>

  <para>
   Para obter detalhes sobre como criar a chave privada do servidor e o
   certificado, deve ser consultada a documentação do <productname>OpenSSL</>.
   Pode ser utilizado para testes um certificado auto-assinado, mas no ambiente
   de produção deve ser utilizado um certificado assinado por uma autoridade
   certificadora (<acronym>CA</acronym>) (por uma <acronym>CA</acronym> global
   ou por uma local), para que o cliente possa verificar a identidade do
   servidor. Para criar rapidamente um certificado auto-assinado pode ser
   utilizado o seguinte comando do <productname>OpenSSL</productname>:
<programlisting>
openssl req -new -text -out server.req
</programlisting>
   Devem ser fornecidas as informações solicitadas pelo <command>openssl</>.
   Assegure-se de especificar <quote>Common Name</quote> como nome do
   hospedeiro local; a senha desafio (<literal>challenge password</literal>)
   pode ser deixada em branco.
   O programa gera uma chave que é protegida por uma frase-senha; não é aceita
   uma frase-senha com menos de quatro caracteres. Para remover a frase-senha
   (o que deve ser feito se for desejada uma inicialização automática do
   servidor), devem ser executados os comandos:
<programlisting>
openssl rsa -in privkey.pem -out server.key
rm privkey.pem
</programlisting>
   Deve ser fornecida a frase-senha antiga para desbloquear a chave existente.
   Agora deve ser executado
<programlisting>
openssl req -x509 -in server.req -text -key server.key -out server.crt
chmod og-rwx server.key
</programlisting>
   para tornar o certificado um certificado auto-assinado, e para copiar a chave
   e o certificado para onde o servidor procura pelos mesmos.
  </para>

  <para>
   Se for requerida a verificação dos certificados cliente, devem ser colocados
   no arquivo <filename>root.crt</filename> no diretório de dados os
   certificados das <acronym>CA</acronym>(s) que se deseja verificar.
   Quando presente, é requisitado do cliente um certificado cliente durante a
   inicialização da conexão SSL, que deve ter sido assinado por um dos
   certificados presentes no arquivo <filename>root.crt</filename>.
  </para>

  <para>
   Quando o arquivo <filename>root.crt</filename> não está presente, os
   certificados cliente não são requeridos nem verificados. Neste modo o
   SSL fornece segurança para a comunicação, mas não para autenticação.
  </para>

  <para>
   Os arquivos <filename>server.key</>, <filename>server.crt</> e
   <filename>root.crt</filename> são examinados apenas durante a inicialização
   do servidor; o servidor deve ser reinicializado para que as alterações
   feitas nestes arquivos tenham efeito.
  </para>
 </sect1>

 <sect1 id="ssh-tunnels">
  <title>Conexões TCP/IP seguras por túneis SSH</title>

  <indexterm zone="ssh-tunnels">
   <primary>ssh</primary>
  </indexterm>

  <para>
   Pode ser utilizado o <application>SSH</application> para criptografar a
   conexão de rede entre os clientes e o servidor <productname>PostgreSQL</>.
   Feito de forma apropriada, fornece uma conexão de rede adequadamente segura,
   mesmo para clientes sem capacidade de <acronym>SSL</acronym>.
  </para>

  <para>
   Primeiro deve-se ter certeza que o servidor <application>SSH</application>
   está executando de forma apropriada na mesma máquina onde está o servidor
   <productname>PostgreSQL</productname>, e que é possível se conectar
   utilizando o <command>ssh</command> como algum usuário. Depois pode ser
   estabelecido, a partir da máquina cliente, um túnel seguro usando um comando
   como o mostrado abaixo:
<programlisting>
ssh -L 3333:foo.com:5432 joel@foo.com
</programlisting>
   O primeiro número no argumento <option>-L</option>, 3333, é o
   número da porta do lado cliente do túnel; pode ser escolhido livremente.
   O segundo número, 5432, é o fim remoto do túnel: o número da porta
   que o servidor está utilizando. O nome, ou endereço de IP, entre os
   números das portas é o hospedeiro do servidor de banco de dados onde vai ser
   feita a conexão. Para que seja possível conectar com o servidor de banco de
   dados utilizando este túnel, deve ser feita a conexão com a porta 3333 na
   máquina cliente:
<programlisting>
psql -h localhost -p 3333 template1
</programlisting>
   Para o servidor de banco de dados vai parecer como se fosse realmente
   o usuário <literal>joel@foo.com</literal>, e vai utilizar o procedimento de
   autenticação que estiver configurado para este usuário e hospedeiro.
   Deve ser observado que o servidor não vai supor que a conexão está
   criptografada por SSL, porque, na verdade, não está criptografada entre o
   servidor <application>SSH</application> e o servidor
   <productname>PostgreSQL</productname>. Isto não deve causar nenhum risco
   adicional à segurança, desde que estes dois servidores estejam na mesma
   máquina.
  </para>
  <para>
   Para que a configuração do túnel seja bem-sucedida, deve ser permitida a
   conexão através do <command>ssh</command> como
   <literal>joel@foo.com</literal>, da mesma maneira como se tivesse tentado
   utilizar o <command>ssh</command> para estabelecer uma sessão de terminal.
  </para>

  <tip>
   <para>
    Existem diversas outras aplicações que podem fornecer túneis seguros
    utilizando procedimentos conceitualmente semelhantes ao que foi descrito.
   </para>
  </tip>

 </sect1>

</Chapter>

<!-- Keep this comment at the end of the file
Local variables:
mode:sgml
sgml-omittag:nil
sgml-shorttag:t
sgml-minimize-attributes:nil
sgml-always-quote-attributes:t
sgml-indent-step:1
sgml-indent-data:t
sgml-parent-document:nil
sgml-default-dtd-file:"./reference.ced"
sgml-exposed-tags:nil
sgml-local-catalogs:("/usr/lib/sgml/catalog")
sgml-local-ecat-files:nil
End:
-->
